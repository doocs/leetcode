# [2849. 判断能否在给定时间到达单元格](https://leetcode.cn/problems/determine-if-a-cell-is-reachable-at-a-given-time)



## 题目描述

<!-- 这里写题目描述 -->

<p>给你四个整数 <code>sx</code>、<code>sy</code>、<code>fx</code>、<code>fy</code>&nbsp; 以及一个 <strong>非负整数</strong> <code>t</code> 。</p>

<p>在一个无限的二维网格中，你从单元格 <code>(sx, sy)</code> 开始出发。每一秒，你 <strong>必须</strong> 移动到任一与之前所处单元格相邻的单元格中。</p>

<p>如果你能在 <strong>恰好 </strong><code>t</code><strong> 秒</strong> 后到达单元格<em> </em><code>(fx, fy)</code> ，返回 <code>true</code> ；否则，返回&nbsp; <code>false</code> 。</p>

<p>单元格的 <strong>相邻单元格</strong> 是指该单元格周围与其至少共享一个角的 8 个单元格。你可以多次访问同一个单元格。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2800-2899/2849.Determine%20if%20a%20Cell%20Is%20Reachable%20at%20a%20Given%20Time/images/example2.svg" style="width: 443px; height: 243px;" />
<pre>
<strong>输入：</strong>sx = 2, sy = 4, fx = 7, fy = 7, t = 6
<strong>输出：</strong>true
<strong>解释：</strong>从单元格 (2, 4) 开始出发，穿过上图标注的单元格，可以在恰好 6 秒后到达单元格 (7, 7) 。 
</pre>

<p><strong class="example">示例 2：</strong></p>
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2800-2899/2849.Determine%20if%20a%20Cell%20Is%20Reachable%20at%20a%20Given%20Time/images/example1.svg" style="width: 383px; height: 202px;" />
<pre>
<strong>输入：</strong>sx = 3, sy = 1, fx = 7, fy = 3, t = 3
<strong>输出：</strong>false
<strong>解释：</strong>从单元格 (3, 1) 开始出发，穿过上图标注的单元格，至少需要 4 秒后到达单元格 (7, 3) 。 因此，无法在 3 秒后到达单元格 (7, 3) 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= sx, sy, fx, fy &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= t &lt;= 10<sup>9</sup></code></li>
</ul>

## 解法

### 方法一

=== "Python3"

    ```python
    class Solution:
        def isReachableAtTime(self, sx: int, sy: int, fx: int, fy: int, t: int) -> bool:
            if sx == fx and sy == fy:
                return t != 1
            dx = abs(sx - fx)
            dy = abs(sy - fy)
            return max(dx, dy) <= t
    ```

=== "Java"

    ```java
    class Solution {
        public boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {
            if (sx == fx && sy == fy) {
                return t != 1;
            }
            int dx = Math.abs(sx - fx);
            int dy = Math.abs(sy - fy);
            return Math.max(dx, dy) <= t;
        }
    }
    ```

=== "C++"

    ```cpp
    class Solution {
    public:
        bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {
            if (sx == fx && sy == fy) {
                return t != 1;
            }
            int dx = abs(fx - sx), dy = abs(fy - sy);
            return max(dx, dy) <= t;
        }
    };
    ```

=== "Go"

    ```go
    func isReachableAtTime(sx int, sy int, fx int, fy int, t int) bool {
    	if sx == fx && sy == fy {
    		return t != 1
    	}
    	dx := abs(sx - fx)
    	dy := abs(sy - fy)
    	return max(dx, dy) <= t
    }
    
    func abs(x int) int {
    	if x < 0 {
    		return -x
    	}
    	return x
    }
    ```

=== "TypeScript"

    ```ts
    function isReachableAtTime(sx: number, sy: number, fx: number, fy: number, t: number): boolean {
        if (sx === fx && sy === fy) {
            return t !== 1;
        }
        const dx = Math.abs(sx - fx);
        const dy = Math.abs(sy - fy);
        return Math.max(dx, dy) <= t;
    }
    ```

=== "C#"

    ```cs
    public class Solution {
        public bool IsReachableAtTime(int sx, int sy, int fx, int fy, int t) {
            if (sx == fx && sy == fy)
                return t != 1;
            return Math.Max(Math.Abs(sx - fx), Math.Abs(sy - fy)) <= t;
        }
    }
    ```


<!-- end -->
