# [332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary)

[English Version](/solution/0300-0399/0332.Reconstruct%20Itinerary/README_EN.md)

## 题目描述

<!-- 这里写题目描述 -->

<p>给定一个机票的字符串二维数组 <code>[from, to]</code>，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。</p>

<p> </p>

<p><strong>提示：</strong></p>

<ol>
	<li>如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 <code>["JFK", "LGA"]</code> 与 <code>["JFK", "LGB"]</code> 相比就更小，排序更靠前</li>
	<li>所有的机场都用三个大写字母表示（机场代码）。</li>
	<li>假定所有机票至少存在一种合理的行程。</li>
	<li>所有的机票必须都用一次 且 只能用一次。</li>
</ol>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<code><strong>输入：</strong></code><code>[["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]</code>
<strong>输出：</strong><code>["JFK", "MUC", "LHR", "SFO", "SJC"]</code>
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<code><strong>输入：</strong></code><code>[["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]</code>
<strong>输出：</strong><code>["JFK","ATL","JFK","SFO","ATL","SFO"]</code>
<strong>解释：</strong>另一种有效的行程是 <code>["JFK","SFO","ATL","JFK","ATL","SFO"]</code>。但是它自然排序更大更靠后。</pre>

## 解法

<!-- 这里可写通用的实现逻辑 -->

<!-- tabs:start -->

### **Python3**

<!-- 这里可写当前语言的特殊实现逻辑 -->

```python

```

### **Java**

<!-- 这里可写当前语言的特殊实现逻辑 -->

```java

```

### **...**

```

```

<!-- tabs:end -->
