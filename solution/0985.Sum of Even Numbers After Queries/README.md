# 查询后的偶数和

### 题目描述

给出一个整数数组 `A` 和一个查询数组 `queries`。

对于第 `i` 次查询，有 `val = queries[i][0], index = queries[i][1]`，我们会把 `val` 加到 `A[index]` 上。然后，第 `i` 次查询的答案是 `A` 中偶数值的和。

*（此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。）*

返回所有查询的答案。你的答案应当以数组 `answer` 给出，`answer[i]` 为第 `i` 次查询的答案。

**示例**

```
输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
输出：[8,6,2,4]
解释：
开始时，数组为 [1,2,3,4]。
将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。
将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。
将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。
将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。
```

**提示**

1. `1 <= A.length <= 10000`
2. `-10000 <= A[i] <= 10000`
3. `1 <= queries.length <= 10000`
4. `-10000 <= queries[i][0] <= 10000`
5. `0 <= queries[i][1] < A.length`

### 解法

**第一种解法：调整数组和**

**思路**

让我们尝试不断调整 `S`，即每一步操作之后整个数组的偶数和。

我们操作数组中的某一个元素 `A[index]` 的时候，数组 `A` 其他位置的元素都应保持不变。如果 `A[index]` 是偶数，我们就从 `S` 中减去它，然后计算 `A[index] + val` 对 `S` 的影响（如果是偶数则在 `S` 中加上它）。

这里有一些例子：

- 如果当前情况为 `A = [2,2,2,2,2]`、`S = 10`，并且需要执行 `A[0] += 4` 操作：我们应该先令 `S -= 2`，然后令 `S += 6`。最后得到 `A = [6,2,2,2,2]` 与 `S = 14`。
- 如果当前情况为 `A = [1,2,2,2,2]`、`S = 8`，同时需要执行 `A[0] += 3` 操作：我们会跳过第一次更新 `S` 的步骤（因为 `A[0]` 是奇数），然后令 `S += 4`。 最后得到 `A = [4,2,2,2,2]` 与 `S = 12`。
- 如果当前情况为 `A = [2,2,2,2,2]`、`S = 10`，同时需要执行 `A[0] += 1` 操作：我们先令 `S -= 2`，然后跳过第二次更新 `S` 的操作（因为 `A[0] + 1` 是奇数）。最后得到 `A = [3,2,2,2,2]` 与 `S = 8`。
- 如果当前情况为 `A = [1,2,2,2,2]`、`S = 8`，同时需要执行 `A[0] += 2` 操作：我们跳过第一次更新 `S` 的操作（因为 `A[0]` 是奇数），然后再跳过第二次更新 `S` 的操作（因为 `A[0] + 2` 是奇数）。最后得到 `A = [3,2,2,2,2]` 与 `S = 8`。

这些例子充分展现了我们的算法在每一次询问操作之后应该如何调整 `S` 。

**算法**

```javascript
var sumEvenAfterQueries = function (A, queries) {
  const len = A.length;        // A数组的长度
  const qlen = queries.length; // queries数组的长度
  let answer = [];
  let S = 0;
  for ( let i = 0; i < len; i++ ) {
    if (A[i] % 2 == 0) {
      S += A[i];
    }
  }
  for ( let j = 0; j < qlen; j++ ) {
    let val = queries[j][0];
    let index = queries[j][1];
    if ( A[index] % 2 == 0 ) {
      S -= A[index];
    }
    A[index] += val;
    if ( A[index] % 2 == 0 ) {
      S += A[index]
    }
    answer.push(S);
  }
  return answer;
};
```

**复杂度分析**

- 时间复杂度：O(N+Q)，其中 N 是数组 `A` 的长度， Q是询问 `queries` 的数量。
- 空间复杂度：O(N+Q)，事实上我们只使用了 O(1) 的额外空间。
