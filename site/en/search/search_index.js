var __index = {"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#introduction","title":"Introduction","text":"<p>Welcome to LeetCode Wiki!</p> <p>This project contains solutions for problems from LeetCode, \"Coding Interviews (2nd Edition)\", \"Coding Interviews (Special Edition)\", \"Cracking the Coding Interview (6th Edition)\", etc. All solutions are implemented in multiple programming languages, including but not limited to: Java, Python, C++, Go, TypeScript, Rust. We are working hard to update, welcome to Star \ud83c\udf1f and follow this project to get the latest updates.</p>"},{"location":"index.html#stargazers-over-time","title":"Stargazers over time","text":""},{"location":"index.html#backers-sponsors","title":"Backers &amp; Sponsors","text":"<p>Thank you to all our backers and sponsors!</p> <p></p> <p></p> <p>\"You help the developer community practice for interviews, and there is nothing better we could ask for.\" -- Alan Yessenbayev</p>"},{"location":"index.html#copyright","title":"Copyright","text":"<p>The copyright of this project belongs to Doocs community. For commercial reprints, please contact @yanglbme for authorization. For non-commercial reprints, please indicate the source.</p>"},{"location":"index.html#contact-us","title":"Contact Us","text":"<p>We welcome everyone to add @yanglbme's personal WeChat (WeChat ID: YLB0109), with the note \"leetcode\". In the future, we will create algorithm and technology related discussion groups, where we can learn and share experiences together, and make progress together.</p>"},{"location":"index.html#license","title":"License","text":"<p>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</p>"},{"location":"tags.html","title":"Tags","text":"<p>Below is a list of problems classified by tags, suitable for focused practice on a certain type of problem.</p>"},{"location":"intro/contribution.html","title":"Contribution","text":""},{"location":"intro/contribution.html#our-top-contributors","title":"Our Top Contributors","text":"<p>This project exists thanks to all the people who contribute.</p> <p></p>"},{"location":"intro/contribution.html#contributions","title":"Contributions","text":"<p>We're looking for long-term contributors/partners to this repo! Send me PRs if you're interested! See the following:</p> <ol> <li>Fork this repository to your own GitHub account and then clone it to your local machine.</li> <li>Checkout a new branch.</li> <li>Make some changes to your leetcode repository, then push the changes to your remote GitHub repository.</li> <li>Create a pull request with your changes!</li> <li>See CONTRIBUTING or GitHub Help for more details.</li> </ol> <p> </p> <p></p>"},{"location":"lc/1.html","title":"1. Two Sum","text":""},{"location":"lc/1.html#description","title":"Description","text":"<p>Given an array of integers <code>nums</code>\u00a0and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p> <p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p> <p>You can return the answer in any order.</p> <p> </p> <p>Example 1:</p> <pre>\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre> <p>Example 2:</p> <pre>\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n</pre> <p>Example 3:</p> <pre>\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n</pre> <p> </p> <p>Constraints:</p> <ul> <li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li> <li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li> <li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li> <li>Only one valid answer exists.</li> </ul> <p> </p> <p>Follow-up:\u00a0Can you come up with an algorithm that is less than <code>O(n<sup>2</sup>)</code> time complexity?</p>"},{"location":"lc/1.html#solutions","title":"Solutions","text":""},{"location":"lc/1.html#solution-1-hash-table","title":"Solution 1: Hash Table","text":"<p>We can use the hash table $m$ to store the array value and the corresponding subscript.</p> <p>Traverse the array <code>nums</code>, when you find <code>target - nums[i]</code> in the hash table, it means that the target value is found, and the index of <code>target - nums[i]</code> and $i$ are returned.</p> <p>The time complexity is $O(n)$ and the space complexity is $O(n)$. Where $n$ is the length of the array <code>nums</code>.</p> Python3JavaC++GoTypeScriptRustJavaScriptC#PHPScalaSwiftRubyNim <pre><code>class Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        m = {}\n        for i, x in enumerate(nums):\n            y = target - x\n            if y in m:\n                return [m[y], i]\n            m[x] = i\n</code></pre> <pre><code>class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;();\n        for (int i = 0;; ++i) {\n            int x = nums[i];\n            int y = target - x;\n            if (m.containsKey(y)) {\n                return new int[] {m.get(y), i};\n            }\n            m.put(x, i);\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; m;\n        for (int i = 0;; ++i) {\n            int x = nums[i];\n            int y = target - x;\n            if (m.count(y)) {\n                return {m[y], i};\n            }\n            m[x] = i;\n        }\n    }\n};\n</code></pre> <pre><code>func twoSum(nums []int, target int) []int {\n    m := map[int]int{}\n    for i := 0; ; i++ {\n        x := nums[i]\n        y := target - x\n        if j, ok := m[y]; ok {\n            return []int{j, i}\n        }\n        m[x] = i\n    }\n}\n</code></pre> <pre><code>function twoSum(nums: number[], target: number): number[] {\n    const m: Map&lt;number, number&gt; = new Map();\n\n    for (let i = 0; ; ++i) {\n        const x = nums[i];\n        const y = target - x;\n\n        if (m.has(y)) {\n            return [m.get(y)!, i];\n        }\n\n        m.set(x, i);\n    }\n}\n</code></pre> <pre><code>use std::collections::HashMap;\n\nimpl Solution {\n    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {\n        let mut map = HashMap::new();\n        for (i, item) in nums.iter().enumerate() {\n            if map.contains_key(item) {\n                return vec![i as i32, map[item]];\n            } else {\n                let x = target - nums[i];\n                map.insert(x, i as i32);\n            }\n        }\n        unreachable!()\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (nums, target) {\n    const m = new Map();\n    for (let i = 0; ; ++i) {\n        const x = nums[i];\n        const y = target - x;\n        if (m.has(y)) {\n            return [m.get(y), i];\n        }\n        m.set(x, i);\n    }\n};\n</code></pre> <pre><code>public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n        var m = new Dictionary&lt;int, int&gt;();\n        for (int i = 0, j; ; ++i) {\n            int x = nums[i];\n            int y = target - x;\n            if (m.TryGetValue(y, out j)) {\n                return new [] {j, i};\n            }\n            if (!m.ContainsKey(x)) {\n                m.Add(x, i);\n            }\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[]\n     */\n    function twoSum($nums, $target) {\n        foreach ($nums as $key =&gt; $x) {\n            $y = $target - $x;\n            if (isset($hashtable[$y])) {\n                return [$hashtable[$y], $key];\n            }\n            $hashtable[$x] = $key;\n        }\n    }\n}\n</code></pre> <pre><code>import scala.collection.mutable\n\nobject Solution {\n  def twoSum(nums: Array[Int], target: Int): Array[Int] = {\n    var map = new mutable.HashMap[Int, Int]()\n    for (i &lt;- 0 to nums.length) {\n      if (map.contains(target - nums(i))) {\n        return Array(map(target - nums(i)), i)\n      } else {\n        map += (nums(i) -&gt; i)\n      }\n    }\n    Array(0, 0)\n  }\n}\n</code></pre> <pre><code>class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] {\n        var m = [Int: Int]()\n        var i = 0\n        while true {\n            let x = nums[i]\n            let y = target - nums[i]\n            if let j = m[target - nums[i]] {\n                return [j, i]\n            }\n            m[nums[i]] = i\n            i += 1\n        }\n    }\n}\n</code></pre> <pre><code># @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef two_sum(nums, target)\n  nums.each_with_index do |x, idx|\n    if nums.include? target - x\n      return [idx, nums.index(target - x)] if nums.index(target - x) != idx\n    end\n    next\n  end\nend\n</code></pre> <pre><code>import std/enumerate\n\nproc twoSum(nums: seq[int], target: int): seq[int] =\n    var\n        bal: int\n        tdx: int\n    for idx, val in enumerate(nums):\n        bal = target - val\n        if bal in nums:\n            tdx = nums.find(bal)\n            if idx != tdx:\n                return @[idx, tdx]\n</code></pre>"},{"location":"lc/2.html","title":"2. Add Two Numbers","text":""},{"location":"lc/2.html#description","title":"Description","text":"<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum\u00a0as a linked list.</p> <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p> <p> </p> <p>Example 1:</p> <p></p> <pre>\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n</pre> <p>Example 2:</p> <pre>\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n</pre> <p>Example 3:</p> <pre>\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n</pre> <p> </p> <p>Constraints:</p> <ul> <li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li> <li><code>0 &lt;= Node.val &lt;= 9</code></li> <li>It is guaranteed that the list represents a number that does not have leading zeros.</li> </ul>"},{"location":"lc/2.html#solutions","title":"Solutions","text":""},{"location":"lc/2.html#solution-1-simulation","title":"Solution 1: Simulation","text":"<p>We traverse two linked lists $l_1$ and $l_2$ at the same time, and use the variable $carry$ to indicate whether there is a carry.</p> <p>Each time we traverse, we take out the current bit of the corresponding linked list, calculate the sum with the carry $carry$, and then update the value of the carry. Then we add the current bit to the answer linked list. If both linked lists are traversed, and the carry is $0$, the traversal ends.</p> <p>Finally, we return the head node of the answer linked list.</p> <p>The time complexity is $O(\\max (m, n))$, where $m$ and $n$ are the lengths of the two linked lists. We need to traverse the entire position of the two linked lists, and each position only needs $O(1)$ time. Ignoring the space consumption of the answer, the space complexity is $O(1)$.</p> Python3JavaC++GoTypeScriptRustJavaScriptC#PHPSwiftRubyNim <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -&gt; Optional[ListNode]:\n        dummy = ListNode()\n        carry, curr = 0, dummy\n        while l1 or l2 or carry:\n            s = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n            carry, val = divmod(s, 10)\n            curr.next = ListNode(val)\n            curr = curr.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummy.next\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        int carry = 0;\n        ListNode cur = dummy;\n        while (l1 != null || l2 != null || carry != 0) {\n            int s = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry;\n            carry = s / 10;\n            cur.next = new ListNode(s % 10);\n            cur = cur.next;\n            l1 = l1 == null ? null : l1.next;\n            l2 = l2 == null ? null : l2.next;\n        }\n        return dummy.next;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode();\n        int carry = 0;\n        ListNode* cur = dummy;\n        while (l1 || l2 || carry) {\n            int s = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + carry;\n            carry = s / 10;\n            cur-&gt;next = new ListNode(s % 10);\n            cur = cur-&gt;next;\n            l1 = l1 ? l1-&gt;next : nullptr;\n            l2 = l2 ? l2-&gt;next : nullptr;\n        }\n        return dummy-&gt;next;\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    dummy := &amp;ListNode{}\n    carry := 0\n    cur := dummy\n    for l1 != nil || l2 != nil || carry != 0 {\n        s := carry\n        if l1 != nil {\n            s += l1.Val\n        }\n        if l2 != nil {\n            s += l2.Val\n        }\n        carry = s / 10\n        cur.Next = &amp;ListNode{s % 10, nil}\n        cur = cur.Next\n        if l1 != nil {\n            l1 = l1.Next\n        }\n        if l2 != nil {\n            l2 = l2.Next\n        }\n    }\n    return dummy.Next\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    const dummy = new ListNode();\n    let cur = dummy;\n    let sum = 0;\n    while (l1 != null || l2 != null || sum !== 0) {\n        if (l1 != null) {\n            sum += l1.val;\n            l1 = l1.next;\n        }\n        if (l2 != null) {\n            sum += l2.val;\n            l2 = l2.next;\n        }\n        cur.next = new ListNode(sum % 10);\n        cur = cur.next;\n        sum = Math.floor(sum / 10);\n    }\n    return dummy.next;\n}\n</code></pre> <pre><code>// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -&gt; Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn add_two_numbers(\n        mut l1: Option&lt;Box&lt;ListNode&gt;&gt;,\n        mut l2: Option&lt;Box&lt;ListNode&gt;&gt;\n    ) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n        let mut dummy = Some(Box::new(ListNode::new(0)));\n        let mut cur = &amp;mut dummy;\n        let mut sum = 0;\n        while l1.is_some() || l2.is_some() || sum != 0 {\n            if let Some(node) = l1 {\n                sum += node.val;\n                l1 = node.next;\n            }\n            if let Some(node) = l2 {\n                sum += node.val;\n                l2 = node.next;\n            }\n            cur.as_mut().unwrap().next = Some(Box::new(ListNode::new(sum % 10)));\n            cur = &amp;mut cur.as_mut().unwrap().next;\n            sum /= 10;\n        }\n        dummy.unwrap().next.take()\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n    const dummy = new ListNode();\n    let carry = 0;\n    let cur = dummy;\n    while (l1 || l2 || carry) {\n        const s = (l1?.val || 0) + (l2?.val || 0) + carry;\n        carry = Math.floor(s / 10);\n        cur.next = new ListNode(s % 10);\n        cur = cur.next;\n        l1 = l1?.next;\n        l2 = l2?.next;\n    }\n    return dummy.next;\n};\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        int carry = 0;\n        ListNode cur = dummy;\n        while (l1 != null || l2 != null || carry != 0) {\n            int s = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry;\n            carry = s / 10;\n            cur.next = new ListNode(s % 10);\n            cur = cur.next;\n            l1 = l1 == null ? null : l1.next;\n            l2 = l2 == null ? null : l2.next;\n        }\n        return dummy.next;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this-&gt;val = $val;\n *         $this-&gt;next = $next;\n *     }\n * }\n */\nclass Solution {\n    /**\n     * @param ListNode $l1\n     * @param ListNode $l2\n     * @return ListNode\n     */\n    function addTwoNumbers($l1, $l2) {\n        $dummy = new ListNode(0);\n        $current = $dummy;\n        $carry = 0;\n\n        while ($l1 !== null || $l2 !== null) {\n            $x = $l1 !== null ? $l1-&gt;val : 0;\n            $y = $l2 !== null ? $l2-&gt;val : 0;\n\n            $sum = $x + $y + $carry;\n            $carry = (int) ($sum / 10);\n            $current-&gt;next = new ListNode($sum % 10);\n            $current = $current-&gt;next;\n\n            if ($l1 !== null) {\n                $l1 = $l1-&gt;next;\n            }\n\n            if ($l2 !== null) {\n                $l2 = $l2-&gt;next;\n            }\n        }\n\n        if ($carry &gt; 0) {\n            $current-&gt;next = new ListNode($carry);\n        }\n\n        return $dummy-&gt;next;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? {\n        var dummy = ListNode.init()\n        var carry = 0\n        var l1 = l1\n        var l2 = l2\n        var cur = dummy\n        while l1 != nil || l2 != nil || carry != 0 {\n            let s = (l1?.val ?? 0) + (l2?.val ?? 0) + carry\n            carry = s / 10\n            cur.next = ListNode.init(s % 10)\n            cur = cur.next!\n            l1 = l1?.next\n            l2 = l2?.next\n        }\n        return dummy.next\n    }\n}\n</code></pre> <pre><code># Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} l1\n# @param {ListNode} l2\n# @return {ListNode}\ndef add_two_numbers(l1, l2)\n    dummy = ListNode.new()\n    carry = 0\n    cur = dummy\n    while !l1.nil? || !l2.nil? || carry &gt; 0\n        s = (l1.nil? ? 0 : l1.val) + (l2.nil? ? 0 : l2.val) + carry\n        carry = s / 10\n        cur.next = ListNode.new(s % 10)\n        cur = cur.next\n        l1 = l1.nil? ? l1 : l1.next\n        l2 = l2.nil? ? l2 : l2.next\n    end\n    dummy.next\nend\n</code></pre> <pre><code>#[\n    # Driver code in the solution file\n    # Definition for singly-linked list.\n    type\n    Node[int] = ref object\n        value: int\n        next: Node[int]\n\n    SinglyLinkedList[T] = object\n        head, tail: Node[T]\n]#\n\n# More efficient code churning ...\nproc addTwoNumbers(l1: var SinglyLinkedList, l2: var SinglyLinkedList): SinglyLinkedList[int] =\n  var\n    aggregate: SinglyLinkedList\n    psum: seq[char]\n    temp_la, temp_lb: seq[int]\n\n  while not l1.head.isNil:\n    temp_la.add(l1.head.value)\n    l1.head = l1.head.next\n\n  while not l2.head.isNil:\n    temp_lb.add(l2.head.value)\n    l2.head = l2.head.next\n\n  psum = reversed($(reversed(temp_la).join(\"\").parseInt() + reversed(temp_lb).join(\"\").parseInt()))\n  for i in psum: aggregate.append(($i).parseInt())\n\n  result = aggregate\n</code></pre>"},{"location":"lcci/1.1.html","title":"01.01. Is Unique","text":""},{"location":"lcci/1.1.html#description","title":"Description","text":"<p>Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?</p> <p>Example 1:</p> <pre>\n\nInput:  = \"leetcode\"\n\nOutput: false\n\n</pre> <p>Example 2:</p> <pre>\n\nInput: s = \"abc\"\n\nOutput: true\n\n</pre> <p>Note:</p> <ul> <li><code>0 &lt;= len(s) &lt;= 100 </code></li> </ul>"},{"location":"lcci/1.1.html#solutions","title":"Solutions","text":""},{"location":"lcci/1.1.html#solution-1-bit-manipulation","title":"Solution 1: Bit Manipulation","text":"<p>Based on the examples, we can assume that the string only contains lowercase letters (which is confirmed by actual verification).</p> <p>Therefore, we can use each bit of a $32$-bit integer <code>mask</code> to represent whether each character in the string has appeared.</p> <p>The time complexity is $O(n)$, where $n$ is the length of the string. The space complexity is $O(1)$.</p> Python3JavaC++GoTypeScriptJavaScript <pre><code>class Solution:\n    def isUnique(self, astr: str) -&gt; bool:\n        mask = 0\n        for c in astr:\n            i = ord(c) - ord('a')\n            if (mask &gt;&gt; i) &amp; 1:\n                return False\n            mask |= 1 &lt;&lt; i\n        return True\n</code></pre> <pre><code>class Solution {\n    public boolean isUnique(String astr) {\n        int mask = 0;\n        for (char c : astr.toCharArray()) {\n            int i = c - 'a';\n            if (((mask &gt;&gt; i) &amp; 1) == 1) {\n                return false;\n            }\n            mask |= 1 &lt;&lt; i;\n        }\n        return true;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    bool isUnique(string astr) {\n        int mask = 0;\n        for (char c : astr) {\n            int i = c - 'a';\n            if (mask &gt;&gt; i &amp; 1) {\n                return false;\n            }\n            mask |= 1 &lt;&lt; i;\n        }\n        return true;\n    }\n};\n</code></pre> <pre><code>func isUnique(astr string) bool {\n    mask := 0\n    for _, c := range astr {\n        i := c - 'a'\n        if mask&gt;&gt;i&amp;1 == 1 {\n            return false\n        }\n        mask |= 1 &lt;&lt; i\n    }\n    return true\n}\n</code></pre> <pre><code>function isUnique(astr: string): boolean {\n    let mask = 0;\n    for (let j = 0; j &lt; astr.length; ++j) {\n        const i = astr.charCodeAt(j) - 'a'.charCodeAt(0);\n        if ((mask &gt;&gt; i) &amp; 1) {\n            return false;\n        }\n        mask |= 1 &lt;&lt; i;\n    }\n    return true;\n}\n</code></pre> <pre><code>/**\n * @param {string} astr\n * @return {boolean}\n */\nvar isUnique = function (astr) {\n    let mask = 0;\n    for (const c of astr) {\n        const i = c.charCodeAt() - 'a'.charCodeAt();\n        if ((mask &gt;&gt; i) &amp; 1) {\n            return false;\n        }\n        mask |= 1 &lt;&lt; i;\n    }\n    return true;\n};\n</code></pre>"},{"location":"lcci/1.2.html","title":"01.02. Check Permutation","text":""},{"location":"lcci/1.2.html#description","title":"Description","text":"<p>Given two strings,write a method to decide if one is a permutation of the other.</p> <p>Example 1:</p> <pre>\n\nInput: s1 = \"abc\", s2 = \"bca\"\n\nOutput: true\n\n</pre> <p>Example 2:</p> <pre>\n\nInput: s1 = \"abc\", s2 = \"bad\"\n\nOutput: false\n\n</pre> <p>Note:</p> <ol> <li><code>0 &lt;= len(s1) &lt;= 100 </code></li> <li><code>0 &lt;= len(s2) &lt;= 100</code></li> </ol>"},{"location":"lcci/1.2.html#solutions","title":"Solutions","text":""},{"location":"lcci/1.2.html#solution-1-array-or-hash-table","title":"Solution 1: Array or Hash Table","text":"<p>First, we check whether the lengths of the two strings are equal. If they are not equal, we directly return <code>false</code>.</p> <p>Then, we use an array or hash table to count the occurrence of each character in string $s1$.</p> <p>Next, we traverse the other string $s2$. For each character we encounter, we decrement its corresponding count. If the count after decrementing is less than $0$, it means that the occurrence of characters in the two strings is different, so we directly return <code>false</code>.</p> <p>Finally, after traversing string $s2$, we return <code>true</code>.</p> <p>Note: In this problem, all test case strings only contain lowercase letters, so we can directly create an array of length $26$ for counting.</p> <p>The time complexity is $O(n)$, and the space complexity is $O(C)$. Here, $n$ is the length of the string, and $C$ is the size of the character set. In this problem, $C=26$.</p> Python3JavaC++GoTypeScriptRustJavaScript <pre><code>class Solution:\n    def CheckPermutation(self, s1: str, s2: str) -&gt; bool:\n        return Counter(s1) == Counter(s2)\n</code></pre> <pre><code>class Solution {\n    public boolean CheckPermutation(String s1, String s2) {\n        if (s1.length() != s2.length()) {\n            return false;\n        }\n        int[] cnt = new int[26];\n        for (char c : s1.toCharArray()) {\n            ++cnt[c - 'a'];\n        }\n        for (char c : s2.toCharArray()) {\n            if (--cnt[c - 'a'] &lt; 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    bool CheckPermutation(string s1, string s2) {\n        if (s1.size() != s2.size()) return false;\n        int cnt[26] = {0};\n        for (char&amp; c : s1) ++cnt[c - 'a'];\n        for (char&amp; c : s2)\n            if (--cnt[c - 'a'] &lt; 0) return false;\n        return true;\n    }\n};\n</code></pre> <pre><code>func CheckPermutation(s1 string, s2 string) bool {\n    if len(s1) != len(s2) {\n        return false\n    }\n    cnt := make([]int, 26)\n    for _, c := range s1 {\n        cnt[c-'a']++\n    }\n    for _, c := range s2 {\n        cnt[c-'a']--\n        if cnt[c-'a'] &lt; 0 {\n            return false\n        }\n    }\n    return true\n}\n</code></pre> <pre><code>function CheckPermutation(s1: string, s2: string): boolean {\n    const n = s1.length;\n    const m = s2.length;\n    if (n !== m) {\n        return false;\n    }\n    const map = new Map&lt;string, number&gt;();\n    for (let i = 0; i &lt; n; i++) {\n        map.set(s1[i], (map.get(s1[i]) ?? 0) + 1);\n        map.set(s2[i], (map.get(s2[i]) ?? 0) - 1);\n    }\n    for (const v of map.values()) {\n        if (v !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\n</code></pre> <pre><code>use std::collections::HashMap;\nimpl Solution {\n    pub fn check_permutation(s1: String, s2: String) -&gt; bool {\n        let n = s1.len();\n        let m = s2.len();\n        if n != m {\n            return false;\n        }\n        let s1 = s1.as_bytes();\n        let s2 = s2.as_bytes();\n        let mut map = HashMap::new();\n        for i in 0..n {\n            *map.entry(s1[i]).or_insert(0) += 1;\n            *map.entry(s2[i]).or_insert(0) -= 1;\n        }\n        map.values().all(|i| *i == 0)\n    }\n}\n</code></pre> <pre><code>/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar CheckPermutation = function (s1, s2) {\n    if (s1.length != s2.length) {\n        return false;\n    }\n    const cnt = new Array(26).fill(0);\n    for (let i = 0; i &lt; s1.length; ++i) {\n        const j = s1.codePointAt(i) - 'a'.codePointAt(0);\n        ++cnt[j];\n    }\n    for (let i = 0; i &lt; s2.length; ++i) {\n        const j = s2.codePointAt(i) - 'a'.codePointAt(0);\n        if (--cnt[j] &lt; 0) {\n            return false;\n        }\n    }\n    return true;\n};\n</code></pre>"},{"location":"lcci/1.2.html#solution-2-sorting","title":"Solution 2: Sorting","text":"<p>We can also sort the two strings in lexicographical order, and then compare whether the two strings are equal.</p> <p>The time complexity is $O(n \\times \\log n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string.</p> Python3JavaC++GoTypeScriptRust <pre><code>class Solution:\n    def CheckPermutation(self, s1: str, s2: str) -&gt; bool:\n        return sorted(s1) == sorted(s2)\n</code></pre> <pre><code>class Solution {\n    public boolean CheckPermutation(String s1, String s2) {\n        char[] cs1 = s1.toCharArray();\n        char[] cs2 = s2.toCharArray();\n        Arrays.sort(cs1);\n        Arrays.sort(cs2);\n        return Arrays.equals(cs1, cs2);\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    bool CheckPermutation(string s1, string s2) {\n        sort(s1.begin(), s1.end());\n        sort(s2.begin(), s2.end());\n        return s1 == s2;\n    }\n};\n</code></pre> <pre><code>func CheckPermutation(s1 string, s2 string) bool {\n    cs1, cs2 := []byte(s1), []byte(s2)\n    sort.Slice(cs1, func(i, j int) bool { return cs1[i] &lt; cs1[j] })\n    sort.Slice(cs2, func(i, j int) bool { return cs2[i] &lt; cs2[j] })\n    return string(cs1) == string(cs2)\n}\n</code></pre> <pre><code>function CheckPermutation(s1: string, s2: string): boolean {\n    return [...s1].sort().join('') === [...s2].sort().join('');\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn check_permutation(s1: String, s2: String) -&gt; bool {\n        let mut s1: Vec&lt;char&gt; = s1.chars().collect();\n        let mut s2: Vec&lt;char&gt; = s2.chars().collect();\n        s1.sort();\n        s2.sort();\n        s1 == s2\n    }\n}\n</code></pre>"},{"location":"lcci/1.3.html","title":"01.03. String to URL","text":""},{"location":"lcci/1.3.html#description","title":"Description","text":"<p>Write a method to replace all spaces in a string with '%20'. You may assume that the string has sufficient space at the end to hold the additional characters,and that you are given the \"true\" length of the string. (Note: If implementing in Java,please use a character array so that you can perform this operation in place.)</p> <p>Example 1:</p> <pre>\n\nInput: \"Mr John Smith \", 13\n\nOutput: \"Mr%20John%20Smith\"\n\nExplanation: \n\nThe missing numbers are [5,6,8,...], hence the third missing number is 8.\n\n</pre> <p>Example 2:</p> <pre>\n\nInput: \"               \", 5\n\nOutput: \"%20%20%20%20%20\"\n\n</pre> <p> </p> <p>Note:</p> <ol> <li><code>0 &lt;= S.length &lt;= 500000</code></li> </ol>"},{"location":"lcci/1.3.html#solutions","title":"Solutions","text":""},{"location":"lcci/1.3.html#solution-1-using-replace-function","title":"Solution 1: Using <code>replace()</code> function","text":"<p>Directly use <code>replace</code> to replace all <code></code> with <code>%20</code>:</p> <p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string.</p> Python3TypeScriptRustJavaScript <pre><code>class Solution:\n    def replaceSpaces(self, S: str, length: int) -&gt; str:\n        return S[:length].replace(' ', '%20')\n</code></pre> <pre><code>function replaceSpaces(S: string, length: number): string {\n    return S.slice(0, length).replace(/\\s/g, '%20');\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn replace_spaces(s: String, length: i32) -&gt; String {\n        s[..length as usize].replace(' ', \"%20\")\n    }\n}\n</code></pre> <pre><code>/**\n * @param {string} S\n * @param {number} length\n * @return {string}\n */\nvar replaceSpaces = function (S, length) {\n    return encodeURI(S.substring(0, length));\n};\n</code></pre>"},{"location":"lcci/1.3.html#solution-2-simulation","title":"Solution 2: Simulation","text":"<p>Traverse each character $c$ in the string. When encountering a space, add <code>%20</code> to the result, otherwise add $c$.</p> <p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string.</p> Python3JavaGoRust <pre><code>class Solution:\n    def replaceSpaces(self, S: str, length: int) -&gt; str:\n        return ''.join(['%20' if c == ' ' else c for c in S[:length]])\n</code></pre> <pre><code>class Solution {\n    public String replaceSpaces(String S, int length) {\n        char[] cs = S.toCharArray();\n        int j = cs.length;\n        for (int i = length - 1; i &gt;= 0; --i) {\n            if (cs[i] == ' ') {\n                cs[--j] = '0';\n                cs[--j] = '2';\n                cs[--j] = '%';\n            } else {\n                cs[--j] = cs[i];\n            }\n        }\n        return new String(cs, j, cs.length - j);\n    }\n}\n</code></pre> <pre><code>func replaceSpaces(S string, length int) string {\n    // return url.PathEscape(S[:length])\n    j := len(S)\n    b := []byte(S)\n    for i := length - 1; i &gt;= 0; i-- {\n        if b[i] == ' ' {\n            b[j-1] = '0'\n            b[j-2] = '2'\n            b[j-3] = '%'\n            j -= 3\n        } else {\n            b[j-1] = b[i]\n            j--\n        }\n    }\n    return string(b[j:])\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn replace_spaces(s: String, length: i32) -&gt; String {\n        s.chars()\n            .take(length as usize)\n            .map(|c| {\n                if c == ' ' { \"%20\".to_string() } else { c.to_string() }\n            })\n            .collect()\n    }\n}\n</code></pre>"},{"location":"lcci/1.4.html","title":"01.04. Palindrome Permutation","text":""},{"location":"lcci/1.4.html#description","title":"Description","text":"<p>Given a string, write a function to check if it is a permutation of a palin\u00ad drome. A palindrome is a word or phrase that is the same forwards and backwards. A permutation is a rearrangement of letters. The palindrome does not need to be limited to just dictionary words.</p> <p> </p> <p>Example1: </p> <pre>\n\nInput: \"tactcoa\"\n\nOutput: true\uff08permutations: \"tacocat\"\u3001\"atcocta\", etc.\uff09\n\n</pre>"},{"location":"lcci/1.4.html#solutions","title":"Solutions","text":""},{"location":"lcci/1.4.html#solution-1-hash-table","title":"Solution 1: Hash Table","text":"<p>We use a hash table $cnt$ to store the occurrence count of each character. If more than $1$ character has an odd count, then it is not a palindrome permutation.</p> <p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string.</p> Python3JavaC++GoTypeScriptRust <pre><code>class Solution:\n    def canPermutePalindrome(self, s: str) -&gt; bool:\n        cnt = Counter(s)\n        return sum(v &amp; 1 for v in cnt.values()) &lt; 2\n</code></pre> <pre><code>class Solution {\n    public boolean canPermutePalindrome(String s) {\n        Map&lt;Character, Integer&gt; cnt = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); ++i) {\n            cnt.merge(s.charAt(i), 1, Integer::sum);\n        }\n        int sum = 0;\n        for (int v : cnt.values()) {\n            sum += v &amp; 1;\n        }\n        return sum &lt; 2;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    bool canPermutePalindrome(string s) {\n        unordered_map&lt;char, int&gt; cnt;\n        for (auto&amp; c : s) {\n            ++cnt[c];\n        }\n        int sum = 0;\n        for (auto&amp; [_, v] : cnt) {\n            sum += v &amp; 1;\n        }\n        return sum &lt; 2;\n    }\n};\n</code></pre> <pre><code>func canPermutePalindrome(s string) bool {\n    vis := map[rune]bool{}\n    cnt := 0\n    for _, c := range s {\n        if vis[c] {\n            vis[c] = false\n            cnt--\n        } else {\n            vis[c] = true\n            cnt++\n        }\n    }\n    return cnt &lt; 2\n}\n</code></pre> <pre><code>function canPermutePalindrome(s: string): boolean {\n    const set = new Set&lt;string&gt;();\n    for (const c of s) {\n        if (set.has(c)) {\n            set.delete(c);\n        } else {\n            set.add(c);\n        }\n    }\n    return set.size &lt;= 1;\n}\n</code></pre> <pre><code>use std::collections::HashSet;\n\nimpl Solution {\n    pub fn can_permute_palindrome(s: String) -&gt; bool {\n        let mut set = HashSet::new();\n        for c in s.chars() {\n            if set.contains(&amp;c) {\n                set.remove(&amp;c);\n            } else {\n                set.insert(c);\n            }\n        }\n        set.len() &lt;= 1\n    }\n}\n</code></pre>"},{"location":"lcci/1.4.html#solution-2-another-implementation-of-hash-table","title":"Solution 2: Another Implementation of Hash Table","text":"<p>We use a hash table $vis$ to store whether each character has appeared. If it has appeared, we remove the character from the hash table; otherwise, we add the character to the hash table.</p> <p>Finally, we check whether the number of characters in the hash table is less than $2$. If it is, then it is a palindrome permutation.</p> <p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string.</p> Python3JavaC++ <pre><code>class Solution:\n    def canPermutePalindrome(self, s: str) -&gt; bool:\n        vis = set()\n        for c in s:\n            if c in vis:\n                vis.remove(c)\n            else:\n                vis.add(c)\n        return len(vis) &lt; 2\n</code></pre> <pre><code>class Solution {\n    public boolean canPermutePalindrome(String s) {\n        Set&lt;Character&gt; vis = new HashSet&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); ++i) {\n            char c = s.charAt(i);\n            if (!vis.add(c)) {\n                vis.remove(c);\n            }\n        }\n        return vis.size() &lt; 2;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    bool canPermutePalindrome(string s) {\n        unordered_set&lt;char&gt; vis;\n        for (auto&amp; c : s) {\n            if (vis.count(c)) {\n                vis.erase(c);\n            } else {\n                vis.insert(c);\n            }\n        }\n        return vis.size() &lt; 2;\n    }\n};\n</code></pre>"},{"location":"lcci/1.5.html","title":"01.05. One Away","text":""},{"location":"lcci/1.5.html#description","title":"Description","text":"<p>There are three types of edits that can be performed on strings: insert a character, remove a character, or replace a character. Given two strings, write a function to check if they are one edit (or zero edits) away.</p> <p>Example\u00a01:</p> <pre>\n\nInput:\n\nfirst = \"pale\"\n\nsecond = \"ple\"\n\nOutput: True\n\n</pre> <p>Example\u00a02:</p> <pre>\n\nInput:\n\nfirst = \"pales\"\n\nsecond = \"pal\"\n\nOutput: False\n\n</pre>"},{"location":"lcci/1.5.html#solutions","title":"Solutions","text":""},{"location":"lcci/1.5.html#solution-1-case-discussion-two-pointers","title":"Solution 1: Case Discussion + Two Pointers","text":"<p>We denote the lengths of strings $first$ and $second$ as $m$ and $n$, respectively, where $m \\geq n$.</p> <p>Next, we discuss different cases:</p> <ul> <li>When $m - n &gt; 1$, $first$ and $second$ cannot be obtained through a single edit, so we return <code>false</code>.</li> <li>When $m = n$, $first$ and $second$ can only be obtained through a single edit if and only if exactly one character is different.</li> <li>When $m - n = 1$, $first$ and $second$ can only be obtained through a single edit if and only if $second$ is obtained by deleting one character from $first$. We can use two pointers to implement this.</li> </ul> <p>The time complexity is $O(n)$, where $n$ is the length of the string. The space complexity is $O(1)$.</p> Python3JavaC++GoTypeScriptRust <pre><code>class Solution:\n    def oneEditAway(self, first: str, second: str) -&gt; bool:\n        m, n = len(first), len(second)\n        if m &lt; n:\n            return self.oneEditAway(second, first)\n        if m - n &gt; 1:\n            return False\n        if m == n:\n            return sum(a != b for a, b in zip(first, second)) &lt; 2\n        i = j = cnt = 0\n        while i &lt; m:\n            if j == n or (j &lt; n and first[i] != second[j]):\n                cnt += 1\n            else:\n                j += 1\n            i += 1\n        return cnt &lt; 2\n</code></pre> <pre><code>class Solution {\n    public boolean oneEditAway(String first, String second) {\n        int m = first.length(), n = second.length();\n        if (m &lt; n) {\n            return oneEditAway(second, first);\n        }\n        if (m - n &gt; 1) {\n            return false;\n        }\n        int cnt = 0;\n        if (m == n) {\n            for (int i = 0; i &lt; n; ++i) {\n                if (first.charAt(i) != second.charAt(i)) {\n                    if (++cnt &gt; 1) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        for (int i = 0, j = 0; i &lt; m; ++i) {\n            if (j == n || (j &lt; n &amp;&amp; first.charAt(i) != second.charAt(j))) {\n                ++cnt;\n            } else {\n                ++j;\n            }\n        }\n        return cnt &lt; 2;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    bool oneEditAway(std::string first, std::string second) {\n        int m = first.length(), n = second.length();\n        if (m &lt; n) {\n            return oneEditAway(second, first);\n        }\n        if (m - n &gt; 1) {\n            return false;\n        }\n        int cnt = 0;\n        if (m == n) {\n            for (int i = 0; i &lt; n; ++i) {\n                if (first[i] != second[i]) {\n                    if (++cnt &gt; 1) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        for (int i = 0, j = 0; i &lt; m; ++i) {\n            if (j == n || (j &lt; n &amp;&amp; first[i] != second[j])) {\n                ++cnt;\n            } else {\n                ++j;\n            }\n        }\n        return cnt &lt; 2;\n    }\n};\n</code></pre> <pre><code>func oneEditAway(first string, second string) bool {\n    m, n := len(first), len(second)\n    if m &lt; n {\n        return oneEditAway(second, first)\n    }\n    if m-n &gt; 1 {\n        return false\n    }\n    cnt := 0\n    if m == n {\n        for i := 0; i &lt; n; i++ {\n            if first[i] != second[i] {\n                if cnt++; cnt &gt; 1 {\n                    return false\n                }\n            }\n        }\n        return true\n    }\n    for i, j := 0, 0; i &lt; m; i++ {\n        if j == n || (j &lt; n &amp;&amp; first[i] != second[j]) {\n            cnt++\n        } else {\n            j++\n        }\n    }\n    return cnt &lt; 2\n}\n</code></pre> <pre><code>function oneEditAway(first: string, second: string): boolean {\n    let m: number = first.length;\n    let n: number = second.length;\n    if (m &lt; n) {\n        return oneEditAway(second, first);\n    }\n    if (m - n &gt; 1) {\n        return false;\n    }\n\n    let cnt: number = 0;\n    if (m === n) {\n        for (let i: number = 0; i &lt; n; ++i) {\n            if (first[i] !== second[i]) {\n                if (++cnt &gt; 1) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    for (let i: number = 0, j: number = 0; i &lt; m; ++i) {\n        if (j === n || (j &lt; n &amp;&amp; first[i] !== second[j])) {\n            ++cnt;\n        } else {\n            ++j;\n        }\n    }\n    return cnt &lt; 2;\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn one_edit_away(first: String, second: String) -&gt; bool {\n        let (f_len, s_len) = (first.len(), second.len());\n        let (first, second) = (first.as_bytes(), second.as_bytes());\n        let (mut i, mut j) = (0, 0);\n        let mut count = 0;\n        while i &lt; f_len &amp;&amp; j &lt; s_len {\n            if first[i] != second[j] {\n                if count &gt; 0 {\n                    return false;\n                }\n\n                count += 1;\n                if i + 1 &lt; f_len &amp;&amp; first[i + 1] == second[j] {\n                    i += 1;\n                } else if j + 1 &lt; s_len &amp;&amp; first[i] == second[j + 1] {\n                    j += 1;\n                }\n            }\n            i += 1;\n            j += 1;\n        }\n        count += f_len - i + s_len - j;\n        count &lt;= 1\n    }\n}\n</code></pre>"},{"location":"lcci/1.6.html","title":"01.06. Compress String","text":""},{"location":"lcci/1.6.html#description","title":"Description","text":"<p>Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabcccccaaa would become a2blc5a3. If the \"compressed\" string would not become smaller than the original string, your method should return the original string. You can assume the string has only uppercase and lowercase letters (a - z).</p> <p>Example 1:</p> <pre>\n\nInput: \"aabcccccaaa\"\n\nOutput: \"a2b1c5a3\"\n\n</pre> <p>Example 2:</p> <pre>\n\nInput: \"abbccd\"\n\nOutput: \"abbccd\"\n\nExplanation: \n\nThe compressed string is \"a1b2c2d1\", which is longer than the original string.\n\n</pre> <p>Note:</p> <ul> <li><code>0 &lt;= S.length &lt;= 50000</code></li> </ul>"},{"location":"lcci/1.6.html#solutions","title":"Solutions","text":""},{"location":"lcci/1.6.html#solution-1-two-pointers","title":"Solution 1: Two Pointers","text":"<p>We can use two pointers to find the start and end positions of each consecutive character, calculate the length of the consecutive characters, and then append the character and length to the string $t$.</p> <p>Finally, we compare the lengths of $t$ and $S$. If the length of $t$ is less than $S$, we return $t$, otherwise we return $S$.</p> <p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string.</p> Python3Python3JavaC++GoRustJavaScript <pre><code>class Solution:\n    def compressString(self, S: str) -&gt; str:\n        t = \"\".join(a + str(len(list(b))) for a, b in groupby(S))\n        return min(S, t, key=len)\n</code></pre> <pre><code>class Solution:\n    def compressString(self, S: str) -&gt; str:\n        t = []\n        i, n = 0, len(S)\n        while i &lt; n:\n            j = i + 1\n            while j &lt; n and S[j] == S[i]:\n                j += 1\n            t.append(S[i] + str(j - i))\n            i = j\n        return min(S, \"\".join(t), key=len)\n</code></pre> <pre><code>class Solution {\n    public String compressString(String S) {\n        int n = S.length();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; n;) {\n            int j = i + 1;\n            while (j &lt; n &amp;&amp; S.charAt(j) == S.charAt(i)) {\n                ++j;\n            }\n            sb.append(S.charAt(i)).append(j - i);\n            i = j;\n        }\n        String t = sb.toString();\n        return t.length() &lt; n ? t : S;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    string compressString(string S) {\n        int n = S.size();\n        string t;\n        for (int i = 0; i &lt; n;) {\n            int j = i + 1;\n            while (j &lt; n &amp;&amp; S[j] == S[i]) {\n                ++j;\n            }\n            t += S[i];\n            t += to_string(j - i);\n            i = j;\n        }\n        return t.size() &lt; n ? t : S;\n    }\n};\n</code></pre> <pre><code>func compressString(S string) string {\n    n := len(S)\n    sb := strings.Builder{}\n    for i := 0; i &lt; n; {\n        j := i + 1\n        for j &lt; n &amp;&amp; S[j] == S[i] {\n            j++\n        }\n        sb.WriteByte(S[i])\n        sb.WriteString(strconv.Itoa(j - i))\n        i = j\n    }\n    if t := sb.String(); len(t) &lt; n {\n        return t\n    }\n    return S\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn compress_string(s: String) -&gt; String {\n        let mut cs: Vec&lt;char&gt; = s.chars().collect();\n        let mut t = Vec::new();\n        let mut i = 0;\n        let n = s.len();\n        while i &lt; n {\n            let mut j = i + 1;\n            while j &lt; n &amp;&amp; cs[j] == cs[i] {\n                j += 1;\n            }\n            t.push(cs[i]);\n            t.extend((j - i).to_string().chars());\n            i = j;\n        }\n\n        let t = t.into_iter().collect::&lt;String&gt;();\n        if s.len() &lt;= t.len() {\n            s\n        } else {\n            t\n        }\n    }\n}\n</code></pre> <pre><code>/**\n * @param {string} S\n * @return {string}\n */\nvar compressString = function (S) {\n    const n = S.length;\n    const t = [];\n    for (let i = 0; i &lt; n; ) {\n        let j = i + 1;\n        while (j &lt; n &amp;&amp; S.charAt(j) === S.charAt(i)) {\n            ++j;\n        }\n        t.push(S.charAt(i), j - i);\n        i = j;\n    }\n    return t.length &lt; n ? t.join('') : S;\n};\n</code></pre>"},{"location":"lcci/1.7.html","title":"01.07. Rotate Matrix","text":""},{"location":"lcci/1.7.html#description","title":"Description","text":"<p>Given an image represented by an N x N matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees. Can you do this in place?</p> <p> </p> <p>Example 1:</p> <pre>\n\nGiven matrix =\n\n[\n\n  [1,2,3],\n\n  [4,5,6],\n\n  [7,8,9]\n\n],\n\n\n\nRotate the matrix in place. It becomes:\n\n[\n\n  [7,4,1],\n\n  [8,5,2],\n\n  [9,6,3]\n\n]\n\n</pre> <p>Example 2:</p> <pre>\n\nGiven matrix =\n\n[\n\n  [ 5, 1, 9,11],\n\n  [ 2, 4, 8,10],\n\n  [13, 3, 6, 7],\n\n  [15,14,12,16]\n\n],\n\n\n\nRotate the matrix in place. It becomes:\n\n[\n\n  [15,13, 2, 5],\n\n  [14, 3, 4, 1],\n\n  [12, 6, 8, 9],\n\n  [16, 7,10,11]\n\n]\n\n</pre>"},{"location":"lcci/1.7.html#solutions","title":"Solutions","text":""},{"location":"lcci/1.7.html#solution-1-in-place-rotation","title":"Solution 1: In-place Rotation","text":"<p>According to the problem requirements, we actually need to rotate $matrix[i][j]$ to $matrix[j][n - i - 1]$.</p> <p>We can first flip the matrix upside down, that is, swap $matrix[i][j]$ and $matrix[n - i - 1][j]$, and then flip the matrix along the main diagonal, that is, swap $matrix[i][j]$ and $matrix[j][i]$. This way, we can rotate $matrix[i][j]$ to $matrix[j][n - i - 1]$.</p> <p>The time complexity is $O(n^2)$, where $n$ is the side length of the matrix. The space complexity is $O(1)$.</p> Python3JavaC++GoTypeScriptRustJavaScriptC# <pre><code>class Solution:\n    def rotate(self, matrix: List[List[int]]) -&gt; None:\n        n = len(matrix)\n        for i in range(n &gt;&gt; 1):\n            for j in range(n):\n                matrix[i][j], matrix[n - i - 1][j] = matrix[n - i - 1][j], matrix[i][j]\n        for i in range(n):\n            for j in range(i):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n</code></pre> <pre><code>class Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for (int i = 0; i &lt; n &gt;&gt; 1; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                int t = matrix[i][j];\n                matrix[i][j] = matrix[n - i - 1][j];\n                matrix[n - i - 1][j] = t;\n            }\n        }\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; i; ++j) {\n                int t = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = t;\n            }\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int n = matrix.size();\n        for (int i = 0; i &lt; n &gt;&gt; 1; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                swap(matrix[i][j], matrix[n - i - 1][j]);\n            }\n        }\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; i; ++j) {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n    }\n};\n</code></pre> <pre><code>func rotate(matrix [][]int) {\n    n := len(matrix)\n    for i := 0; i &lt; n&gt;&gt;1; i++ {\n        for j := 0; j &lt; n; j++ {\n            matrix[i][j], matrix[n-i-1][j] = matrix[n-i-1][j], matrix[i][j]\n        }\n    }\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; i; j++ {\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        }\n    }\n}\n</code></pre> <pre><code>/**\n Do not return anything, modify matrix in-place instead.\n */\nfunction rotate(matrix: number[][]): void {\n    matrix.reverse();\n    for (let i = 0; i &lt; matrix.length; ++i) {\n        for (let j = 0; j &lt; i; ++j) {\n            const t = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = t;\n        }\n    }\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn rotate(matrix: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {\n        let n = matrix.len();\n        for i in 0..n / 2 {\n            for j in 0..n {\n                let t = matrix[i][j];\n                matrix[i][j] = matrix[n - i - 1][j];\n                matrix[n - i - 1][j] = t;\n            }\n        }\n        for i in 0..n {\n            for j in 0..i {\n                let t = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = t;\n            }\n        }\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar rotate = function (matrix) {\n    matrix.reverse();\n    for (let i = 0; i &lt; matrix.length; ++i) {\n        for (let j = 0; j &lt; i; ++j) {\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n        }\n    }\n};\n</code></pre> <pre><code>public class Solution {\n    public void Rotate(int[][] matrix) {\n        int n = matrix.Length;\n        for (int i = 0; i &lt; n &gt;&gt; 1; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                int t = matrix[i][j];\n                matrix[i][j] = matrix[n - i - 1][j];\n                matrix[n - i - 1][j] = t;\n            }\n        }\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; i; ++j) {\n                int t = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = t;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"lcci/1.8.html","title":"01.08. Zero Matrix","text":""},{"location":"lcci/1.8.html#description","title":"Description","text":"<p>Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0.</p> <p> </p> <p>Example 1: </p> <pre>\n\nInput: \n\n[\n\n  [1,1,1],\n\n  [1,0,1],\n\n  [1,1,1]\n\n]\n\nOutput: \n\n[\n\n  [1,0,1],\n\n  [0,0,0],\n\n  [1,0,1]\n\n]\n\n</pre> <p>Example 2: </p> <pre>\n\nInput: \n\n[\n\n  [0,1,2,0],\n\n  [3,4,5,2],\n\n  [1,3,1,5]\n\n]\n\nOutput: \n\n[\n\n  [0,0,0,0],\n\n  [0,4,5,0],\n\n  [0,3,1,0]\n\n]\n\n</pre>"},{"location":"lcci/1.8.html#solutions","title":"Solutions","text":""},{"location":"lcci/1.8.html#solution-1-array-marking","title":"Solution 1: Array Marking","text":"<p>We use arrays <code>rows</code> and <code>cols</code> to mark the rows and columns to be zeroed.</p> <p>Then we traverse the matrix again, zeroing the elements corresponding to the rows and columns marked in <code>rows</code> and <code>cols</code>.</p> <p>The time complexity is $O(m \\times n)$, and the space complexity is $O(m + n)$. Here, $m$ and $n$ are the number of rows and columns of the matrix, respectively.</p> Python3JavaC++GoTypeScriptRustJavaScriptC <pre><code>class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -&gt; None:\n        m, n = len(matrix), len(matrix[0])\n        rows = [0] * m\n        cols = [0] * n\n        for i, row in enumerate(matrix):\n            for j, v in enumerate(row):\n                if v == 0:\n                    rows[i] = cols[j] = 1\n        for i in range(m):\n            for j in range(n):\n                if rows[i] or cols[j]:\n                    matrix[i][j] = 0\n</code></pre> <pre><code>class Solution {\n    public void setZeroes(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        boolean[] rows = new boolean[m];\n        boolean[] cols = new boolean[n];\n        for (int i = 0; i &lt; m; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                if (matrix[i][j] == 0) {\n                    rows[i] = true;\n                    cols[j] = true;\n                }\n            }\n        }\n        for (int i = 0; i &lt; m; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                if (rows[i] || cols[j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector&lt;bool&gt; rows(m);\n        vector&lt;bool&gt; cols(n);\n        for (int i = 0; i &lt; m; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                if (!matrix[i][j]) {\n                    rows[i] = 1;\n                    cols[j] = 1;\n                }\n            }\n        }\n        for (int i = 0; i &lt; m; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                if (rows[i] || cols[j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n};\n</code></pre> <pre><code>func setZeroes(matrix [][]int) {\n    m, n := len(matrix), len(matrix[0])\n    rows := make([]bool, m)\n    cols := make([]bool, n)\n    for i, row := range matrix {\n        for j, v := range row {\n            if v == 0 {\n                rows[i] = true\n                cols[j] = true\n            }\n        }\n    }\n    for i := 0; i &lt; m; i++ {\n        for j := 0; j &lt; n; j++ {\n            if rows[i] || cols[j] {\n                matrix[i][j] = 0\n            }\n        }\n    }\n}\n</code></pre> <pre><code>/**\n Do not return anything, modify matrix in-place instead.\n */\nfunction setZeroes(matrix: number[][]): void {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const rows = new Array(m).fill(false);\n    const cols = new Array(n).fill(false);\n    for (let i = 0; i &lt; m; i++) {\n        for (let j = 0; j &lt; n; j++) {\n            if (matrix[i][j] === 0) {\n                rows[i] = true;\n                cols[j] = true;\n            }\n        }\n    }\n    for (let i = 0; i &lt; m; i++) {\n        for (let j = 0; j &lt; n; j++) {\n            if (rows[i] || cols[j]) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn set_zeroes(matrix: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {\n        let m = matrix.len();\n        let n = matrix[0].len();\n        let mut rows = vec![false; m];\n        let mut cols = vec![false; n];\n        for i in 0..m {\n            for j in 0..n {\n                if matrix[i][j] == 0 {\n                    rows[i] = true;\n                    cols[j] = true;\n                }\n            }\n        }\n        for i in 0..m {\n            for j in 0..n {\n                if rows[i] || cols[j] {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar setZeroes = function (matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const rows = new Array(m).fill(false);\n    const cols = new Array(n).fill(false);\n    for (let i = 0; i &lt; m; ++i) {\n        for (let j = 0; j &lt; n; ++j) {\n            if (matrix[i][j] == 0) {\n                rows[i] = true;\n                cols[j] = true;\n            }\n        }\n    }\n    for (let i = 0; i &lt; m; ++i) {\n        for (let j = 0; j &lt; n; ++j) {\n            if (rows[i] || cols[j]) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n};\n</code></pre> <pre><code>void setZeroes(int** matrix, int matrixSize, int* matrixColSize) {\n    int m = matrixSize;\n    int n = matrixColSize[0];\n    int* rows = (int*) malloc(sizeof(int) * m);\n    int* cols = (int*) malloc(sizeof(int) * n);\n    memset(rows, 0, sizeof(int) * m);\n    memset(cols, 0, sizeof(int) * n);\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; ++j) {\n            if (matrix[i][j] == 0) {\n                rows[i] = 1;\n                cols[j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; ++j) {\n            if (rows[i] || cols[j]) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n    free(rows);\n    free(cols);\n}\n</code></pre>"},{"location":"lcci/1.8.html#solution-2-in-place-marking","title":"Solution 2: In-place Marking","text":"<p>In Solution 1, we used additional arrays to mark the rows and columns to be zeroed. In fact, we can directly use the first row and first column of the matrix for marking, without needing to allocate additional array space.</p> <p>Since the first row and first column are used for marking, their values may change due to the marking. Therefore, we need additional variables $i0$ and $j0$ to mark whether the first row and first column need to be zeroed.</p> <p>The time complexity is $O(m \\times n)$, where $m$ and $n$ are the number of rows and columns of the matrix, respectively. The space complexity is $O(1)$.</p> Python3JavaC++GoTypeScriptRustJavaScriptC <pre><code>class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -&gt; None:\n        m, n = len(matrix), len(matrix[0])\n        i0 = any(v == 0 for v in matrix[0])\n        j0 = any(matrix[i][0] == 0 for i in range(m))\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = matrix[0][j] = 0\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        if i0:\n            for j in range(n):\n                matrix[0][j] = 0\n        if j0:\n            for i in range(m):\n                matrix[i][0] = 0\n</code></pre> <pre><code>class Solution {\n    public void setZeroes(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        boolean i0 = false, j0 = false;\n        for (int j = 0; j &lt; n; ++j) {\n            if (matrix[0][j] == 0) {\n                i0 = true;\n                break;\n            }\n        }\n        for (int i = 0; i &lt; m; ++i) {\n            if (matrix[i][0] == 0) {\n                j0 = true;\n                break;\n            }\n        }\n        for (int i = 1; i &lt; m; ++i) {\n            for (int j = 1; j &lt; n; ++j) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1; i &lt; m; ++i) {\n            for (int j = 1; j &lt; n; ++j) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        if (i0) {\n            for (int j = 0; j &lt; n; ++j) {\n                matrix[0][j] = 0;\n            }\n        }\n        if (j0) {\n            for (int i = 0; i &lt; m; ++i) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        bool i0 = false, j0 = false;\n        for (int j = 0; j &lt; n; ++j) {\n            if (matrix[0][j] == 0) {\n                i0 = true;\n                break;\n            }\n        }\n        for (int i = 0; i &lt; m; ++i) {\n            if (matrix[i][0] == 0) {\n                j0 = true;\n                break;\n            }\n        }\n        for (int i = 1; i &lt; m; ++i) {\n            for (int j = 1; j &lt; n; ++j) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1; i &lt; m; ++i) {\n            for (int j = 1; j &lt; n; ++j) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        if (i0) {\n            for (int j = 0; j &lt; n; ++j) {\n                matrix[0][j] = 0;\n            }\n        }\n        if (j0) {\n            for (int i = 0; i &lt; m; ++i) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n};\n</code></pre> <pre><code>func setZeroes(matrix [][]int) {\n    m, n := len(matrix), len(matrix[0])\n    i0, j0 := false, false\n    for j := 0; j &lt; n; j++ {\n        if matrix[0][j] == 0 {\n            i0 = true\n            break\n        }\n    }\n    for i := 0; i &lt; m; i++ {\n        if matrix[i][0] == 0 {\n            j0 = true\n            break\n        }\n    }\n    for i := 1; i &lt; m; i++ {\n        for j := 1; j &lt; n; j++ {\n            if matrix[i][j] == 0 {\n                matrix[i][0], matrix[0][j] = 0, 0\n            }\n        }\n    }\n    for i := 1; i &lt; m; i++ {\n        for j := 1; j &lt; n; j++ {\n            if matrix[i][0] == 0 || matrix[0][j] == 0 {\n                matrix[i][j] = 0\n            }\n        }\n    }\n    if i0 {\n        for j := 0; j &lt; n; j++ {\n            matrix[0][j] = 0\n        }\n    }\n    if j0 {\n        for i := 0; i &lt; m; i++ {\n            matrix[i][0] = 0\n        }\n    }\n}\n</code></pre> <pre><code>/**\n Do not return anything, modify matrix in-place instead.\n */\nfunction setZeroes(matrix: number[][]): void {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    let l0 = false;\n    let r0 = false;\n    for (let i = 0; i &lt; m; i++) {\n        if (matrix[i][0] === 0) {\n            l0 = true;\n            break;\n        }\n    }\n    for (let j = 0; j &lt; n; j++) {\n        if (matrix[0][j] === 0) {\n            r0 = true;\n            break;\n        }\n    }\n    for (let i = 0; i &lt; m; i++) {\n        for (let j = 0; j &lt; n; j++) {\n            if (matrix[i][j] === 0) {\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n    for (let i = 1; i &lt; m; i++) {\n        for (let j = 1; j &lt; n; j++) {\n            if (matrix[i][0] === 0 || matrix[0][j] === 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n    if (l0) {\n        for (let i = 0; i &lt; m; i++) {\n            matrix[i][0] = 0;\n        }\n    }\n    if (r0) {\n        for (let j = 0; j &lt; n; j++) {\n            matrix[0][j] = 0;\n        }\n    }\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn set_zeroes(matrix: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {\n        let m = matrix.len();\n        let n = matrix[0].len();\n        let l0 = {\n            let mut res = false;\n            for j in 0..n {\n                if matrix[0][j] == 0 {\n                    res = true;\n                    break;\n                }\n            }\n            res\n        };\n        let r0 = {\n            let mut res = false;\n            for i in 0..m {\n                if matrix[i][0] == 0 {\n                    res = true;\n                    break;\n                }\n            }\n            res\n        };\n        for i in 0..m {\n            for j in 0..n {\n                if matrix[i][j] == 0 {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for i in 1..m {\n            for j in 1..n {\n                if matrix[i][0] == 0 || matrix[0][j] == 0 {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        if l0 {\n            for j in 0..n {\n                matrix[0][j] = 0;\n            }\n        }\n        if r0 {\n            for i in 0..m {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar setZeroes = function (matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    let i0 = matrix[0].some(v =&gt; v == 0);\n    let j0 = false;\n    for (let i = 0; i &lt; m; ++i) {\n        if (matrix[i][0] == 0) {\n            j0 = true;\n            break;\n        }\n    }\n    for (let i = 1; i &lt; m; ++i) {\n        for (let j = 1; j &lt; n; ++j) {\n            if (matrix[i][j] == 0) {\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n    for (let i = 1; i &lt; m; ++i) {\n        for (let j = 1; j &lt; n; ++j) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n    if (i0) {\n        for (let j = 0; j &lt; n; ++j) {\n            matrix[0][j] = 0;\n        }\n    }\n    if (j0) {\n        for (let i = 0; i &lt; m; ++i) {\n            matrix[i][0] = 0;\n        }\n    }\n};\n</code></pre> <pre><code>void setZeroes(int** matrix, int matrixSize, int* matrixColSize) {\n    int m = matrixSize;\n    int n = matrixColSize[0];\n    int l0 = 0;\n    int r0 = 0;\n    for (int i = 0; i &lt; m; i++) {\n        if (matrix[i][0] == 0) {\n            l0 = 1;\n            break;\n        }\n    }\n    for (int j = 0; j &lt; n; j++) {\n        if (matrix[0][j] == 0) {\n            r0 = 1;\n            break;\n        }\n    }\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (matrix[i][j] == 0) {\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n    if (l0) {\n        for (int i = 0; i &lt; m; i++) {\n            matrix[i][0] = 0;\n        }\n    }\n    if (r0) {\n        for (int j = 0; j &lt; n; j++) {\n            matrix[0][j] = 0;\n        }\n    }\n}\n</code></pre>"},{"location":"lcci/1.9.html","title":"01.09. String Rotation","text":""},{"location":"lcci/1.9.html#description","title":"Description","text":"<p>Given two strings, <code>s1</code>\u00a0and <code>s2</code>, write code to check if <code>s2</code> is a rotation of <code>s1</code> (e.g.,\"waterbottle\" is a rotation of\"erbottlewat\").\u00a0Can you use\u00a0only one call to the method that\u00a0checks if one word is a substring of another?</p> <p>Example 1:</p> <pre>\n\nInput: s1 = \"waterbottle\", s2 = \"erbottlewat\"\n\nOutput: True\n\n</pre> <p>Example 2:</p> <pre>\n\nInput: s1 = \"aa\", \"aba\"\n\nOutput: False\n\n</pre> <p> </p> <p>Note:</p> <ol> <li><code>0 &lt;= s1.length, s1.length &lt;=\u00a0100000</code></li> </ol>"},{"location":"lcci/1.9.html#solutions","title":"Solutions","text":""},{"location":"lcci/1.9.html#solution-1-string-matching","title":"Solution 1: String Matching","text":"<p>First, if the lengths of strings $s1$ and $s2$ are not equal, they are definitely not rotation strings of each other.</p> <p>Second, if the lengths of strings $s1$ and $s2$ are equal, then by concatenating two $s1$ together, the resulting string $s1 + s1$ will definitely include all rotation cases of $s1$. At this point, we just need to check whether $s2$ is a substring of $s1 + s1$.</p> <pre><code># True\ns1 = \"aba\"\ns2 = \"baa\"\ns1 + s1 = \"abaaba\"\n            ^^^\n\n# False\ns1 = \"aba\"\ns2 = \"bab\"\ns1 + s1 = \"abaaba\"\n</code></pre> <p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of string $s1$.</p> Python3JavaC++GoTypeScriptRust <pre><code>class Solution:\n    def isFlipedString(self, s1: str, s2: str) -&gt; bool:\n        return len(s1) == len(s2) and s2 in s1 * 2\n</code></pre> <pre><code>class Solution {\n    public boolean isFlipedString(String s1, String s2) {\n        return s1.length() == s2.length() &amp;&amp; (s1 + s1).contains(s2);\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    bool isFlipedString(string s1, string s2) {\n        return s1.size() == s2.size() &amp;&amp; (s1 + s1).find(s2) != string::npos;\n    }\n};\n</code></pre> <pre><code>func isFlipedString(s1 string, s2 string) bool {\n    return len(s1) == len(s2) &amp;&amp; strings.Contains(s1+s1, s2)\n}\n</code></pre> <pre><code>function isFlipedString(s1: string, s2: string): boolean {\n    return s1.length === s2.length &amp;&amp; (s2 + s2).indexOf(s1) !== -1;\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn is_fliped_string(s1: String, s2: String) -&gt; bool {\n        s1.len() == s2.len() &amp;&amp; (s2.clone() + &amp;s2).contains(&amp;s1)\n    }\n}\n</code></pre>"},{"location":"lcci/10.1.html","title":"10.01. Sorted Merge","text":""},{"location":"lcci/10.1.html#description","title":"Description","text":"<p>You are given two sorted arrays, A and B, where A has a large enough buffer at the end to hold B. Write a method to merge B into A in sorted order.</p> <p>Initially the number of elements in A and B are\u00a0m\u00a0and\u00a0n respectively.</p> <p>Example:</p> <pre>\n\nInput:\n\nA = [1,2,3,0,0,0], m = 3\n\nB = [2,5,6],       n = 3\n\n\n\nOutput:\u00a0[1,2,2,3,5,6]</pre>"},{"location":"lcci/10.1.html#solutions","title":"Solutions","text":""},{"location":"lcci/10.1.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRustJavaScript <pre><code>class Solution:\n    def merge(self, A: List[int], m: int, B: List[int], n: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify A in-place instead.\n        \"\"\"\n        i, j = m - 1, n - 1\n        for k in range(len(A) - 1, -1, -1):\n            if j &lt; 0 or (i &gt;= 0 and A[i] &gt;= B[j]):\n                A[k] = A[i]\n                i -= 1\n            else:\n                A[k] = B[j]\n                j -= 1\n</code></pre> <pre><code>class Solution {\n    public void merge(int[] A, int m, int[] B, int n) {\n        int i = m - 1, j = n - 1;\n        for (int k = A.length - 1; k &gt;= 0; --k) {\n            if (j &lt; 0 || (i &gt;= 0 &amp;&amp; A[i] &gt;= B[j])) {\n                A[k] = A[i--];\n            } else {\n                A[k] = B[j--];\n            }\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    void merge(vector&lt;int&gt;&amp; A, int m, vector&lt;int&gt;&amp; B, int n) {\n        int i = m - 1, j = n - 1;\n        for (int k = A.size() - 1; k &gt;= 0; --k) {\n            if (j &lt; 0 || (i &gt;= 0 &amp;&amp; A[i] &gt;= B[j]))\n                A[k] = A[i--];\n            else\n                A[k] = B[j--];\n        }\n    }\n};\n</code></pre> <pre><code>func merge(A []int, m int, B []int, n int) {\n    i, j := m-1, n-1\n    for k := len(A) - 1; k &gt;= 0; k-- {\n        if j &lt; 0 || (i &gt;= 0 &amp;&amp; A[i] &gt;= B[j]) {\n            A[k] = A[i]\n            i--\n        } else {\n            A[k] = B[j]\n            j--\n        }\n    }\n}\n</code></pre> <pre><code>/**\n Do not return anything, modify A in-place instead.\n */\nfunction merge(A: number[], m: number, B: number[], n: number): void {\n    for (let i = n + m - 1; i &gt;= 0; i--) {\n        const x = A[m - 1] ?? -Infinity;\n        const y = B[n - 1] ?? -Infinity;\n        if (x &gt; y) {\n            A[i] = x;\n            m--;\n        } else {\n            A[i] = y;\n            n--;\n        }\n    }\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn merge(a: &amp;mut Vec&lt;i32&gt;, m: i32, b: &amp;mut Vec&lt;i32&gt;, n: i32) {\n        let mut m = m as usize;\n        let mut n = n as usize;\n        for i in (0..n + m).rev() {\n            let x = if m != 0 { a[m - 1] } else { i32::MIN };\n            let y = if n != 0 { b[n - 1] } else { i32::MIN };\n            if x &gt; y {\n                a[i] = x;\n                m -= 1;\n            } else {\n                a[i] = y;\n                n -= 1;\n            }\n        }\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number[]} A\n * @param {number} m\n * @param {number[]} B\n * @param {number} n\n * @return {void} Do not return anything, modify A in-place instead.\n */\nvar merge = function (A, m, B, n) {\n    let i = m - 1,\n        j = n - 1;\n    for (let k = A.length - 1; k &gt;= 0; k--) {\n        if (k == i) return;\n        if (i &lt; 0 || A[i] &lt;= B[j]) {\n            A[k] = B[j];\n            j--;\n        } else {\n            A[k] = A[i];\n            i--;\n        }\n    }\n};\n</code></pre>"},{"location":"lcci/10.10.html","title":"10.10. Rank from Stream","text":""},{"location":"lcci/10.10.html#description","title":"Description","text":"<p>Imagine you are reading in a stream of integers. Periodically, you wish to be able to look up the rank of a number <code>x</code> (the number of values less than or equal to <code>x</code>). lmplement the data structures and algorithms to support these operations. That is, implement the method <code>track (int x)</code>, which is called when each number is generated, and the method <code>getRankOfNumber(int x)</code>, which returns the number of values less than or equal to <code>x</code>.</p> <p>Note:\u00a0This problem is slightly different from the original one in the book.</p> <p>Example:</p> <pre>\n\nInput:\n\n[\"StreamRank\", \"getRankOfNumber\", \"track\", \"getRankOfNumber\"]\n\n[[], [1], [0], [0]]\n\nOutput:\n\n[null,0,null,1]\n\n</pre> <p>Note: </p> <ul> <li><code>x &lt;= 50000</code></li> <li>The number of calls of both\u00a0<code>track</code>\u00a0and\u00a0<code>getRankOfNumber</code>\u00a0methods are less than or equal to 2000.</li> </ul>"},{"location":"lcci/10.10.html#solutions","title":"Solutions","text":""},{"location":"lcci/10.10.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    @staticmethod\n    def lowbit(x):\n        return x &amp; -x\n\n    def update(self, x, delta):\n        while x &lt;= self.n:\n            self.c[x] += delta\n            x += BinaryIndexedTree.lowbit(x)\n\n    def query(self, x):\n        s = 0\n        while x &gt; 0:\n            s += self.c[x]\n            x -= BinaryIndexedTree.lowbit(x)\n        return s\n\n\nclass StreamRank:\n    def __init__(self):\n        self.tree = BinaryIndexedTree(50010)\n\n    def track(self, x: int) -&gt; None:\n        self.tree.update(x + 1, 1)\n\n    def getRankOfNumber(self, x: int) -&gt; int:\n        return self.tree.query(x + 1)\n\n\n# Your StreamRank object will be instantiated and called as such:\n# obj = StreamRank()\n# obj.track(x)\n# param_2 = obj.getRankOfNumber(x)\n</code></pre> <pre><code>class BinaryIndexedTree {\n    private int n;\n    private int[] c;\n\n    public BinaryIndexedTree(int n) {\n        this.n = n;\n        c = new int[n + 1];\n    }\n\n    public static int lowbit(int x) {\n        return x &amp; -x;\n    }\n\n    public void update(int x, int delta) {\n        while (x &lt;= n) {\n            c[x] += delta;\n            x += lowbit(x);\n        }\n    }\n\n    public int query(int x) {\n        int s = 0;\n        while (x &gt; 0) {\n            s += c[x];\n            x -= lowbit(x);\n        }\n        return s;\n    }\n}\n\nclass StreamRank {\n    private BinaryIndexedTree tree;\n\n    public StreamRank() {\n        tree = new BinaryIndexedTree(50010);\n    }\n\n    public void track(int x) {\n        tree.update(x + 1, 1);\n    }\n\n    public int getRankOfNumber(int x) {\n        return tree.query(x + 1);\n    }\n}\n\n/**\n * Your StreamRank object will be instantiated and called as such:\n * StreamRank obj = new StreamRank();\n * obj.track(x);\n * int param_2 = obj.getRankOfNumber(x);\n */\n</code></pre> <pre><code>class BinaryIndexedTree {\npublic:\n    int n;\n    vector&lt;int&gt; c;\n\n    BinaryIndexedTree(int _n)\n        : n(_n)\n        , c(_n + 1) {}\n\n    void update(int x, int delta) {\n        while (x &lt;= n) {\n            c[x] += delta;\n            x += lowbit(x);\n        }\n    }\n\n    int query(int x) {\n        int s = 0;\n        while (x &gt; 0) {\n            s += c[x];\n            x -= lowbit(x);\n        }\n        return s;\n    }\n\n    int lowbit(int x) {\n        return x &amp; -x;\n    }\n};\n\nclass StreamRank {\npublic:\n    BinaryIndexedTree* tree;\n\n    StreamRank() {\n        tree = new BinaryIndexedTree(50010);\n    }\n\n    void track(int x) {\n        tree-&gt;update(x + 1, 1);\n    }\n\n    int getRankOfNumber(int x) {\n        return tree-&gt;query(x + 1);\n    }\n};\n\n/**\n * Your StreamRank object will be instantiated and called as such:\n * StreamRank* obj = new StreamRank();\n * obj-&gt;track(x);\n * int param_2 = obj-&gt;getRankOfNumber(x);\n */\n</code></pre> <pre><code>type BinaryIndexedTree struct {\n    n int\n    c []int\n}\n\nfunc newBinaryIndexedTree(n int) *BinaryIndexedTree {\n    c := make([]int, n+1)\n    return &amp;BinaryIndexedTree{n, c}\n}\n\nfunc (this *BinaryIndexedTree) lowbit(x int) int {\n    return x &amp; -x\n}\n\nfunc (this *BinaryIndexedTree) update(x, delta int) {\n    for x &lt;= this.n {\n        this.c[x] += delta\n        x += this.lowbit(x)\n    }\n}\n\nfunc (this *BinaryIndexedTree) query(x int) int {\n    s := 0\n    for x &gt; 0 {\n        s += this.c[x]\n        x -= this.lowbit(x)\n    }\n    return s\n}\n\ntype StreamRank struct {\n    tree *BinaryIndexedTree\n}\n\nfunc Constructor() StreamRank {\n    tree := newBinaryIndexedTree(50010)\n    return StreamRank{tree}\n}\n\nfunc (this *StreamRank) Track(x int) {\n    this.tree.update(x+1, 1)\n}\n\nfunc (this *StreamRank) GetRankOfNumber(x int) int {\n    return this.tree.query(x + 1)\n}\n\n/**\n * Your StreamRank object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Track(x);\n * param_2 := obj.GetRankOfNumber(x);\n */\n</code></pre>"},{"location":"lcci/10.11.html","title":"10.11. Peaks and Valleys","text":""},{"location":"lcci/10.11.html#description","title":"Description","text":"<p>In an array of integers, a \"peak\" is an element which is greater than or equal to the adjacent integers and a \"valley\" is an element which is less than or equal to the adjacent inte\u00adgers. For example, in the array {5, 8, 6, 2, 3, 4, 6}, {8, 6} are peaks and {5, 2} are valleys. Given an array of integers, sort the array into an alternating sequence of peaks and valleys.</p> <p>Example:</p> <pre>\n\nInput: [5, 3, 1, 2, 3]\n\nOutput:\u00a0[5, 1, 3, 2, 3]\n\n</pre> <p>Note: </p> <ul> <li><code>nums.length &lt;= 10000</code></li> </ul>"},{"location":"lcci/10.11.html#solutions","title":"Solutions","text":""},{"location":"lcci/10.11.html#solution-1-sorting","title":"Solution 1: Sorting","text":"<p>We first sort the array, and then traverse the array and swap the elements at even indices with their next element.</p> <p>The time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the length of the array.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def wiggleSort(self, nums: List[int]) -&gt; None:\n        nums.sort()\n        for i in range(0, len(nums), 2):\n            nums[i : i + 2] = nums[i : i + 2][::-1]\n</code></pre> <pre><code>class Solution {\n    public void wiggleSort(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        for (int i = 0; i &lt; n - 1; i += 2) {\n            int t = nums[i];\n            nums[i] = nums[i + 1];\n            nums[i + 1] = t;\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    void wiggleSort(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        for (int i = 0; i &lt; n - 1; i += 2) {\n            swap(nums[i], nums[i + 1]);\n        }\n    }\n};\n</code></pre> <pre><code>func wiggleSort(nums []int) {\n    sort.Ints(nums)\n    for i := 0; i &lt; len(nums)-1; i += 2 {\n        nums[i], nums[i+1] = nums[i+1], nums[i]\n    }\n}\n</code></pre> <pre><code>/**\n Do not return anything, modify nums in-place instead.\n */\nfunction wiggleSort(nums: number[]): void {\n    nums.sort((a, b) =&gt; a - b);\n    const n = nums.length;\n    for (let i = 0; i &lt; n - 1; i += 2) {\n        [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    }\n}\n</code></pre>"},{"location":"lcci/10.2.html","title":"10.02. Group Anagrams","text":""},{"location":"lcci/10.2.html#description","title":"Description","text":"<p>Write a method to sort an array of strings so that all the anagrams are in the same group.</p> <p>Note:\u00a0This problem is slightly different from the original one the book.</p> <p>Example:</p> <pre>\n\nInput: <code>[\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]</code>,\n\nOutput:\n\n[\n\n  [\"ate\",\"eat\",\"tea\"],\n\n  [\"nat\",\"tan\"],\n\n  [\"bat\"]\n\n]</pre> <p>Notes: </p> <ul> <li>All inputs will be in lowercase.</li> <li>The order of your output does not\u00a0matter.</li> </ul>"},{"location":"lcci/10.2.html#solutions","title":"Solutions","text":""},{"location":"lcci/10.2.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRust <pre><code>class Solution:\n    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:\n        chars = defaultdict(list)\n        for s in strs:\n            k = ''.join(sorted(list(s)))\n            chars[k].append(s)\n        return list(chars.values())\n</code></pre> <pre><code>class Solution {\n    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {\n        Map&lt;String, List&lt;String&gt;&gt; chars = new HashMap&lt;&gt;();\n        for (String s : strs) {\n            char[] t = s.toCharArray();\n            Arrays.sort(t);\n            String k = new String(t);\n            chars.computeIfAbsent(k, key -&gt; new ArrayList&lt;&gt;()).add(s);\n        }\n        return new ArrayList&lt;&gt;(chars.values());\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; chars;\n        for (auto s : strs) {\n            string k = s;\n            sort(k.begin(), k.end());\n            chars[k].emplace_back(s);\n        }\n        vector&lt;vector&lt;string&gt;&gt; res;\n        for (auto it = chars.begin(); it != chars.end(); ++it) {\n            res.emplace_back(it-&gt;second);\n        }\n        return res;\n    }\n};\n</code></pre> <pre><code>func groupAnagrams(strs []string) [][]string {\n    chars := map[string][]string{}\n    for _, s := range strs {\n        key := []byte(s)\n        sort.Slice(key, func(i, j int) bool {\n            return key[i] &lt; key[j]\n        })\n        chars[string(key)] = append(chars[string(key)], s)\n    }\n    var res [][]string\n    for _, v := range chars {\n        res = append(res, v)\n    }\n    return res\n}\n</code></pre> <pre><code>function groupAnagrams(strs: string[]): string[][] {\n    const map = new Map&lt;string, string[]&gt;();\n    for (const s of strs) {\n        const k = s.split('').sort().join();\n        map.set(k, (map.get(k) || []).concat([s]));\n    }\n    return [...map.values()];\n}\n</code></pre> <pre><code>use std::collections::HashMap;\n\nimpl Solution {\n    pub fn group_anagrams(strs: Vec&lt;String&gt;) -&gt; Vec&lt;Vec&lt;String&gt;&gt; {\n        let mut map = HashMap::new();\n        for s in strs {\n            let key = {\n                let mut cs = s.chars().collect::&lt;Vec&lt;char&gt;&gt;();\n                cs.sort();\n                cs.iter().collect::&lt;String&gt;()\n            };\n            map.entry(key)\n                .or_insert(vec![])\n                .push(s);\n        }\n        map.into_values().collect()\n    }\n}\n</code></pre>"},{"location":"lcci/10.3.html","title":"10.03. Search Rotate Array","text":""},{"location":"lcci/10.3.html#description","title":"Description","text":"<p>Given a sorted array of n integers that has been rotated an unknown number of times, write code to find an element in the array. You may assume that the array was originally sorted in increasing order. If there are more than one target elements in the array, return the smallest index.</p> <p>Example1:</p> <pre>\n\n Input: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5\n\n Output: 8 (the index of 5 in the array)\n\n</pre> <p>Example2:</p> <pre>\n\n Input: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11\n\n Output: -1 (not found)\n\n</pre> <p>Note:</p> <ol> <li><code>1 &lt;= arr.length &lt;= 1000000</code></li> </ol>"},{"location":"lcci/10.3.html#solutions","title":"Solutions","text":""},{"location":"lcci/10.3.html#solution-1-binary-search","title":"Solution 1: Binary Search","text":"<p>We define the left boundary of the binary search as $l=0$ and the right boundary as $r=n-1$, where $n$ is the length of the array.</p> <p>In each binary search process, we get the current midpoint $mid=(l+r)/2$.</p> <ul> <li>If $nums[mid] &gt; nums[r]$, it means that $[l,mid]$ is ordered. If $nums[l] \\leq target \\leq nums[mid]$, it means that $target$ is in $[l,mid]$, otherwise $target$ is in $[mid+1,r]$.</li> <li>If $nums[mid] &lt; nums[r]$, it means that $[mid+1,r]$ is ordered. If $nums[mid] &lt; target \\leq nums[r]$, it means that $target$ is in $[mid+1,r]$, otherwise $target$ is in $[l,mid]$.</li> <li>If $nums[mid] = nums[r]$, it means that the elements $nums[mid]$ and $nums[r]$ are equal. At this time, we cannot determine which interval $target$ is in, we can only decrease $r$ by $1$.</li> </ul> <p>After the binary search ends, if $nums[l] = target$, it means that the target value $target$ exists in the array, otherwise it does not exist.</p> <p>Note that if initially $nums[l] = nums[r]$, we loop to decrease $r$ by $1$ until $nums[l] \\neq nums[r]$.</p> <p>The time complexity is approximately $O(\\log n)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array.</p> <p>Similar problems:</p> <ul> <li>81. Search in Rotated Sorted Array II</li> </ul> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def search(self, arr: List[int], target: int) -&gt; int:\n        l, r = 0, len(arr) - 1\n        while arr[l] == arr[r]:\n            r -= 1\n        while l &lt; r:\n            mid = (l + r) &gt;&gt; 1\n            if arr[mid] &gt; arr[r]:\n                if arr[l] &lt;= target &lt;= arr[mid]:\n                    r = mid\n                else:\n                    l = mid + 1\n            elif arr[mid] &lt; arr[r]:\n                if arr[mid] &lt; target &lt;= arr[r]:\n                    l = mid + 1\n                else:\n                    r = mid\n            else:\n                r -= 1\n        return l if arr[l] == target else -1\n</code></pre> <pre><code>class Solution {\n    public int search(int[] arr, int target) {\n        int l = 0, r = arr.length - 1;\n        while (arr[l] == arr[r]) {\n            --r;\n        }\n        while (l &lt; r) {\n            int mid = (l + r) &gt;&gt; 1;\n            if (arr[mid] &gt; arr[r]) {\n                if (arr[l] &lt;= target &amp;&amp; target &lt;= arr[mid]) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            } else if (arr[mid] &lt; arr[r]) {\n                if (arr[mid] &lt; target &amp;&amp; target &lt;= arr[r]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            } else {\n                --r;\n            }\n        }\n        return arr[l] == target ? l : -1;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int search(vector&lt;int&gt;&amp; arr, int target) {\n        int l = 0, r = arr.size() - 1;\n        while (arr[l] == arr[r]) {\n            --r;\n        }\n        while (l &lt; r) {\n            int mid = (l + r) &gt;&gt; 1;\n            if (arr[mid] &gt; arr[r]) {\n                if (arr[l] &lt;= target &amp;&amp; target &lt;= arr[mid]) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            } else if (arr[mid] &lt; arr[r]) {\n                if (arr[mid] &lt; target &amp;&amp; target &lt;= arr[r]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            } else {\n                --r;\n            }\n        }\n        return arr[l] == target ? l : -1;\n    }\n};\n</code></pre> <pre><code>func search(arr []int, target int) int {\n    l, r := 0, len(arr)-1\n    for arr[l] == arr[r] {\n        r--\n    }\n    for l &lt; r {\n        mid := (l + r) &gt;&gt; 1\n        if arr[mid] &gt; arr[r] {\n            if arr[l] &lt;= target &amp;&amp; target &lt;= arr[mid] {\n                r = mid\n            } else {\n                l = mid + 1\n            }\n        } else if arr[mid] &lt; arr[r] {\n            if arr[mid] &lt; target &amp;&amp; target &lt;= arr[r] {\n                l = mid + 1\n            } else {\n                r = mid\n            }\n        } else {\n            r--\n        }\n    }\n    if arr[l] == target {\n        return l\n    }\n    return -1\n}\n</code></pre> <pre><code>function search(arr: number[], target: number): number {\n    let [l, r] = [0, arr.length - 1];\n    while (arr[l] === arr[r]) {\n        --r;\n    }\n    while (l &lt; r) {\n        const mid = (l + r) &gt;&gt; 1;\n        if (arr[mid] &gt; arr[r]) {\n            if (arr[l] &lt;= target &amp;&amp; target &lt;= arr[mid]) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        } else if (arr[mid] &lt; arr[r]) {\n            if (arr[mid] &lt; target &amp;&amp; target &lt;= arr[r]) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        } else {\n            --r;\n        }\n    }\n    return arr[l] === target ? l : -1;\n}\n</code></pre>"},{"location":"lcci/10.5.html","title":"10.05. Sparse Array Search","text":""},{"location":"lcci/10.5.html#description","title":"Description","text":"<p>Given a sorted array of strings that is interspersed with empty strings, write a method to find the location of a given string.</p> <p>Example1:</p> <pre>\n\n Input: words = [\"at\", \"\", \"\", \"\", \"ball\", \"\", \"\", \"car\", \"\", \"\",\"dad\", \"\", \"\"], s = \"ta\"\n\n Output: -1\n\n Explanation: Return -1 if <code>s</code> is not in <code>words</code>.\n\n</pre> <p>Example2:</p> <pre>\n\n Input: words = [\"at\", \"\", \"\", \"\", \"ball\", \"\", \"\", \"car\", \"\", \"\",\"dad\", \"\", \"\"], s = \"ball\"\n\n Output: 4\n\n</pre> <p>Note:</p> <ol> <li><code>1 &lt;= words.length &lt;= 1000000</code></li> </ol>"},{"location":"lcci/10.5.html#solutions","title":"Solutions","text":""},{"location":"lcci/10.5.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Solution:\n    def findString(self, words: List[str], s: str) -&gt; int:\n        left, right = 0, len(words) - 1\n        while left &lt; right:\n            mid = (left + right) &gt;&gt; 1\n            while left &lt; mid and words[mid] == '':\n                mid -= 1\n            if s &lt;= words[mid]:\n                right = mid\n            else:\n                left = mid + 1\n        return -1 if words[left] != s else left\n</code></pre> <pre><code>class Solution {\n    public int findString(String[] words, String s) {\n        int left = 0, right = words.length - 1;\n        while (left &lt; right) {\n            int mid = (left + right) &gt;&gt; 1;\n            while (left &lt; mid &amp;&amp; \"\".equals(words[mid])) {\n                --mid;\n            }\n            if (s.compareTo(words[mid]) &lt;= 0) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return s.equals(words[left]) ? left : -1;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int findString(vector&lt;string&gt;&amp; words, string s) {\n        int left = 0, right = words.size() - 1;\n        while (left &lt; right) {\n            int mid = left + right &gt;&gt; 1;\n            while (left &lt; mid &amp;&amp; words[mid] == \"\") --mid;\n            if (s &lt;= words[mid])\n                right = mid;\n            else\n                left = mid + 1;\n        }\n        return words[left] == s ? left : -1;\n    }\n};\n</code></pre> <pre><code>func findString(words []string, s string) int {\n    left, right := 0, len(words)-1\n    for left &lt; right {\n        mid := (left + right) &gt;&gt; 1\n        for left &lt; mid &amp;&amp; words[mid] == \"\" {\n            mid--\n        }\n        if s &lt;= words[mid] {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n    if words[left] == s {\n        return left\n    }\n    return -1\n}\n</code></pre>"},{"location":"lcci/10.9.html","title":"10.09. Sorted Matrix Search","text":""},{"location":"lcci/10.9.html#description","title":"Description","text":"<p>Given an M x N matrix in which each row and each column is sorted in ascending order, write a method to find an element.</p> <p>Example:</p> <p>Given matrix:</p> <pre>\n\n[\n\n  [1,   4,  7, 11, 15],\n\n  [2,   5,  8, 12, 19],\n\n  [3,   6,  9, 16, 22],\n\n  [10, 13, 14, 17, 24],\n\n  [18, 21, 23, 26, 30]\n\n]\n\n</pre> <p>Given target\u00a0=\u00a05,\u00a0return\u00a0<code>true.</code></p> <p>Given target\u00a0=\u00a020, return\u00a0<code>false.</code></p>"},{"location":"lcci/10.9.html#solutions","title":"Solutions","text":""},{"location":"lcci/10.9.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        if not matrix or not matrix[0]:\n            return False\n        m, n = len(matrix), len(matrix[0])\n        i, j = m - 1, 0\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] == target:\n                return True\n            if matrix[i][j] &gt; target:\n                i -= 1\n            else:\n                j += 1\n        return False\n</code></pre> <pre><code>class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) {\n            return false;\n        }\n        int m = matrix.length, n = matrix[0].length;\n        int i = m - 1, j = 0;\n        while (i &gt;= 0 &amp;&amp; j &lt; n) {\n            if (matrix[i][j] == target) {\n                return true;\n            }\n            if (matrix[i][j] &gt; target) {\n                --i;\n            } else {\n                ++j;\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\n        if (matrix.size() == 0 || matrix[0].size() == 0) return false;\n        int m = matrix.size(), n = matrix[0].size();\n        int i = m - 1, j = 0;\n        while (i &gt;= 0 &amp;&amp; j &lt; n) {\n            if (matrix[i][j] == target) return true;\n            if (matrix[i][j] &gt; target)\n                --i;\n            else\n                ++j;\n        }\n        return false;\n    }\n};\n</code></pre> <pre><code>func searchMatrix(matrix [][]int, target int) bool {\n    if len(matrix) == 0 || len(matrix[0]) == 0 {\n        return false\n    }\n    m, n := len(matrix), len(matrix[0])\n    i, j := m-1, 0\n    for i &gt;= 0 &amp;&amp; j &lt; n {\n        if matrix[i][j] == target {\n            return true\n        }\n        if matrix[i][j] &gt; target {\n            i--\n        } else {\n            j++\n        }\n    }\n    return false\n}\n</code></pre>"},{"location":"lcci/16.1.html","title":"16.01. Swap Numbers","text":""},{"location":"lcci/16.1.html#description","title":"Description","text":"<p>Write a function to swap a number in place (that is, without temporary vari\u00ad ables).</p> <p>Example: </p> <pre>\n\nInput: numbers = [1,2]\n\nOutput: [2,1]\n\n</pre> <p>Note: </p> <ul> <li><code>numbers.length == 2</code></li> </ul>"},{"location":"lcci/16.1.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.1.html#solution-1-bitwise-operation","title":"Solution 1: Bitwise Operation","text":"<p>We can use the XOR operation $\\oplus$ to implement the swap of two numbers.</p> <p>The XOR operation has the following three properties:</p> <ul> <li>Any number XORed with $0$ remains unchanged, i.e., $a \\oplus 0=a$.</li> <li>Any number XORed with itself results in $0$, i.e., $a \\oplus a=0$.</li> <li>The XOR operation satisfies the commutative and associative laws, i.e., $a \\oplus b \\oplus a=b \\oplus a \\oplus a=b \\oplus (a \\oplus a)=b \\oplus 0=b$.</li> </ul> <p>Therefore, we can perform the following operations on two numbers $a$ and $b$ in the array $numbers$:</p> <ul> <li>$a=a \\oplus b$, now $a$ stores the XOR result of the two numbers;</li> <li>$b=a \\oplus b$, now $b$ stores the original value of $a$;</li> <li>$a=a \\oplus b$, now $a$ stores the original value of $b$;</li> </ul> <p>In this way, we can swap two numbers without using a temporary variable.</p> <p>The time complexity is $O(1)$, and the space complexity is $O(1)$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def swapNumbers(self, numbers: List[int]) -&gt; List[int]:\n        numbers[0] ^= numbers[1]\n        numbers[1] ^= numbers[0]\n        numbers[0] ^= numbers[1]\n        return numbers\n</code></pre> <pre><code>class Solution {\n    public int[] swapNumbers(int[] numbers) {\n        numbers[0] ^= numbers[1];\n        numbers[1] ^= numbers[0];\n        numbers[0] ^= numbers[1];\n        return numbers;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; swapNumbers(vector&lt;int&gt;&amp; numbers) {\n        numbers[0] ^= numbers[1];\n        numbers[1] ^= numbers[0];\n        numbers[0] ^= numbers[1];\n        return numbers;\n    }\n};\n</code></pre> <pre><code>func swapNumbers(numbers []int) []int {\n    numbers[0] ^= numbers[1]\n    numbers[1] ^= numbers[0]\n    numbers[0] ^= numbers[1]\n    return numbers\n}\n</code></pre> <pre><code>function swapNumbers(numbers: number[]): number[] {\n    numbers[0] ^= numbers[1];\n    numbers[1] ^= numbers[0];\n    numbers[0] ^= numbers[1];\n    return numbers;\n}\n</code></pre>"},{"location":"lcci/16.1.html#solution-2","title":"Solution 2","text":"TypeScript <pre><code>function swapNumbers(numbers: number[]): number[] {\n    [numbers[0], numbers[1]] = [numbers[1], numbers[0]];\n    return numbers;\n}\n</code></pre>"},{"location":"lcci/16.10.html","title":"16.10. Living People","text":""},{"location":"lcci/16.10.html#description","title":"Description","text":"<p>Given a list of people with their birth and death years, implement a method to compute the year with the most number of people alive. You may assume that all people were born between 1900 and 2000 (inclusive). If a person was alive during any portion of that year, they should be included in that year's count. For example, Person (birth= 1908, death= 1909) is included in the counts for both 1908 and 1909.</p> <p>If there are more than one years\u00a0that have the most number of people alive, return the smallest one.</p> <p>Example: </p> <pre>\n\nInput: \n\nbirth = {1900, 1901, 1950}\n\ndeath = {1948, 1951, 2000}\n\nOutput:  1901\n\n</pre> <p>Note: </p> <ul> <li><code>0 &lt; birth.length == death.length &lt;= 10000</code></li> <li><code>birth[i] &lt;= death[i]</code></li> </ul>"},{"location":"lcci/16.10.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.10.html#solution-1-difference-array","title":"Solution 1: Difference Array","text":"<p>The problem is actually about performing addition and subtraction operations on a continuous interval, and then finding the maximum value. This can be solved using a difference array.</p> <p>Since the year range in the problem is fixed, we can use an array of length $102$ to represent the population changes from 1900 to 2000. Each element in the array represents the population change in that year, with positive numbers indicating the number of births and negative numbers indicating the number of deaths.</p> <p>We traverse the birth and death years of each person, and add one and subtract one from the corresponding year's population change, respectively. Then we traverse the difference array, and find the maximum value of the prefix sum of the difference array. The year corresponding to the maximum value is the answer.</p> <p>The time complexity is $O(n)$, and the space complexity is $O(C)$. Here, $n$ is the length of the birth and death years, and $C$ is the range of years.</p> Python3JavaC++GoTypeScriptRust <pre><code>class Solution:\n    def maxAliveYear(self, birth: List[int], death: List[int]) -&gt; int:\n        base = 1900\n        d = [0] * 102\n        for a, b in zip(birth, death):\n            d[a - base] += 1\n            d[b + 1 - base] -= 1\n        s = mx = 0\n        ans = 0\n        for i, x in enumerate(d):\n            s += x\n            if mx &lt; s:\n                mx = s\n                ans = base + i\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int maxAliveYear(int[] birth, int[] death) {\n        int base = 1900;\n        int[] d = new int[102];\n        for (int i = 0; i &lt; birth.length; ++i) {\n            int a = birth[i] - base;\n            int b = death[i] - base;\n            ++d[a];\n            --d[b + 1];\n        }\n        int s = 0, mx = 0;\n        int ans = 0;\n        for (int i = 0; i &lt; d.length; ++i) {\n            s += d[i];\n            if (mx &lt; s) {\n                mx = s;\n                ans = base + i;\n            }\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int maxAliveYear(vector&lt;int&gt;&amp; birth, vector&lt;int&gt;&amp; death) {\n        int base = 1900;\n        int d[102]{};\n        for (int i = 0; i &lt; birth.size(); ++i) {\n            int a = birth[i] - base;\n            int b = death[i] - base;\n            ++d[a];\n            --d[b + 1];\n        }\n        int s = 0, mx = 0;\n        int ans = 0;\n        for (int i = 0; i &lt; 102; ++i) {\n            s += d[i];\n            if (mx &lt; s) {\n                mx = s;\n                ans = base + i;\n            }\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func maxAliveYear(birth []int, death []int) (ans int) {\n    base := 1900\n    d := [102]int{}\n    for i, a := range birth {\n        a -= base\n        b := death[i] - base\n        d[a]++\n        d[b+1]--\n    }\n    mx, s := 0, 0\n    for i, x := range d {\n        s += x\n        if mx &lt; s {\n            mx = s\n            ans = base + i\n        }\n    }\n    return\n}\n</code></pre> <pre><code>function maxAliveYear(birth: number[], death: number[]): number {\n    const base = 1900;\n    const d: number[] = Array(102).fill(0);\n    for (let i = 0; i &lt; birth.length; ++i) {\n        const [a, b] = [birth[i] - base, death[i] - base];\n        ++d[a];\n        --d[b + 1];\n    }\n    let [s, mx] = [0, 0];\n    let ans = 0;\n    for (let i = 0; i &lt; d.length; ++i) {\n        s += d[i];\n        if (mx &lt; s) {\n            mx = s;\n            ans = base + i;\n        }\n    }\n    return ans;\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn max_alive_year(birth: Vec&lt;i32&gt;, death: Vec&lt;i32&gt;) -&gt; i32 {\n        let n = birth.len();\n        let mut d = vec![0; 102];\n        let base = 1900;\n        for i in 0..n {\n            d[(birth[i] - base) as usize] += 1;\n            d[(death[i] - base + 1) as usize] -= 1;\n        }\n        let mut ans = 0;\n        let mut mx = 0;\n        let mut s = 0;\n        for i in 0..102 {\n            s += d[i];\n            if mx &lt; s {\n                mx = s;\n                ans = base + (i as i32);\n            }\n        }\n        ans\n    }\n}\n</code></pre>"},{"location":"lcci/16.11.html","title":"16.11. Diving Board","text":""},{"location":"lcci/16.11.html#description","title":"Description","text":"<p>You are building a diving board by placing a bunch of planks of wood end-to-end. There are two types of planks, one of length <code>shorter</code> and one of length <code>longer</code>. You must use exactly <code>K</code> planks of wood. Write a method to generate all possible lengths for the diving board.</p> <p>return all lengths in non-decreasing order.</p> <p>Example: </p> <pre>\n\nInput: \n\nshorter = 1\n\nlonger = 2\n\nk = 3\n\nOutput:  {3,4,5,6}\n\n</pre> <p>Note: </p> <ul> <li>0 &lt; shorter &lt;= longer</li> <li>0 &lt;= k &lt;= 100000</li> </ul>"},{"location":"lcci/16.11.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.11.html#solution-1-case-analysis","title":"Solution 1: Case Analysis","text":"<p>If $k=0$, there is no solution, and we can directly return an empty list.</p> <p>If $shorter=longer$, we can only use a board with length $longer \\times k$, so we directly return a list with length $longer \\times k$.</p> <p>Otherwise, we can use a board with length $shorter \\times (k-i) + longer \\times i$, where $0 \\leq i \\leq k$. We enumerate $i$ in the range $[0, k]$, and calculate the corresponding length. For different values of $i$, we will not get the same length, because if $0 \\leq i \\lt j \\leq k$, then the difference in length is $(i - j) \\times (longer - shorter) \\lt 0$. Therefore, for different values of $i$, we will get different lengths.</p> <p>The time complexity is $O(k)$, where $k$ is the number of boards. Ignoring the space consumption of the answer, the space complexity is $O(1)$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def divingBoard(self, shorter: int, longer: int, k: int) -&gt; List[int]:\n        if k == 0:\n            return []\n        if longer == shorter:\n            return [longer * k]\n        ans = []\n        for i in range(k + 1):\n            ans.append(longer * i + shorter * (k - i))\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int[] divingBoard(int shorter, int longer, int k) {\n        if (k == 0) {\n            return new int[0];\n        }\n        if (longer == shorter) {\n            return new int[] {longer * k};\n        }\n        int[] ans = new int[k + 1];\n        for (int i = 0; i &lt; k + 1; ++i) {\n            ans[i] = longer * i + shorter * (k - i);\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; divingBoard(int shorter, int longer, int k) {\n        if (k == 0) return {};\n        if (longer == shorter) return {longer * k};\n        vector&lt;int&gt; ans;\n        for (int i = 0; i &lt; k + 1; ++i)\n            ans.push_back(longer * i + shorter * (k - i));\n        return ans;\n    }\n};\n</code></pre> <pre><code>func divingBoard(shorter int, longer int, k int) []int {\n    if k == 0 {\n        return []int{}\n    }\n    if longer == shorter {\n        return []int{longer * k}\n    }\n    var ans []int\n    for i := 0; i &lt; k+1; i++ {\n        ans = append(ans, longer*i+shorter*(k-i))\n    }\n    return ans\n}\n</code></pre> <pre><code>function divingBoard(shorter: number, longer: number, k: number): number[] {\n    if (k === 0) {\n        return [];\n    }\n    if (longer === shorter) {\n        return [longer * k];\n    }\n    const ans: number[] = [k + 1];\n    for (let i = 0; i &lt;= k; ++i) {\n        ans[i] = longer * i + shorter * (k - i);\n    }\n    return ans;\n}\n</code></pre>"},{"location":"lcci/16.13.html","title":"16.13. Bisect Squares","text":""},{"location":"lcci/16.13.html#description","title":"Description","text":"<p>Given two squares on a two-dimensional plane, find a line that would cut these two squares in half. Assume that the top and the bottom sides of the square run parallel to the x-axis.</p> <p>Each square consists of three values,\u00a0the coordinate of bottom left corner\u00a0<code>[X,Y] = [square[0],square[1]]</code>, and the side length\u00a0of the square <code>square[2]</code>. The line will intersect to the two squares in four points. Return the coordinates of two intersection points <code>[X<sub>1</sub>,Y<sub>1</sub>]</code>\u00a0and\u00a0<code>[X<sub>2</sub>,Y<sub>2</sub>]</code>\u00a0that the forming segment covers the other two intersection points in format of <code>{X<sub>1</sub>,Y<sub>1</sub>,X<sub>2</sub>,Y<sub>2</sub>}</code>. If <code>X<sub>1</sub> != X<sub>2</sub></code>, there should be\u00a0<code>X<sub>1</sub> &lt; X<sub>2</sub></code>, otherwise there should be\u00a0<code>Y<sub>1</sub> &lt;= Y<sub>2</sub></code>.</p> <p>If there are more than one line that can cut these two squares in half, return the one that has biggest slope (slope of a line parallel to the y-axis is considered as infinity).</p> <p>Example: </p> <pre>\n\nInput: \n\nsquare1 = {-1, -1, 2}\n\nsquare2 = {0, -1, 2}\n\nOutput: {-1,0,2,0}\n\nExplanation: y = 0 is the line that can cut these two squares in half.\n\n</pre> <p>Note: </p> <ul> <li><code>square.length == 3</code></li> <li><code>square[2] &gt; 0</code></li> </ul>"},{"location":"lcci/16.13.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.13.html#solution-1-geometric-mathematics","title":"Solution 1: Geometric Mathematics","text":"<p>We know that if a line can bisect two squares, then the line must pass through the centers of the two squares. Therefore, we can first calculate the centers of the two squares, denoted as $(x_1, y_1)$ and $(x_2, y_2)$, respectively.</p> <p>If $x_1 = x_2$, then the line is perpendicular to the $x$-axis, and we only need to find the intersection point of the top and bottom edges of the two squares.</p> <p>Otherwise, we can calculate the slope $k$ and the intercept $b$ of the line passing through the two centers, and then divide into two cases based on the absolute value of the slope:</p> <ul> <li>When $|k| \\gt 1$, the line passing through the two centers intersects with the top and bottom edges of the two squares. We calculate the maximum and minimum values of the vertical coordinates of the top and bottom edges, and then calculate the corresponding horizontal coordinate using the equation of the line, which is the intersection point of the two squares.</li> <li>When $|k| \\le 1$, the line passing through the two centers intersects with the left and right edges of the two squares. We calculate the maximum and minimum values of the horizontal coordinates of the left and right edges, and then calculate the corresponding vertical coordinate using the equation of the line, which is the intersection point of the two squares.</li> </ul> <p>The time complexity is $O(1)$, and the space complexity is $O(1)$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def cutSquares(self, square1: List[int], square2: List[int]) -&gt; List[float]:\n        x1, y1 = square1[0] + square1[2] / 2, square1[1] + square1[2] / 2\n        x2, y2 = square2[0] + square2[2] / 2, square2[1] + square2[2] / 2\n        if x1 == x2:\n            y3 = min(square1[1], square2[1])\n            y4 = max(square1[1] + square1[2], square2[1] + square2[2])\n            return [x1, y3, x2, y4]\n        k = (y2 - y1) / (x2 - x1)\n        b = y1 - k * x1\n        if abs(k) &gt; 1:\n            y3 = min(square1[1], square2[1])\n            x3 = (y3 - b) / k\n            y4 = max(square1[1] + square1[2], square2[1] + square2[2])\n            x4 = (y4 - b) / k\n            if x3 &gt; x4 or (x3 == x4 and y3 &gt; y4):\n                x3, y3, x4, y4 = x4, y4, x3, y3\n        else:\n            x3 = min(square1[0], square2[0])\n            y3 = k * x3 + b\n            x4 = max(square1[0] + square1[2], square2[0] + square2[2])\n            y4 = k * x4 + b\n        return [x3, y3, x4, y4]\n</code></pre> <pre><code>class Solution {\n    public double[] cutSquares(int[] square1, int[] square2) {\n        double x1 = square1[0] + square1[2] / 2.0;\n        double y1 = square1[1] + square1[2] / 2.0;\n        double x2 = square2[0] + square2[2] / 2.0;\n        double y2 = square2[1] + square2[2] / 2.0;\n        if (x1 == x2) {\n            double y3 = Math.min(square1[1], square2[1]);\n            double y4 = Math.max(square1[1] + square1[2], square2[1] + square2[2]);\n            return new double[] {x1, y3, x2, y4};\n        }\n        double k = (y2 - y1) / (x2 - x1);\n        double b = y1 - k * x1;\n        if (Math.abs(k) &gt; 1) {\n            double y3 = Math.min(square1[1], square2[1]);\n            double x3 = (y3 - b) / k;\n            double y4 = Math.max(square1[1] + square1[2], square2[1] + square2[2]);\n            double x4 = (y4 - b) / k;\n            if (x3 &gt; x4 || (x3 == x4 &amp;&amp; y3 &gt; y4)) {\n                return new double[] {x4, y4, x3, y3};\n            }\n            return new double[] {x3, y3, x4, y4};\n        } else {\n            double x3 = Math.min(square1[0], square2[0]);\n            double y3 = k * x3 + b;\n            double x4 = Math.max(square1[0] + square1[2], square2[0] + square2[2]);\n            double y4 = k * x4 + b;\n            return new double[] {x3, y3, x4, y4};\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;double&gt; cutSquares(vector&lt;int&gt;&amp; square1, vector&lt;int&gt;&amp; square2) {\n        double x1 = square1[0] + square1[2] / 2.0;\n        double y1 = square1[1] + square1[2] / 2.0;\n        double x2 = square2[0] + square2[2] / 2.0;\n        double y2 = square2[1] + square2[2] / 2.0;\n        if (x1 == x2) {\n            double y3 = min(square1[1], square2[1]);\n            double y4 = max(square1[1] + square1[2], square2[1] + square2[2]);\n            return {x1, y3, x2, y4};\n        }\n        double k = (y2 - y1) / (x2 - x1);\n        double b = y1 - k * x1;\n        if (abs(k) &gt; 1) {\n            double y3 = min(square1[1], square2[1]);\n            double x3 = (y3 - b) / k;\n            double y4 = max(square1[1] + square1[2], square2[1] + square2[2]);\n            double x4 = (y4 - b) / k;\n            if (x3 &gt; x4 || (x3 == x4 &amp;&amp; y3 &gt; y4)) {\n                return {x4, y4, x3, y3};\n            }\n            return {x3, y3, x4, y4};\n        } else {\n            double x3 = min(square1[0], square2[0]);\n            double y3 = k * x3 + b;\n            double x4 = max(square1[0] + square1[2], square2[0] + square2[2]);\n            double y4 = k * x4 + b;\n            return {x3, y3, x4, y4};\n        }\n    }\n};\n</code></pre> <pre><code>func cutSquares(square1 []int, square2 []int) []float64 {\n    x1, y1 := float64(square1[0])+float64(square1[2])/2, float64(square1[1])+float64(square1[2])/2\n    x2, y2 := float64(square2[0])+float64(square2[2])/2, float64(square2[1])+float64(square2[2])/2\n    if x1 == x2 {\n        y3 := math.Min(float64(square1[1]), float64(square2[1]))\n        y4 := math.Max(float64(square1[1]+square1[2]), float64(square2[1]+square2[2]))\n        return []float64{x1, y3, x2, y4}\n    }\n    k := (y2 - y1) / (x2 - x1)\n    b := y1 - k*x1\n    if math.Abs(k) &gt; 1 {\n        y3 := math.Min(float64(square1[1]), float64(square2[1]))\n        x3 := (y3 - b) / k\n        y4 := math.Max(float64(square1[1]+square1[2]), float64(square2[1]+square2[2]))\n        x4 := (y4 - b) / k\n        if x3 &gt; x4 || (x3 == x4 &amp;&amp; y3 &gt; y4) {\n            return []float64{x4, y4, x3, y3}\n        }\n        return []float64{x3, y3, x4, y4}\n    } else {\n        x3 := math.Min(float64(square1[0]), float64(square2[0]))\n        y3 := k*x3 + b\n        x4 := math.Max(float64(square1[0]+square1[2]), float64(square2[0]+square2[2]))\n        y4 := k*x4 + b\n        return []float64{x3, y3, x4, y4}\n    }\n}\n</code></pre> <pre><code>function cutSquares(square1: number[], square2: number[]): number[] {\n    const x1 = square1[0] + square1[2] / 2;\n    const y1 = square1[1] + square1[2] / 2;\n    const x2 = square2[0] + square2[2] / 2;\n    const y2 = square2[1] + square2[2] / 2;\n    if (x1 === x2) {\n        const y3 = Math.min(square1[1], square2[1]);\n        const y4 = Math.max(square1[1] + square1[2], square2[1] + square2[2]);\n        return [x1, y3, x2, y4];\n    }\n    const k = (y2 - y1) / (x2 - x1);\n    const b = y1 - k * x1;\n    if (Math.abs(k) &gt; 1) {\n        const y3 = Math.min(square1[1], square2[1]);\n        const x3 = (y3 - b) / k;\n        const y4 = Math.max(square1[1] + square1[2], square2[1] + square2[2]);\n        const x4 = (y4 - b) / k;\n        if (x3 &gt; x4 || (x3 === x4 &amp;&amp; y3 &gt; y4)) {\n            return [x4, y4, x3, y3];\n        }\n        return [x3, y3, x4, y4];\n    } else {\n        const x3 = Math.min(square1[0], square2[0]);\n        const y3 = k * x3 + b;\n        const x4 = Math.max(square1[0] + square1[2], square2[0] + square2[2]);\n        const y4 = k * x4 + b;\n        return [x3, y3, x4, y4];\n    }\n}\n</code></pre>"},{"location":"lcci/16.14.html","title":"16.14. Best Line","text":""},{"location":"lcci/16.14.html#description","title":"Description","text":"<p>Given a two-dimensional graph with points on it, find a line which passes the most number of points.</p> <p>Assume all the points that passed by the line are stored in list <code>S</code>\u00a0sorted by their number. You need to return <code>[S[0], S[1]]</code>, that is , two points that have smallest number. If there are more than one line that passes the most number of points, choose the one that has the smallest <code>S[0].</code>\u00a0If there are more that one line that has the same <code>S[0]</code>, choose the one that has smallest <code>S[1]</code>.</p> <p>Example: </p> <pre>\n\nInput:  [[0,0],[1,1],[1,0],[2,0]]\n\nOutput:  [0,2]\n\nExplanation:  The numbers of points passed by the line are [0,2,3].\n\n</pre> <p>Note: </p> <ul> <li><code>2 &lt;= len(Points) &lt;= 300</code></li> <li><code>len(Points[i]) = 2</code></li> </ul>"},{"location":"lcci/16.14.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.14.html#solution-1-brute-force","title":"Solution 1: Brute Force","text":"<p>We can enumerate any two points $(x_1, y_1), (x_2, y_2)$, connect these two points into a line, and the number of points on this line is 2. Then we enumerate other points $(x_3, y_3)$, and determine whether they are on the same line. If they are, the number of points on the line increases by 1; otherwise, the number of points on the line remains the same. Find the maximum number of points on a line, and the corresponding smallest two point indices are the answer.</p> <p>The time complexity is $O(n^3)$, and the space complexity is $O(1)$. Here, $n$ is the length of the array <code>points</code>.</p> Python3JavaC++Go <pre><code>class Solution:\n    def bestLine(self, points: List[List[int]]) -&gt; List[int]:\n        n = len(points)\n        mx = 0\n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                cnt = 2\n                for k in range(j + 1, n):\n                    x3, y3 = points[k]\n                    a = (y2 - y1) * (x3 - x1)\n                    b = (y3 - y1) * (x2 - x1)\n                    cnt += a == b\n                if mx &lt; cnt:\n                    mx = cnt\n                    x, y = i, j\n        return [x, y]\n</code></pre> <pre><code>class Solution {\n    public int[] bestLine(int[][] points) {\n        int n = points.length;\n        int mx = 0;\n        int[] ans = new int[2];\n        for (int i = 0; i &lt; n; ++i) {\n            int x1 = points[i][0], y1 = points[i][1];\n            for (int j = i + 1; j &lt; n; ++j) {\n                int x2 = points[j][0], y2 = points[j][1];\n                int cnt = 2;\n                for (int k = j + 1; k &lt; n; ++k) {\n                    int x3 = points[k][0], y3 = points[k][1];\n                    int a = (y2 - y1) * (x3 - x1);\n                    int b = (y3 - y1) * (x2 - x1);\n                    if (a == b) {\n                        ++cnt;\n                    }\n                }\n                if (mx &lt; cnt) {\n                    mx = cnt;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; bestLine(vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n        int n = points.size();\n        int mx = 0;\n        vector&lt;int&gt; ans(2);\n        for (int i = 0; i &lt; n; ++i) {\n            int x1 = points[i][0], y1 = points[i][1];\n            for (int j = i + 1; j &lt; n; ++j) {\n                int x2 = points[j][0], y2 = points[j][1];\n                int cnt = 2;\n                for (int k = j + 1; k &lt; n; ++k) {\n                    int x3 = points[k][0], y3 = points[k][1];\n                    long a = (long) (y2 - y1) * (x3 - x1);\n                    long b = (long) (y3 - y1) * (x2 - x1);\n                    cnt += a == b;\n                }\n                if (mx &lt; cnt) {\n                    mx = cnt;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func bestLine(points [][]int) []int {\n    n := len(points)\n    ans := make([]int, 2)\n    mx := 0\n    for i := 0; i &lt; n; i++ {\n        x1, y1 := points[i][0], points[i][1]\n        for j := i + 1; j &lt; n; j++ {\n            x2, y2 := points[j][0], points[j][1]\n            cnt := 2\n            for k := j + 1; k &lt; n; k++ {\n                x3, y3 := points[k][0], points[k][1]\n                a := (y2 - y1) * (x3 - x1)\n                b := (y3 - y1) * (x2 - x1)\n                if a == b {\n                    cnt++\n                }\n            }\n            if mx &lt; cnt {\n                mx = cnt\n                ans[0], ans[1] = i, j\n            }\n        }\n    }\n    return ans\n}\n</code></pre>"},{"location":"lcci/16.14.html#solution-2-enumeration-hash-table","title":"Solution 2: Enumeration + Hash Table","text":"<p>We can enumerate a point $(x_1, y_1)$, store the slope of the line connecting $(x_1, y_1)$ and all other points $(x_2, y_2)$ in a hash table. Points with the same slope are on the same line, and the key of the hash table is the slope, and the value is the number of points on the line. Find the maximum value in the hash table, which is the answer. To avoid precision issues, we can reduce the slope $\\frac{y_2 - y_1}{x_2 - x_1}$, and the reduction method is to find the greatest common divisor, and then divide the numerator and denominator by the greatest common divisor. The resulting numerator and denominator are used as the key of the hash table.</p> <p>The time complexity is $O(n^2 \\times \\log m)$, and the space complexity is $O(n)$. Here, $n$ and $m$ are the length of the array <code>points</code> and the maximum difference between all horizontal and vertical coordinates in the array <code>points</code>, respectively.</p> Python3JavaC++Go <pre><code>class Solution:\n    def bestLine(self, points: List[List[int]]) -&gt; List[int]:\n        def gcd(a, b):\n            return a if b == 0 else gcd(b, a % b)\n\n        n = len(points)\n        mx = 0\n        for i in range(n):\n            x1, y1 = points[i]\n            cnt = defaultdict(list)\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                dx, dy = x2 - x1, y2 - y1\n                g = gcd(dx, dy)\n                k = (dx // g, dy // g)\n                cnt[k].append((i, j))\n                if mx &lt; len(cnt[k]) or (mx == len(cnt[k]) and (x, y) &gt; cnt[k][0]):\n                    mx = len(cnt[k])\n                    x, y = cnt[k][0]\n        return [x, y]\n</code></pre> <pre><code>class Solution {\n    public int[] bestLine(int[][] points) {\n        int n = points.length;\n        int mx = 0;\n        int[] ans = new int[2];\n        for (int i = 0; i &lt; n; ++i) {\n            int x1 = points[i][0], y1 = points[i][1];\n            Map&lt;String, List&lt;int[]&gt;&gt; cnt = new HashMap&lt;&gt;();\n            for (int j = i + 1; j &lt; n; ++j) {\n                int x2 = points[j][0], y2 = points[j][1];\n                int dx = x2 - x1, dy = y2 - y1;\n                int g = gcd(dx, dy);\n                String key = (dx / g) + \".\" + (dy / g);\n                cnt.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(new int[] {i, j});\n                if (mx &lt; cnt.get(key).size()\n                    || (mx == cnt.get(key).size()\n                        &amp;&amp; (ans[0] &gt; cnt.get(key).get(0)[0]\n                            || (ans[0] == cnt.get(key).get(0)[0]\n                                &amp;&amp; ans[1] &gt; cnt.get(key).get(0)[1])))) {\n                    mx = cnt.get(key).size();\n                    ans = cnt.get(key).get(0);\n                }\n            }\n        }\n        return ans;\n    }\n\n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; bestLine(vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n        int n = points.size();\n        int mx = 0;\n        pair&lt;int, int&gt; ans = {0, 0};\n        for (int i = 0; i &lt; n; ++i) {\n            int x1 = points[i][0], y1 = points[i][1];\n            unordered_map&lt;string, vector&lt;pair&lt;int, int&gt;&gt;&gt; cnt;\n            for (int j = i + 1; j &lt; n; ++j) {\n                int x2 = points[j][0], y2 = points[j][1];\n                int dx = x2 - x1, dy = y2 - y1;\n                int g = gcd(dx, dy);\n                string k = to_string(dx / g) + \".\" + to_string(dy / g);\n                cnt[k].push_back({i, j});\n                if (mx &lt; cnt[k].size() || (mx == cnt[k].size() &amp;&amp; ans &gt; cnt[k][0])) {\n                    mx = cnt[k].size();\n                    ans = cnt[k][0];\n                }\n            }\n        }\n        return vector&lt;int&gt;{ans.first, ans.second};\n    }\n\n    int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n};\n</code></pre> <pre><code>func bestLine(points [][]int) []int {\n    n := len(points)\n    ans := make([]int, 2)\n    type pair struct{ i, j int }\n    mx := 0\n    for i := 0; i &lt; n; i++ {\n        x1, y1 := points[i][0], points[i][1]\n        cnt := map[pair][]pair{}\n        for j := i + 1; j &lt; n; j++ {\n            x2, y2 := points[j][0], points[j][1]\n            dx, dy := x2-x1, y2-y1\n            g := gcd(dx, dy)\n            k := pair{dx / g, dy / g}\n            cnt[k] = append(cnt[k], pair{i, j})\n            if mx &lt; len(cnt[k]) || (mx == len(cnt[k]) &amp;&amp; (ans[0] &gt; cnt[k][0].i || (ans[0] == cnt[k][0].i &amp;&amp; ans[1] &gt; cnt[k][0].j))) {\n                mx = len(cnt[k])\n                ans[0], ans[1] = cnt[k][0].i, cnt[k][0].j\n            }\n        }\n    }\n    return ans\n}\n\nfunc gcd(a, b int) int {\n    if b == 0 {\n        return a\n    }\n    return gcd(b, a%b)\n}\n</code></pre>"},{"location":"lcci/16.15.html","title":"16.15. Master Mind","text":""},{"location":"lcci/16.15.html#description","title":"Description","text":"<p>The Game of Master Mind is played as follows:</p> <p>The computer has four slots, and each slot will contain a ball that is red (R). yellow (Y). green (G) or blue (B). For example, the computer might have RGGB (Slot #1 is red, Slots #2 and #3 are green, Slot #4 is blue).</p> <p>You, the user, are trying to guess the solution. You might, for example, guess YRGB.</p> <p>When you guess the correct color for the correct slot, you get a \"hit:' If you guess a color that exists but is in the wrong slot, you get a \"pseudo-hit:' Note that a slot that is a hit can never count as a pseudo-hit.</p> <p>For example, if the actual solution is RGBY and you guess GGRR, you have one hit and one pseudo-hit. Write a method that, given a guess and a solution, returns the number of hits and pseudo-hits.</p> <p>Given a sequence of colors <code>solution</code>, and a <code>guess</code>, write a method that return the number of hits and pseudo-hit <code>answer</code>, where <code>answer[0]</code> is the number of hits and <code>answer[1]</code> is the number of pseudo-hit.</p> <p>Example: </p> <pre>\n\nInput:  solution=\"RGBY\",guess=\"GGRR\"\n\nOutput:  [1,1]\n\nExplanation:  hit once, pseudo-hit once.\n\n</pre> <p>Note: </p> <ul> <li><code>len(solution) = len(guess) = 4</code></li> <li>There are only <code>\"R\"</code>,<code>\"G\"</code>,<code>\"B\"</code>,<code>\"Y\"</code> in <code>solution</code>\u00a0and\u00a0<code>guess</code>.</li> </ul>"},{"location":"lcci/16.15.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.15.html#solution-1-hash-table","title":"Solution 1: Hash Table","text":"<p>We simultaneously traverse both strings, count the number of corresponding characters that are the same, and accumulate them in $x$. Then we record the characters and their frequencies in both strings in hash tables $cnt1$ and $cnt2$, respectively.</p> <p>Next, we traverse both hash tables, count the number of common characters, and accumulate them in $y$. The answer is then $[x, y - x]$.</p> <p>The time complexity is $O(C)$, and the space complexity is $O(C)$. Here, $C=4$ for this problem.</p> Python3JavaC++GoJavaScript <pre><code>class Solution:\n    def masterMind(self, solution: str, guess: str) -&gt; List[int]:\n        x = sum(a == b for a, b in zip(solution, guess))\n        y = sum((Counter(solution) &amp; Counter(guess)).values())\n        return [x, y - x]\n</code></pre> <pre><code>class Solution {\n    public int[] masterMind(String solution, String guess) {\n        int x = 0, y = 0;\n        Map&lt;Character, Integer&gt; cnt1 = new HashMap&lt;&gt;();\n        Map&lt;Character, Integer&gt; cnt2 = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; 4; ++i) {\n            char a = solution.charAt(i), b = guess.charAt(i);\n            x += a == b ? 1 : 0;\n            cnt1.merge(a, 1, Integer::sum);\n            cnt2.merge(b, 1, Integer::sum);\n        }\n        for (char c : \"RYGB\".toCharArray()) {\n            y += Math.min(cnt1.getOrDefault(c, 0), cnt2.getOrDefault(c, 0));\n        }\n        return new int[] {x, y - x};\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; masterMind(string solution, string guess) {\n        int x = 0, y = 0;\n        unordered_map&lt;char, int&gt; cnt1;\n        unordered_map&lt;char, int&gt; cnt2;\n        for (int i = 0; i &lt; 4; ++i) {\n            x += solution[i] == guess[i];\n            cnt1[solution[i]]++;\n            cnt2[guess[i]]++;\n        }\n        for (char c : \"RYGB\") y += min(cnt1[c], cnt2[c]);\n        return vector&lt;int&gt;{x, y - x};\n    }\n};\n</code></pre> <pre><code>func masterMind(solution string, guess string) []int {\n    var x, y int\n    cnt1 := map[byte]int{}\n    cnt2 := map[byte]int{}\n    for i := range solution {\n        a, b := solution[i], guess[i]\n        if a == b {\n            x++\n        }\n        cnt1[a]++\n        cnt2[b]++\n    }\n    for _, c := range []byte(\"RYGB\") {\n        y += min(cnt1[c], cnt2[c])\n    }\n    return []int{x, y - x}\n}\n</code></pre> <pre><code>/**\n * @param {string} solution\n * @param {string} guess\n * @return {number[]}\n */\nvar masterMind = function (solution, guess) {\n    let counts1 = { R: 0, G: 0, B: 0, Y: 0 };\n    let counts2 = { R: 0, G: 0, B: 0, Y: 0 };\n    let res1 = 0;\n    for (let i = 0; i &lt; solution.length; i++) {\n        let s1 = solution.charAt(i),\n            s2 = guess.charAt(i);\n        if (s1 == s2) {\n            res1++;\n        } else {\n            counts1[s1] += 1;\n            counts2[s2] += 1;\n        }\n    }\n    let res2 = ['R', 'G', 'B', 'Y'].reduce((a, c) =&gt; a + Math.min(counts1[c], counts2[c]), 0);\n    return [res1, res2];\n};\n</code></pre>"},{"location":"lcci/16.16.html","title":"16.16. Sub Sort","text":""},{"location":"lcci/16.16.html#description","title":"Description","text":"<p>Given an array of integers, write a method to find indices m and n such that if you sorted\u00a0elements m through n, the entire array would be sorted. Minimize <code>n - m</code> (that is, find the smallest such sequence).</p> <p>Return <code>[m,n]</code>. If there are no such m and n (e.g. the array is already sorted), return [-1, -1].</p> <p>Example: </p> <pre>\n\nInput:  [1,2,4,7,10,11,7,12,6,7,16,18,19]\n\nOutput:  [3,9]\n\n</pre> <p>Note: </p> <ul> <li><code>0 &lt;= len(array) &lt;= 1000000</code></li> </ul>"},{"location":"lcci/16.16.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.16.html#solution-1-two-passes","title":"Solution 1: Two Passes","text":"<p>We first traverse the array $array$ from left to right, and use $mx$ to record the maximum value encountered so far. If the current value $x$ is less than $mx$, it means that $x$ needs to be sorted, and we record the index $i$ of $x$ as $right$; otherwise, update $mx$.</p> <p>Similarly, we traverse the array $array$ from right to left, and use $mi$ to record the minimum value encountered so far. If the current value $x$ is greater than $mi$, it means that $x$ needs to be sorted, and we record the index $i$ of $x$ as $left$; otherwise, update $mi$.</p> <p>Finally, return $[left, right]$.</p> <p>The time complexity is $O(n)$, where $n$ is the length of the array $array$. The space complexity is $O(1)$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def subSort(self, array: List[int]) -&gt; List[int]:\n        n = len(array)\n        mi, mx = inf, -inf\n        left = right = -1\n        for i, x in enumerate(array):\n            if x &lt; mx:\n                right = i\n            else:\n                mx = x\n        for i in range(n - 1, -1, -1):\n            if array[i] &gt; mi:\n                left = i\n            else:\n                mi = array[i]\n        return [left, right]\n</code></pre> <pre><code>class Solution {\n    public int[] subSort(int[] array) {\n        int n = array.length;\n        int mi = Integer.MAX_VALUE, mx = Integer.MIN_VALUE;\n        int left = -1, right = -1;\n        for (int i = 0; i &lt; n; ++i) {\n            if (array[i] &lt; mx) {\n                right = i;\n            } else {\n                mx = array[i];\n            }\n        }\n        for (int i = n - 1; i &gt;= 0; --i) {\n            if (array[i] &gt; mi) {\n                left = i;\n            } else {\n                mi = array[i];\n            }\n        }\n        return new int[] {left, right};\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; subSort(vector&lt;int&gt;&amp; array) {\n        int n = array.size();\n        int mi = INT_MAX, mx = INT_MIN;\n        int left = -1, right = -1;\n        for (int i = 0; i &lt; n; ++i) {\n            if (array[i] &lt; mx) {\n                right = i;\n            } else {\n                mx = array[i];\n            }\n        }\n        for (int i = n - 1; ~i; --i) {\n            if (array[i] &gt; mi) {\n                left = i;\n            } else {\n                mi = array[i];\n            }\n        }\n        return {left, right};\n    }\n};\n</code></pre> <pre><code>func subSort(array []int) []int {\n    n := len(array)\n    mi, mx := math.MaxInt32, math.MinInt32\n    left, right := -1, -1\n    for i, x := range array {\n        if x &lt; mx {\n            right = i\n        } else {\n            mx = x\n        }\n    }\n    for i := n - 1; i &gt;= 0; i-- {\n        if array[i] &gt; mi {\n            left = i\n        } else {\n            mi = array[i]\n        }\n    }\n    return []int{left, right}\n}\n</code></pre> <pre><code>function subSort(array: number[]): number[] {\n    const n = array.length;\n    let [mi, mx] = [Infinity, -Infinity];\n    let [left, right] = [-1, -1];\n    for (let i = 0; i &lt; n; ++i) {\n        if (array[i] &lt; mx) {\n            right = i;\n        } else {\n            mx = array[i];\n        }\n    }\n    for (let i = n - 1; ~i; --i) {\n        if (array[i] &gt; mi) {\n            left = i;\n        } else {\n            mi = array[i];\n        }\n    }\n    return [left, right];\n}\n</code></pre>"},{"location":"lcci/16.17.html","title":"16.17. Contiguous Sequence","text":""},{"location":"lcci/16.17.html#description","title":"Description","text":"<p>You are given an array of integers (both positive and negative). Find the contiguous sequence with the largest sum. Return the sum.</p> <p>Example: </p> <pre>\n\n\n\nInput:  [-2,1,-3,4,-1,2,1,-5,4]\n\n\n\nOutput:  6\n\n\n\nExplanation:  [4,-1,2,1] has the largest sum 6.\n\n\n\n</pre> <p>Follow Up: </p> <p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>"},{"location":"lcci/16.17.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.17.html#solution-1-dynamic-programming","title":"Solution 1: Dynamic Programming","text":"<p>We define $f[i]$ as the maximum sum of a continuous subarray that ends with $nums[i]$. The state transition equation is:</p> <p>$$ f[i] = \\max(f[i-1], 0) + nums[i] $$</p> <p>where $f[0] = nums[0]$.</p> <p>The answer is $\\max\\limits_{i=0}^{n-1}f[i]$.</p> <p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array.</p> <p>We notice that $f[i]$ only depends on $f[i-1]$, so we can use a variable $f$ to represent $f[i-1]$, thus reducing the space complexity to $O(1)$.</p> Python3JavaC++GoTypeScriptJavaScript <pre><code>class Solution:\n    def maxSubArray(self, nums: List[int]) -&gt; int:\n        ans = f = -inf\n        for x in nums:\n            f = max(f, 0) + x\n            ans = max(ans, f)\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int maxSubArray(int[] nums) {\n        int ans = Integer.MIN_VALUE, f = Integer.MIN_VALUE;\n        for (int x : nums) {\n            f = Math.max(f, 0) + x;\n            ans = Math.max(ans, f);\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) {\n        int ans = INT_MIN, f = INT_MIN;\n        for (int x : nums) {\n            f = max(f, 0) + x;\n            ans = max(ans, f);\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func maxSubArray(nums []int) int {\n    ans, f := math.MinInt32, math.MinInt32\n    for _, x := range nums {\n        f = max(f, 0) + x\n        ans = max(ans, f)\n    }\n    return ans\n}\n</code></pre> <pre><code>function maxSubArray(nums: number[]): number {\n    let [ans, f] = [-Infinity, -Infinity];\n    for (const x of nums) {\n        f = Math.max(f, 0) + x;\n        ans = Math.max(ans, f);\n    }\n    return ans;\n}\n</code></pre> <pre><code>/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function (nums) {\n    let [ans, f] = [-Infinity, -Infinity];\n    for (const x of nums) {\n        f = Math.max(f, 0) + x;\n        ans = Math.max(ans, f);\n    }\n    return ans;\n};\n</code></pre>"},{"location":"lcci/16.18.html","title":"16.18. Pattern Matching","text":""},{"location":"lcci/16.18.html#description","title":"Description","text":"<p>You are given two strings, pattern and value. The pattern string consists of just the letters a and b, describing a pattern within a string. For example, the string catcatgocatgo matches the pattern aabab (where cat is a and go is b). It also matches patterns like a, ab, and b. Write a method to determine if value matches pattern. a and b cannot be the same string.</p> <p>Example 1: </p> <pre>\n\nInput:  pattern = \"abba\", value = \"dogcatcatdog\"\n\nOutput:  true\n\n</pre> <p>Example 2: </p> <pre>\n\nInput:  pattern = \"abba\", value = \"dogcatcatfish\"\n\nOutput:  false\n\n</pre> <p>Example 3: </p> <pre>\n\nInput:  pattern = \"aaaa\", value = \"dogcatcatdog\"\n\nOutput:  false\n\n</pre> <p>Example 4: </p> <pre>\n\nInput:  pattern = \"abba\", value = \"dogdogdogdog\"\n\nOutput:  true\n\nExplanation:  \"a\"=\"dogdog\",b=\"\"\uff0cvice versa.\n\n</pre> <p>Note: </p> <ul> <li><code>0 &lt;= len(pattern) &lt;= 1000</code></li> <li><code>0 &lt;= len(value) &lt;= 1000</code></li> <li><code>pattern</code>\u00a0only contains\u00a0<code>\"a\"</code>\u00a0and\u00a0<code>\"b\"</code>,\u00a0<code>value</code> only contains lowercase letters.</li> </ul>"},{"location":"lcci/16.18.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.18.html#solution-1-enumeration","title":"Solution 1: Enumeration","text":"<p>We first count the number of characters <code>'a'</code> and <code>'b'</code> in the pattern string $pattern$, denoted as $cnt[0]$ and $cnt[1]$, respectively. Let the length of the string $value$ be $n$.</p> <p>If $cnt[0]=0$, it means that the pattern string only contains the character <code>'b'</code>. We need to check whether $n$ is a multiple of $cnt[1]$, and whether $value$ can be divided into $cnt[1]$ substrings of length $n/cnt[1]$, and all these substrings are the same. If not, return $false$ directly.</p> <p>If $cnt[1]=0$, it means that the pattern string only contains the character <code>'a'</code>. We need to check whether $n$ is a multiple of $cnt[0]$, and whether $value$ can be divided into $cnt[0]$ substrings of length $n/cnt[0]$, and all these substrings are the same. If not, return $false$ directly.</p> <p>Next, we denote the length of the string matched by the character <code>'a'</code> as $la$, and the length of the string matched by the character <code>'b'</code> as $lb$. Then we have $la \\times cnt[0] + lb \\times cnt[1] = n$. If we enumerate $la$, we can determine the value of $lb$. Therefore, we can enumerate $la$ and check whether there exists an integer $lb$ that satisfies the above equation.</p> <p>The time complexity is $O(n^2)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string $value$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def patternMatching(self, pattern: str, value: str) -&gt; bool:\n        def check(la: int, lb: int) -&gt; bool:\n            i = 0\n            a, b = \"\", \"\"\n            for c in pattern:\n                if c == \"a\":\n                    if a and value[i : i + la] != a:\n                        return False\n                    a = value[i : i + la]\n                    i += la\n                else:\n                    if b and value[i : i + lb] != b:\n                        return False\n                    b = value[i : i + lb]\n                    i += lb\n            return a != b\n\n        n = len(value)\n        cnt = Counter(pattern)\n        if cnt[\"a\"] == 0:\n            return n % cnt[\"b\"] == 0 and value[: n // cnt[\"b\"]] * cnt[\"b\"] == value\n        if cnt[\"b\"] == 0:\n            return n % cnt[\"a\"] == 0 and value[: n // cnt[\"a\"]] * cnt[\"a\"] == value\n\n        for la in range(n + 1):\n            if la * cnt[\"a\"] &gt; n:\n                break\n            lb, mod = divmod(n - la * cnt[\"a\"], cnt[\"b\"])\n            if mod == 0 and check(la, lb):\n                return True\n        return False\n</code></pre> <pre><code>class Solution {\n    private String pattern;\n    private String value;\n\n    public boolean patternMatching(String pattern, String value) {\n        this.pattern = pattern;\n        this.value = value;\n        int[] cnt = new int[2];\n        for (char c : pattern.toCharArray()) {\n            ++cnt[c - 'a'];\n        }\n        int n = value.length();\n        if (cnt[0] == 0) {\n            return n % cnt[1] == 0 &amp;&amp; value.substring(0, n / cnt[1]).repeat(cnt[1]).equals(value);\n        }\n        if (cnt[1] == 0) {\n            return n % cnt[0] == 0 &amp;&amp; value.substring(0, n / cnt[0]).repeat(cnt[0]).equals(value);\n        }\n        for (int la = 0; la &lt;= n; ++la) {\n            if (la * cnt[0] &gt; n) {\n                break;\n            }\n            if ((n - la * cnt[0]) % cnt[1] == 0) {\n                int lb = (n - la * cnt[0]) / cnt[1];\n                if (check(la, lb)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean check(int la, int lb) {\n        int i = 0;\n        String a = null, b = null;\n        for (char c : pattern.toCharArray()) {\n            if (c == 'a') {\n                if (a != null &amp;&amp; !a.equals(value.substring(i, i + la))) {\n                    return false;\n                }\n                a = value.substring(i, i + la);\n                i += la;\n            } else {\n                if (b != null &amp;&amp; !b.equals(value.substring(i, i + lb))) {\n                    return false;\n                }\n                b = value.substring(i, i + lb);\n                i += lb;\n            }\n        }\n        return !a.equals(b);\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    bool patternMatching(string pattern, string value) {\n        int n = value.size();\n        int cnt[2]{};\n        for (char c : pattern) {\n            cnt[c - 'a']++;\n        }\n        if (cnt[0] == 0) {\n            return n % cnt[1] == 0 &amp;&amp; repeat(value.substr(0, n / cnt[1]), cnt[1]) == value;\n        }\n        if (cnt[1] == 0) {\n            return n % cnt[0] == 0 &amp;&amp; repeat(value.substr(0, n / cnt[0]), cnt[0]) == value;\n        }\n        auto check = [&amp;](int la, int lb) {\n            int i = 0;\n            string a, b;\n            for (char c : pattern) {\n                if (c == 'a') {\n                    if (!a.empty() &amp;&amp; a != value.substr(i, la)) {\n                        return false;\n                    }\n                    a = value.substr(i, la);\n                    i += la;\n                } else {\n                    if (!b.empty() &amp;&amp; b != value.substr(i, lb)) {\n                        return false;\n                    }\n                    b = value.substr(i, lb);\n                    i += lb;\n                }\n            }\n            return a != b;\n        };\n        for (int la = 0; la &lt;= n; ++la) {\n            if (la * cnt[0] &gt; n) {\n                break;\n            }\n            if ((n - la * cnt[0]) % cnt[1] == 0) {\n                int lb = (n - la * cnt[0]) / cnt[1];\n                if (check(la, lb)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    string repeat(string s, int n) {\n        string ans;\n        while (n--) {\n            ans += s;\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func patternMatching(pattern string, value string) bool {\n    cnt := [2]int{}\n    for _, c := range pattern {\n        cnt[c-'a']++\n    }\n    n := len(value)\n    if cnt[0] == 0 {\n        return n%cnt[1] == 0 &amp;&amp; strings.Repeat(value[:n/cnt[1]], cnt[1]) == value\n    }\n    if cnt[1] == 0 {\n        return n%cnt[0] == 0 &amp;&amp; strings.Repeat(value[:n/cnt[0]], cnt[0]) == value\n    }\n    check := func(la, lb int) bool {\n        i := 0\n        a, b := \"\", \"\"\n        for _, c := range pattern {\n            if c == 'a' {\n                if a != \"\" &amp;&amp; value[i:i+la] != a {\n                    return false\n                }\n                a = value[i : i+la]\n                i += la\n            } else {\n                if b != \"\" &amp;&amp; value[i:i+lb] != b {\n                    return false\n                }\n                b = value[i : i+lb]\n                i += lb\n            }\n        }\n        return a != b\n    }\n    for la := 0; la &lt;= n; la++ {\n        if la*cnt[0] &gt; n {\n            break\n        }\n        if (n-la*cnt[0])%cnt[1] == 0 {\n            lb := (n - la*cnt[0]) / cnt[1]\n            if check(la, lb) {\n                return true\n            }\n        }\n    }\n    return false\n}\n</code></pre> <pre><code>function patternMatching(pattern: string, value: string): boolean {\n    const cnt: number[] = [0, 0];\n    for (const c of pattern) {\n        cnt[c === 'a' ? 0 : 1]++;\n    }\n    const n = value.length;\n    if (cnt[0] === 0) {\n        return n % cnt[1] === 0 &amp;&amp; value.slice(0, (n / cnt[1]) | 0).repeat(cnt[1]) === value;\n    }\n    if (cnt[1] === 0) {\n        return n % cnt[0] === 0 &amp;&amp; value.slice(0, (n / cnt[0]) | 0).repeat(cnt[0]) === value;\n    }\n    const check = (la: number, lb: number) =&gt; {\n        let i = 0;\n        let a = '';\n        let b = '';\n        for (const c of pattern) {\n            if (c === 'a') {\n                if (a &amp;&amp; a !== value.slice(i, i + la)) {\n                    return false;\n                }\n                a = value.slice(i, (i += la));\n            } else {\n                if (b &amp;&amp; b !== value.slice(i, i + lb)) {\n                    return false;\n                }\n                b = value.slice(i, (i += lb));\n            }\n        }\n        return a !== b;\n    };\n    for (let la = 0; la &lt;= n; ++la) {\n        if (la * cnt[0] &gt; n) {\n            break;\n        }\n        if ((n - la * cnt[0]) % cnt[1] === 0) {\n            const lb = ((n - la * cnt[0]) / cnt[1]) | 0;\n            if (check(la, lb)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n</code></pre>"},{"location":"lcci/16.19.html","title":"16.19. Pond Sizes","text":""},{"location":"lcci/16.19.html#description","title":"Description","text":"<p>You have an integer matrix representing a plot of land, where the value at that loca\u00adtion represents the height above sea level. A value of zero indicates water. A pond is a region of water connected vertically, horizontally, or diagonally. The size of the pond is the total number of connected water cells. Write a method to compute the sizes of all ponds in the matrix.</p> <p>Example: </p> <pre>\n\nInput: \n\n[\n\n  [0,2,1,0],\n\n  [0,1,0,1],\n\n  [1,1,0,1],\n\n  [0,1,0,1]\n\n]\n\nOutput:  [1,2,4]\n\n</pre> <p>Note: </p> <ul> <li><code>0 &lt; len(land) &lt;= 1000</code></li> <li><code>0 &lt; len(land[i]) &lt;= 1000</code></li> </ul>"},{"location":"lcci/16.19.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.19.html#solution-1-dfs","title":"Solution 1: DFS","text":"<p>We can traverse each point $(i, j)$ in the integer matrix $land$. If the value of the point is $0$, we start a depth-first search from this point until we reach a point with a non-zero value. The number of points searched during this process is the size of the pond, which is added to the answer array.</p> <p>Note: To avoid duplicate searches, we set the value of the searched points to $1$.</p> <p>Finally, we sort the answer array to obtain the final answer.</p> <p>The time complexity is $O(m \\times n \\times \\log (m \\times n))$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of rows and columns in the matrix $land$, respectively.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def pondSizes(self, land: List[List[int]]) -&gt; List[int]:\n        def dfs(i: int, j: int) -&gt; int:\n            res = 1\n            land[i][j] = 1\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 &lt;= x &lt; m and 0 &lt;= y &lt; n and land[x][y] == 0:\n                        res += dfs(x, y)\n            return res\n\n        m, n = len(land), len(land[0])\n        return sorted(dfs(i, j) for i in range(m) for j in range(n) if land[i][j] == 0)\n</code></pre> <pre><code>class Solution {\n    private int m;\n    private int n;\n    private int[][] land;\n\n    public int[] pondSizes(int[][] land) {\n        m = land.length;\n        n = land[0].length;\n        this.land = land;\n        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; m; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                if (land[i][j] == 0) {\n                    ans.add(dfs(i, j));\n                }\n            }\n        }\n        return ans.stream().sorted().mapToInt(Integer::valueOf).toArray();\n    }\n\n    private int dfs(int i, int j) {\n        int res = 1;\n        land[i][j] = 1;\n        for (int x = i - 1; x &lt;= i + 1; ++x) {\n            for (int y = j - 1; y &lt;= j + 1; ++y) {\n                if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; land[x][y] == 0) {\n                    res += dfs(x, y);\n                }\n            }\n        }\n        return res;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; pondSizes(vector&lt;vector&lt;int&gt;&gt;&amp; land) {\n        int m = land.size(), n = land[0].size();\n        function&lt;int(int, int)&gt; dfs = [&amp;](int i, int j) -&gt; int {\n            int res = 1;\n            land[i][j] = 1;\n            for (int x = i - 1; x &lt;= i + 1; ++x) {\n                for (int y = j - 1; y &lt;= j + 1; ++y) {\n                    if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; land[x][y] == 0) {\n                        res += dfs(x, y);\n                    }\n                }\n            }\n            return res;\n        };\n        vector&lt;int&gt; ans;\n        for (int i = 0; i &lt; m; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                if (land[i][j] == 0) {\n                    ans.push_back(dfs(i, j));\n                }\n            }\n        }\n        sort(ans.begin(), ans.end());\n        return ans;\n    }\n};\n</code></pre> <pre><code>func pondSizes(land [][]int) (ans []int) {\n    m, n := len(land), len(land[0])\n    var dfs func(i, j int) int\n    dfs = func(i, j int) int {\n        res := 1\n        land[i][j] = 1\n        for x := i - 1; x &lt;= i+1; x++ {\n            for y := j - 1; y &lt;= j+1; y++ {\n                if x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; land[x][y] == 0 {\n                    res += dfs(x, y)\n                }\n            }\n        }\n        return res\n    }\n    for i := range land {\n        for j := range land[i] {\n            if land[i][j] == 0 {\n                ans = append(ans, dfs(i, j))\n            }\n        }\n    }\n    sort.Ints(ans)\n    return\n}\n</code></pre> <pre><code>function pondSizes(land: number[][]): number[] {\n    const m = land.length;\n    const n = land[0].length;\n    const dfs = (i: number, j: number): number =&gt; {\n        let res = 1;\n        land[i][j] = 1;\n        for (let x = i - 1; x &lt;= i + 1; ++x) {\n            for (let y = j - 1; y &lt;= j + 1; ++y) {\n                if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; land[x][y] === 0) {\n                    res += dfs(x, y);\n                }\n            }\n        }\n        return res;\n    };\n    const ans: number[] = [];\n    for (let i = 0; i &lt; m; ++i) {\n        for (let j = 0; j &lt; n; ++j) {\n            if (land[i][j] === 0) {\n                ans.push(dfs(i, j));\n            }\n        }\n    }\n    ans.sort((a, b) =&gt; a - b);\n    return ans;\n}\n</code></pre>"},{"location":"lcci/16.2.html","title":"16.02. Words Frequency","text":""},{"location":"lcci/16.2.html#description","title":"Description","text":"<p>Design a method to find the frequency of occurrences of any given word in a book. What if we were running this algorithm multiple times?</p> <p>You should implement following methods:</p> <ul> <li><code>WordsFrequency(book)</code> constructor, parameter is a array of strings, representing the book.</li> <li><code>get(word)</code>\u00a0get the frequency of <code>word</code> in the book.\u00a0</li> </ul> <p>Example: </p> <pre>\n\nWordsFrequency wordsFrequency = new WordsFrequency({\"i\", \"have\", \"an\", \"apple\", \"he\", \"have\", \"a\", \"pen\"});\n\nwordsFrequency.get(\"you\"); //returns 0\uff0c\"you\" is not in the book\n\nwordsFrequency.get(\"have\"); //returns 2\uff0c\"have\" occurs twice in the book\n\nwordsFrequency.get(\"an\"); //returns 1\n\nwordsFrequency.get(\"apple\"); //returns 1\n\nwordsFrequency.get(\"pen\"); //returns 1\n\n</pre> <p>Note: </p> <ul> <li><code>There are only lowercase letters in book[i].</code></li> <li><code>1 &lt;= book.length &lt;= 100000</code></li> <li><code>1 &lt;= book[i].length &lt;= 10</code></li> <li><code>get</code>\u00a0function will not be called more than\u00a0100000 times.</li> </ul>"},{"location":"lcci/16.2.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.2.html#solution-1-hash-table","title":"Solution 1: Hash Table","text":"<p>We use a hash table $cnt$ to count the number of occurrences of each word in $book$.</p> <p>When calling the <code>get</code> function, we only need to return the number of occurrences of the corresponding word in $cnt$.</p> <p>In terms of time complexity, the time complexity of initializing the hash table $cnt$ is $O(n)$, where $n$ is the length of $book$. The time complexity of the <code>get</code> function is $O(1)$. The space complexity is $O(n)$.</p> Python3JavaC++GoTypeScriptRustJavaScript <pre><code>class WordsFrequency:\n    def __init__(self, book: List[str]):\n        self.cnt = Counter(book)\n\n    def get(self, word: str) -&gt; int:\n        return self.cnt[word]\n\n\n# Your WordsFrequency object will be instantiated and called as such:\n# obj = WordsFrequency(book)\n# param_1 = obj.get(word)\n</code></pre> <pre><code>class WordsFrequency {\n    private Map&lt;String, Integer&gt; cnt = new HashMap&lt;&gt;();\n\n    public WordsFrequency(String[] book) {\n        for (String x : book) {\n            cnt.merge(x, 1, Integer::sum);\n        }\n    }\n\n    public int get(String word) {\n        return cnt.getOrDefault(word, 0);\n    }\n}\n\n/**\n * Your WordsFrequency object will be instantiated and called as such:\n * WordsFrequency obj = new WordsFrequency(book);\n * int param_1 = obj.get(word);\n */\n</code></pre> <pre><code>class WordsFrequency {\npublic:\n    WordsFrequency(vector&lt;string&gt;&amp; book) {\n        for (auto&amp; x : book) {\n            ++cnt[x];\n        }\n    }\n\n    int get(string word) {\n        return cnt[word];\n    }\n\nprivate:\n    unordered_map&lt;string, int&gt; cnt;\n};\n\n/**\n * Your WordsFrequency object will be instantiated and called as such:\n * WordsFrequency* obj = new WordsFrequency(book);\n * int param_1 = obj-&gt;get(word);\n */\n</code></pre> <pre><code>type WordsFrequency struct {\n    cnt map[string]int\n}\n\nfunc Constructor(book []string) WordsFrequency {\n    cnt := map[string]int{}\n    for _, x := range book {\n        cnt[x]++\n    }\n    return WordsFrequency{cnt}\n}\n\nfunc (this *WordsFrequency) Get(word string) int {\n    return this.cnt[word]\n}\n\n/**\n * Your WordsFrequency object will be instantiated and called as such:\n * obj := Constructor(book);\n * param_1 := obj.Get(word);\n */\n</code></pre> <pre><code>class WordsFrequency {\n    private cnt: Map&lt;string, number&gt;;\n\n    constructor(book: string[]) {\n        const cnt = new Map&lt;string, number&gt;();\n        for (const word of book) {\n            cnt.set(word, (cnt.get(word) ?? 0) + 1);\n        }\n        this.cnt = cnt;\n    }\n\n    get(word: string): number {\n        return this.cnt.get(word) ?? 0;\n    }\n}\n\n/**\n * Your WordsFrequency object will be instantiated and called as such:\n * var obj = new WordsFrequency(book)\n * var param_1 = obj.get(word)\n */\n</code></pre> <pre><code>use std::collections::HashMap;\nstruct WordsFrequency {\n    cnt: HashMap&lt;String, i32&gt;,\n}\n\n/**\n * `&amp;self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&amp;mut self` instead.\n */\nimpl WordsFrequency {\n    fn new(book: Vec&lt;String&gt;) -&gt; Self {\n        let mut cnt = HashMap::new();\n        for word in book.into_iter() {\n            *cnt.entry(word).or_insert(0) += 1;\n        }\n        Self { cnt }\n    }\n\n    fn get(&amp;self, word: String) -&gt; i32 {\n        *self.cnt.get(&amp;word).unwrap_or(&amp;0)\n    }\n}/**\n * Your WordsFrequency object will be instantiated and called as such:\n * let obj = WordsFrequency::new(book);\n * let ret_1: i32 = obj.get(word);\n */\n</code></pre> <pre><code>/**\n * @param {string[]} book\n */\nvar WordsFrequency = function (book) {\n    this.cnt = new Map();\n    for (const x of book) {\n        this.cnt.set(x, (this.cnt.get(x) || 0) + 1);\n    }\n};\n\n/**\n * @param {string} word\n * @return {number}\n */\nWordsFrequency.prototype.get = function (word) {\n    return this.cnt.get(word) || 0;\n};\n\n/**\n * Your WordsFrequency object will be instantiated and called as such:\n * var obj = new WordsFrequency(book)\n * var param_1 = obj.get(word)\n */\n</code></pre>"},{"location":"lcci/16.20.html","title":"16.20. T9","text":""},{"location":"lcci/16.20.html#description","title":"Description","text":"<p>On old cell phones, users typed on a numeric keypad and the phone would provide a list of words that matched these numbers. Each digit mapped to a set of 0\u00a0- 4 letters. Implement an algo\u00adrithm to return a list of matching words, given a sequence of digits. You are provided a list of valid words. The mapping is shown in the diagram below:</p> <p></p> <p>Example 1:</p> <pre>\n\nInput: num = \"8733\", words = [\"tree\", \"used\"]\n\nOutput: [\"tree\", \"used\"]\n\n</pre> <p>Example 2:</p> <pre>\n\nInput: num = \"2\", words = [\"a\", \"b\", \"c\", \"d\"]\n\nOutput: [\"a\", \"b\", \"c\"]</pre> <p>Note:</p> <ul> <li><code>num.length &lt;= 1000</code></li> <li><code>words.length &lt;= 500</code></li> <li><code>words[i].length == num.length</code></li> <li><code>There are no number 0 and 1 in num</code>.</li> </ul>"},{"location":"lcci/16.20.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.20.html#solution-1-reverse-thinking","title":"Solution 1: Reverse Thinking","text":"<p>We consider a forward solution, which traverses each digit in the string $num$, maps it to the corresponding letter, combines all the letters to obtain all possible words, and then compares them with the given word list. If the word is in the list, it is added to the answer. The time complexity of this solution is $O(4^n)$, where $n$ is the length of the string $num$, which will obviously time out.</p> <p>Instead, we can consider a reverse solution, which traverses the given word list, and for each word $w$, determines whether it can be composed of the digits in the string $num$. If it can be composed, it is added to the answer. The key to the problem is how to determine whether a word can be composed of the digits in the string $num$. We only need to traverse each letter in the word $w$, restore it to the corresponding digit, and compare it with each digit in the string $num$ one by one. If they are the same, it means that the word $w$ can be composed of the digits in the string $num$.</p> <p>The time complexity is $O(m \\times n)$, and the space complexity is $O(C)$. Here, $m$ and $n$ are the length of the word list and the string $num$, respectively, and $C$ is the size of the character set, which is $26$ in this problem.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def getValidT9Words(self, num: str, words: List[str]) -&gt; List[str]:\n        def check(w: str) -&gt; bool:\n            return all(d[c] == num[i] for i, c in enumerate(w))\n\n        d = {c: d for c, d in zip(ascii_lowercase, \"22233344455566677778889999\")}\n        return [w for w in words if check(w)]\n</code></pre> <pre><code>class Solution {\n    public List&lt;String&gt; getValidT9Words(String num, String[] words) {\n        String s = \"22233344455566677778889999\";\n        int[] d = new int[26];\n        for (int i = 0; i &lt; 26; ++i) {\n            d[i] = s.charAt(i);\n        }\n        List&lt;String&gt; ans = new ArrayList&lt;&gt;();\n        int n = num.length();\n        for (String w : words) {\n            boolean ok = true;\n            for (int i = 0; i &lt; n; ++i) {\n                if (d[w.charAt(i) - 'a'] != num.charAt(i)) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                ans.add(w);\n            }\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;string&gt; getValidT9Words(string num, vector&lt;string&gt;&amp; words) {\n        string s = \"22233344455566677778889999\";\n        int d[26];\n        for (int i = 0; i &lt; 26; ++i) {\n            d[i] = s[i];\n        }\n        vector&lt;string&gt; ans;\n        int n = num.size();\n        for (auto&amp; w : words) {\n            bool ok = true;\n            for (int i = 0; i &lt; n; ++i) {\n                if (d[w[i] - 'a'] != num[i]) {\n                    ok = false;\n                }\n            }\n            if (ok) {\n                ans.emplace_back(w);\n            }\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func getValidT9Words(num string, words []string) (ans []string) {\n    s := \"22233344455566677778889999\"\n    d := [26]rune{}\n    for i, c := range s {\n        d[i] = c\n    }\n    for _, w := range words {\n        ok := true\n        for i, c := range w {\n            if d[c-'a'] != rune(num[i]) {\n                ok = false\n                break\n            }\n        }\n        if ok {\n            ans = append(ans, w)\n        }\n    }\n    return\n}\n</code></pre> <pre><code>function getValidT9Words(num: string, words: string[]): string[] {\n    const s = '22233344455566677778889999';\n    const d: string[] = Array(26);\n    for (let i = 0; i &lt; 26; ++i) {\n        d[i] = s[i];\n    }\n    const ans: string[] = [];\n    const n = num.length;\n    for (const w of words) {\n        let ok = true;\n        for (let i = 0; i &lt; n; ++i) {\n            if (d[w[i].charCodeAt(0) - 97] !== num[i]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            ans.push(w);\n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"lcci/16.20.html#solution-2","title":"Solution 2","text":"Python3 <pre><code>class Solution:\n    def getValidT9Words(self, num: str, words: List[str]) -&gt; List[str]:\n        trans = str.maketrans(ascii_lowercase, \"22233344455566677778889999\")\n        return [w for w in words if w.translate(trans) == num]\n</code></pre>"},{"location":"lcci/16.21.html","title":"16.21. Sum Swap","text":""},{"location":"lcci/16.21.html#description","title":"Description","text":"<p>Given two arrays of integers, find a pair of values (one value from each array) that you can swap to give the two arrays the same sum.</p> <p>Return an array, where the first element is the element in the first array that will be swapped, and the second element is another one in the second array. If there are more than one answers, return any one of them. If there is no answer, return an empty array.</p> <p>Example:</p> <pre>\n\nInput: array1 = [4, 1, 2, 1, 1, 2], array2 = [3, 6, 3, 3]\n\nOutput: [1, 3]\n\n</pre> <p>Example:</p> <pre>\n\nInput: array1 = <code>[1, 2, 3], array2 = [4, 5, 6]</code>\n\nOutput: []</pre> <p>Note: </p> <ul> <li><code>1 &lt;= array1.length, array2.length &lt;= 100000</code></li> </ul>"},{"location":"lcci/16.21.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.21.html#solution-1-hash-table","title":"Solution 1: Hash Table","text":"<p>We first calculate the sum of the two arrays, and then calculate the difference $diff$ between the sums. If $diff$ is odd, it means that the sums of the two arrays cannot be equal, so we directly return an empty array.</p> <p>If $diff$ is even, we can traverse one of the arrays. Suppose the current element being traversed is $a$, then we need to find an element $b$ in the other array such that $a - b = diff / 2$, i.e., $b = a - diff / 2$. We can use a hash table to quickly check whether $b$ exists. If it exists, it means that we have found a pair of elements that meet the conditions, and we can return them directly.</p> <p>The time complexity is $O(m + n)$, and the space complexity is $O(n)$. Here, $m$ and $n$ are the lengths of the two arrays.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def findSwapValues(self, array1: List[int], array2: List[int]) -&gt; List[int]:\n        diff = sum(array1) - sum(array2)\n        if diff &amp; 1:\n            return []\n        diff &gt;&gt;= 1\n        s = set(array2)\n        for a in array1:\n            if (b := (a - diff)) in s:\n                return [a, b]\n        return []\n</code></pre> <pre><code>class Solution {\n    public int[] findSwapValues(int[] array1, int[] array2) {\n        long s1 = 0, s2 = 0;\n        Set&lt;Integer&gt; s = new HashSet&lt;&gt;();\n        for (int x : array1) {\n            s1 += x;\n        }\n        for (int x : array2) {\n            s2 += x;\n            s.add(x);\n        }\n        long diff = s1 - s2;\n        if (diff % 2 != 0) {\n            return new int[0];\n        }\n        diff /= 2;\n        for (int a : array1) {\n            int b = (int) (a - diff);\n            if (s.contains(b)) {\n                return new int[] {a, b};\n            }\n        }\n        return new int[0];\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; findSwapValues(vector&lt;int&gt;&amp; array1, vector&lt;int&gt;&amp; array2) {\n        long long s1 = accumulate(array1.begin(), array1.end(), 0LL);\n        long long s2 = accumulate(array2.begin(), array2.end(), 0LL);\n        long long diff = s1 - s2;\n        if (diff &amp; 1) {\n            return {};\n        }\n        diff &gt;&gt;= 1;\n        unordered_set&lt;int&gt; s(array2.begin(), array2.end());\n        for (int x : array1) {\n            int y = x - diff;\n            if (s.count(y)) {\n                return {x, y};\n            }\n        }\n        return {};\n    }\n};\n</code></pre> <pre><code>func findSwapValues(array1 []int, array2 []int) []int {\n    s1, s2 := 0, 0\n    s := map[int]bool{}\n    for _, a := range array1 {\n        s1 += a\n    }\n    for _, b := range array2 {\n        s2 += b\n        s[b] = true\n    }\n    diff := s1 - s2\n    if (diff &amp; 1) == 1 {\n        return []int{}\n    }\n    diff &gt;&gt;= 1\n    for _, a := range array1 {\n        if b := a - diff; s[b] {\n            return []int{a, b}\n        }\n    }\n    return []int{}\n}\n</code></pre> <pre><code>function findSwapValues(array1: number[], array2: number[]): number[] {\n    const s1 = array1.reduce((a, b) =&gt; a + b, 0);\n    const s2 = array2.reduce((a, b) =&gt; a + b, 0);\n    let diff = s1 - s2;\n    if (diff &amp; 1) {\n        return [];\n    }\n    diff &gt;&gt;= 1;\n    const s: Set&lt;number&gt; = new Set(array2);\n    for (const x of array1) {\n        const y = x - diff;\n        if (s.has(y)) {\n            return [x, y];\n        }\n    }\n    return [];\n}\n</code></pre>"},{"location":"lcci/16.22.html","title":"16.22. Langtons Ant","text":""},{"location":"lcci/16.22.html#description","title":"Description","text":"<p>An ant is sitting on an infinite grid of white and black squares. It initially faces right. All squares are white initially.</p> <p>At each step, it does the following:</p> <p>(1) At a white square, flip the color of the square, turn 90 degrees right (clockwise), and move forward one unit.</p> <p>(2) At a black square, flip the color of the square, turn 90 degrees left (counter-clockwise), and move forward one unit.</p> <p>Write a program to simulate the first K moves that the ant makes and print the final board as a grid.</p> <p>The grid should be represented as an array of strings, where each element represents one row in the grid. The black square is represented as <code>'X'</code>, and the white square is represented as <code>'_'</code>, the square which is occupied by the ant is represented as <code>'L'</code>, <code>'U'</code>, <code>'R'</code>, <code>'D'</code>, which means the left, up, right and down orientations respectively. You only need to return the minimum matrix that is able to contain all squares that are passed through by the ant.</p> <p>Example 1:</p> <pre>\n\nInput: 0\n\nOutput: [\"R\"]\n\n</pre> <p>Example 2:</p> <pre>\n\nInput: 2\n\nOutput:\n\n[\n\n\u00a0 \"\\_X\",\n\n\u00a0 \"LX\"\n\n]\n\n</pre> <p>Example 3:</p> <pre>\n\nInput: 5\n\nOutput:\n\n[\n\n\u00a0 \"\\_U\",\n\n\u00a0 \"X\\_\",\n\n\u00a0 \"XX\"\n\n]\n\n</pre> <p>Note: </p> <ul> <li><code>K &lt;= 100000</code></li> </ul>"},{"location":"lcci/16.22.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.22.html#solution-1-hash-table-simulation","title":"Solution 1: Hash Table + Simulation","text":"<p>We use a hash table $black$ to record the positions of all black squares, and a hash table $dirs$ to record the four directions of the ant. We use variables $x, y$ to record the position of the ant, and variable $p$ to record the direction of the ant. We use variables $x1, y1, x2, y2$ to record the minimum horizontal coordinate, minimum vertical coordinate, maximum horizontal coordinate, and maximum vertical coordinate of all black squares.</p> <p>We simulate the ant's walking process. If the square where the ant is located is white, the ant turns right by $90$ degrees, paints the square black, and moves forward one unit. If the square where the ant is located is black, the ant turns left by $90$ degrees, paints the square white, and moves forward one unit. During the simulation, we continuously update the values of $x1, y1, x2, y2$ so that they can contain all the squares the ant has walked through.</p> <p>After the simulation is over, we construct the answer matrix $g$ based on the values of $x1, y1, x2, y2$. Then, we paint the direction of the ant on the square where the ant is located, paint all black squares with $X$, and finally return the answer matrix.</p> <p>The time complexity is $O(K)$, and the space complexity is $O(K)$. Here, $K$ is the number of steps the ant walks.</p> Python3JavaC++Go <pre><code>class Solution:\n    def printKMoves(self, K: int) -&gt; List[str]:\n        x1 = y1 = x2 = y2 = 0\n        dirs = (0, 1, 0, -1, 0)\n        d = \"RDLU\"\n        x = y = 0\n        p = 0\n        black = set()\n        for _ in range(K):\n            if (x, y) in black:\n                black.remove((x, y))\n                p = (p + 3) % 4\n            else:\n                black.add((x, y))\n                p = (p + 1) % 4\n            x += dirs[p]\n            y += dirs[p + 1]\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, x)\n            y2 = max(y2, y)\n        m, n = x2 - x1 + 1, y2 - y1 + 1\n        g = [[\"_\"] * n for _ in range(m)]\n        for i, j in black:\n            g[i - x1][j - y1] = \"X\"\n        g[x - x1][y - y1] = d[p]\n        return [\"\".join(row) for row in g]\n</code></pre> <pre><code>class Solution {\n    public List&lt;String&gt; printKMoves(int K) {\n        int x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n        int[] dirs = {0, 1, 0, -1, 0};\n        String d = \"RDLU\";\n        int x = 0, y = 0, p = 0;\n        Set&lt;List&lt;Integer&gt;&gt; black = new HashSet&lt;&gt;();\n        while (K-- &gt; 0) {\n            List&lt;Integer&gt; t = List.of(x, y);\n            if (black.add(t)) {\n                p = (p + 1) % 4;\n            } else {\n                black.remove(t);\n                p = (p + 3) % 4;\n            }\n            x += dirs[p];\n            y += dirs[p + 1];\n            x1 = Math.min(x1, x);\n            y1 = Math.min(y1, y);\n            x2 = Math.max(x2, x);\n            y2 = Math.max(y2, y);\n        }\n        int m = x2 - x1 + 1;\n        int n = y2 - y1 + 1;\n        char[][] g = new char[m][n];\n        for (char[] row : g) {\n            Arrays.fill(row, '_');\n        }\n        for (List&lt;Integer&gt; t : black) {\n            int i = t.get(0) - x1;\n            int j = t.get(1) - y1;\n            g[i][j] = 'X';\n        }\n        g[x - x1][y - y1] = d.charAt(p);\n        List&lt;String&gt; ans = new ArrayList&lt;&gt;();\n        for (char[] row : g) {\n            ans.add(String.valueOf(row));\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;string&gt; printKMoves(int K) {\n        int x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n        int dirs[5] = {0, 1, 0, -1, 0};\n        string d = \"RDLU\";\n        int x = 0, y = 0, p = 0;\n        set&lt;pair&lt;int, int&gt;&gt; black;\n        while (K--) {\n            auto t = make_pair(x, y);\n            if (black.count(t)) {\n                black.erase(t);\n                p = (p + 3) % 4;\n            } else {\n                black.insert(t);\n                p = (p + 1) % 4;\n            }\n            x += dirs[p];\n            y += dirs[p + 1];\n            x1 = min(x1, x);\n            y1 = min(y1, y);\n            x2 = max(x2, x);\n            y2 = max(y2, y);\n        }\n        int m = x2 - x1 + 1, n = y2 - y1 + 1;\n        vector&lt;string&gt; g(m, string(n, '_'));\n        for (auto&amp; [i, j] : black) {\n            g[i - x1][j - y1] = 'X';\n        }\n        g[x - x1][y - y1] = d[p];\n        return g;\n    }\n};\n</code></pre> <pre><code>func printKMoves(K int) []string {\n    var x1, y1, x2, y2, x, y, p int\n    dirs := [5]int{0, 1, 0, -1, 0}\n    d := \"RDLU\"\n    type pair struct{ x, y int }\n    black := map[pair]bool{}\n    for K &gt; 0 {\n        t := pair{x, y}\n        if black[t] {\n            delete(black, t)\n            p = (p + 3) % 4\n        } else {\n            black[t] = true\n            p = (p + 1) % 4\n        }\n        x += dirs[p]\n        y += dirs[p+1]\n        x1 = min(x1, x)\n        y1 = min(y1, y)\n        x2 = max(x2, x)\n        y2 = max(y2, y)\n        K--\n    }\n    m, n := x2-x1+1, y2-y1+1\n    g := make([][]byte, m)\n    for i := range g {\n        g[i] = make([]byte, n)\n        for j := range g[i] {\n            g[i][j] = '_'\n        }\n    }\n    for t := range black {\n        i, j := t.x-x1, t.y-y1\n        g[i][j] = 'X'\n    }\n    g[x-x1][y-y1] = d[p]\n    ans := make([]string, m)\n    for i := range ans {\n        ans[i] = string(g[i])\n    }\n    return ans\n}\n</code></pre>"},{"location":"lcci/16.24.html","title":"16.24. Pairs With Sum","text":""},{"location":"lcci/16.24.html#description","title":"Description","text":"<p>Design an algorithm to find all pairs of integers within an array which sum to a specified value.</p> <p>Example 1:</p> <pre>\n\nInput: nums = [5,6,5], target = 11\n\nOutput: [[5,6]]</pre> <p>Example 2:</p> <pre>\n\nInput: nums = [5,6,5,6], target = 11\n\nOutput: [[5,6],[5,6]]</pre> <p>Note: </p> <ul> <li><code>nums.length &lt;= 100000</code></li> </ul>"},{"location":"lcci/16.24.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.24.html#solution-1-hash-table","title":"Solution 1: Hash Table","text":"<p>We can use a hash table to store the elements in the array, with the keys being the elements in the array and the values being the number of times the element appears.</p> <p>We traverse the array, and for each element $x$, we calculate $y = target - x$. If $y$ exists in the hash table, it means that there is a pair of numbers $(x, y)$ that add up to the target, and we add it to the answer and reduce the count of $y$ by $1$. If $y$ does not exist in the hash table, it means that there is no such pair of numbers, and we increase the count of $x$ by $1$.</p> <p>After the traversal, we can obtain the answer.</p> <p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def pairSums(self, nums: List[int], target: int) -&gt; List[List[int]]:\n        cnt = Counter()\n        ans = []\n        for x in nums:\n            y = target - x\n            if cnt[y]:\n                cnt[y] -= 1\n                ans.append([x, y])\n            else:\n                cnt[x] += 1\n        return ans\n</code></pre> <pre><code>class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; pairSums(int[] nums, int target) {\n        Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;();\n        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n        for (int x : nums) {\n            int y = target - x;\n            if (cnt.containsKey(y)) {\n                ans.add(List.of(x, y));\n                if (cnt.merge(y, -1, Integer::sum) == 0) {\n                    cnt.remove(y);\n                }\n            } else {\n                cnt.merge(x, 1, Integer::sum);\n            }\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; pairSums(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; cnt;\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        for (int x : nums) {\n            int y = target - x;\n            if (cnt[y]) {\n                --cnt[y];\n                ans.push_back({x, y});\n            } else {\n                ++cnt[x];\n            }\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func pairSums(nums []int, target int) (ans [][]int) {\n    cnt := map[int]int{}\n    for _, x := range nums {\n        y := target - x\n        if cnt[y] &gt; 0 {\n            cnt[y]--\n            ans = append(ans, []int{x, y})\n        } else {\n            cnt[x]++\n        }\n    }\n    return\n}\n</code></pre> <pre><code>function pairSums(nums: number[], target: number): number[][] {\n    const cnt = new Map();\n    const ans: number[][] = [];\n    for (const x of nums) {\n        const y = target - x;\n        if (cnt.has(y)) {\n            ans.push([x, y]);\n            const yCount = cnt.get(y) - 1;\n            if (yCount === 0) {\n                cnt.delete(y);\n            } else {\n                cnt.set(y, yCount);\n            }\n        } else {\n            cnt.set(x, (cnt.get(x) || 0) + 1);\n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"lcci/16.25.html","title":"16.25. LRU Cache","text":""},{"location":"lcci/16.25.html#description","title":"Description","text":"<p>Design and build a \"least recently used\" cache, which evicts the least recently used item. The cache should map from keys to values (allowing you to insert and retrieve a value associ\u00adated with a particular key) and be initialized with a max size. When it is full, it should evict the least recently used item.</p> <p>You should implement following operations:\u00a0\u00a0<code>get</code>\u00a0and <code>put</code>.</p> <p>Get a value by key:\u00a0<code>get(key)</code> - If key is in the cache, return the value, otherwise return -1.  Write a key-value pair to the cache:\u00a0<code>put(key, value)</code> - If the key is not in the cache, then write its value to the cache. Evict the least recently used item before writing if necessary.</p> <p>Example:</p> <pre>\n\nLRUCache cache = new LRUCache( 2 /* capacity */ );\n\n\n\ncache.put(1, 1);\n\ncache.put(2, 2);\n\ncache.get(1);       // returns 1\n\ncache.put(3, 3);    // evicts key 2\n\ncache.get(2);       // returns -1 (not found)\n\ncache.put(4, 4);    // evicts key 1\n\ncache.get(1);       // returns -1 (not found)\n\ncache.get(3);       // returns 3\n\ncache.get(4);       // returns 4\n\n</pre>"},{"location":"lcci/16.25.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.25.html#solution-1","title":"Solution 1","text":"Python3Java <pre><code>class Node:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.capacity = capacity\n        self.size = 0\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_head(node)\n        return node.value\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self.move_to_head(node)\n        else:\n            node = Node(key, value)\n            self.cache[key] = node\n            self.add_to_head(node)\n            self.size += 1\n            if self.size &gt; self.capacity:\n                node = self.remove_tail()\n                self.cache.pop(node.key)\n                self.size -= 1\n\n    def move_to_head(self, node):\n        self.remove_node(node)\n        self.add_to_head(node)\n\n    def remove_node(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_head(self, node):\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n        node.prev = self.head\n\n    def remove_tail(self):\n        node = self.tail.prev\n        self.remove_node(node)\n        return node\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n</code></pre> <pre><code>class LRUCache {\n    class Node {\n        int key;\n        int value;\n        Node prev;\n        Node next;\n        Node() {\n        }\n        Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    private Map&lt;Integer, Node&gt; cache;\n    private Node head;\n    private Node tail;\n    private int capacity;\n    private int size;\n\n    public LRUCache(int capacity) {\n        cache = new HashMap&lt;&gt;();\n        this.capacity = capacity;\n        head = new Node();\n        tail = new Node();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        Node node = cache.get(key);\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key);\n            node.value = value;\n            moveToHead(node);\n        } else {\n            Node node = new Node(key, value);\n            cache.put(key, node);\n            addToHead(node);\n            ++size;\n            if (size &gt; capacity) {\n                node = removeTail();\n                cache.remove(node.key);\n                --size;\n            }\n        }\n    }\n\n    private void moveToHead(Node node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void addToHead(Node node) {\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        node.prev = head;\n    }\n\n    private Node removeTail() {\n        Node node = tail.prev;\n        removeNode(node);\n        return node;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n</code></pre>"},{"location":"lcci/16.26.html","title":"16.26. Calculator","text":""},{"location":"lcci/16.26.html#description","title":"Description","text":"<p>Given an arithmetic equation consisting of positive integers, +, -, * and / (no paren\u00adtheses), compute the result.</p> <p>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.</p> <p>Example\u00a01:</p> <pre>\n\nInput: \"3+2\\*2\"\n\nOutput: 7\n\n</pre> <p>Example 2:</p> <pre>\n\nInput: \" 3/2 \"\n\nOutput: 1</pre> <p>Example 3:</p> <pre>\n\nInput: \" 3+5 / 2 \"\n\nOutput: 5\n\n</pre> <p>Note:</p> <ul> <li>You may assume that the given expression is always valid.</li> <li>Do not use the eval built-in library function.</li> </ul>"},{"location":"lcci/16.26.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.26.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def calculate(self, s: str) -&gt; int:\n        n = len(s)\n        x = 0\n        sign = \"+\"\n        stk = []\n        for i, c in enumerate(s):\n            if c.isdigit():\n                x = x * 10 + ord(c) - ord(\"0\")\n            if i == n - 1 or c in \"+-*/\":\n                match sign:\n                    case \"+\":\n                        stk.append(x)\n                    case \"-\":\n                        stk.append(-x)\n                    case \"*\":\n                        stk.append(stk.pop() * x)\n                    case \"/\":\n                        stk.append(int(stk.pop() / x))\n                x = 0\n                sign = c\n        return sum(stk)\n</code></pre> <pre><code>class Solution {\n    public int calculate(String s) {\n        int n = s.length();\n        int x = 0;\n        char sign = '+';\n        Deque&lt;Integer&gt; stk = new ArrayDeque&lt;&gt;();\n        for (int i = 0; i &lt; n; ++i) {\n            char c = s.charAt(i);\n            if (Character.isDigit(c)) {\n                x = x * 10 + (c - '0');\n            }\n            if (i == n - 1 || !Character.isDigit(c) &amp;&amp; c != ' ') {\n                switch (sign) {\n                    case '+' -&gt; stk.push(x);\n                    case '-' -&gt; stk.push(-x);\n                    case '*' -&gt; stk.push(stk.pop() * x);\n                    case '/' -&gt; stk.push(stk.pop() / x);\n                }\n                x = 0;\n                sign = c;\n            }\n        }\n        int ans = 0;\n        while (!stk.isEmpty()) {\n            ans += stk.pop();\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int calculate(string s) {\n        int n = s.size();\n        int x = 0;\n        char sign = '+';\n        stack&lt;int&gt; stk;\n        for (int i = 0; i &lt; n; ++i) {\n            char c = s[i];\n            if (isdigit(c)) {\n                x = x * 10 + (c - '0');\n            }\n            if (i == n - 1 || !isdigit(c) &amp;&amp; c != ' ') {\n                if (sign == '+') {\n                    stk.push(x);\n                } else if (sign == '-') {\n                    stk.push(-x);\n                } else if (sign == '*') {\n                    int y = stk.top();\n                    stk.pop();\n                    stk.push(y * x);\n                } else if (sign == '/') {\n                    int y = stk.top();\n                    stk.pop();\n                    stk.push(y / x);\n                }\n                x = 0;\n                sign = c;\n            }\n        }\n        int ans = 0;\n        while (!stk.empty()) {\n            ans += stk.top();\n            stk.pop();\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func calculate(s string) (ans int) {\n    n := len(s)\n    x := 0\n    sign := '+'\n    stk := []int{}\n    for i := range s {\n        if s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9' {\n            x = x*10 + int(s[i]-'0')\n        }\n        if i == n-1 || (s[i] != ' ' &amp;&amp; (s[i] &lt; '0' || s[i] &gt; '9')) {\n            switch sign {\n            case '+':\n                stk = append(stk, x)\n            case '-':\n                stk = append(stk, -x)\n            case '*':\n                stk[len(stk)-1] *= x\n            case '/':\n                stk[len(stk)-1] /= x\n            }\n            x = 0\n            sign = rune(s[i])\n        }\n    }\n    for _, x := range stk {\n        ans += x\n    }\n    return\n}\n</code></pre> <pre><code>function calculate(s: string): number {\n    const n = s.length;\n    let x = 0;\n    let sign = '+';\n    const stk: number[] = [];\n    for (let i = 0; i &lt; n; ++i) {\n        if (!isNaN(Number(s[i])) &amp;&amp; s[i] !== ' ') {\n            x = x * 10 + s[i].charCodeAt(0) - '0'.charCodeAt(0);\n        }\n        if (i === n - 1 || (isNaN(Number(s[i])) &amp;&amp; s[i] !== ' ')) {\n            switch (sign) {\n                case '+':\n                    stk.push(x);\n                    break;\n                case '-':\n                    stk.push(-x);\n                    break;\n                case '*':\n                    stk.push(stk.pop()! * x);\n                    break;\n                default:\n                    stk.push((stk.pop()! / x) | 0);\n            }\n            x = 0;\n            sign = s[i];\n        }\n    }\n    return stk.reduce((x, y) =&gt; x + y);\n}\n</code></pre>"},{"location":"lcci/16.3.html","title":"16.03. Intersection","text":""},{"location":"lcci/16.3.html#description","title":"Description","text":"<p>Given two straight line segments (represented as a start point and an end point), compute the point of intersection, if any. If there's no intersection, return an empty array.</p> <p>The absolute error should not exceed 10^-6. If there are more than one intersections, return the one with smallest X axis value. If there are more than one intersections that have same X axis value, return the one with smallest Y axis value.</p> <p>Example 1: </p> <pre>\n\nInput: \n\nline1 = {0, 0}, {1, 0}\n\nline2 = {1, 1}, {0, -1}\n\nOutput:  {0.5, 0}\n\n</pre> <p>Example 2: </p> <pre>\n\nInput: \n\nline1 = {0, 0}, {3, 3}\n\nline2 = {1, 1}, {2, 2}\n\nOutput:  {1, 1}\n\n</pre> <p>Example 3: </p> <pre>\n\nInput: \n\nline1 = {0, 0}, {1, 1}\n\nline2 = {1, 0}, {2, 1}\n\nOutput:  {} (no intersection)\n\n</pre> <p>Note: </p> <ul> <li>The absolute value of coordinate value will not exceed 2^7.</li> <li>All coordinates are valid 2D coordinates.</li> </ul>"},{"location":"lcci/16.3.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.4.html","title":"16.04. Tic-Tac-Toe","text":""},{"location":"lcci/16.4.html#description","title":"Description","text":"<p>Design an algorithm to figure out if someone has won a game of tic-tac-toe.\u00a0Input is a string array\u00a0of size N x N, including characters \" \", \"X\" and \"O\", where \" \" represents a empty grid.</p> <p>The rules of tic-tac-toe are as follows:</p> <ul> <li>Players place characters into an empty grid(\" \") in turn.</li> <li>The first player always place character \"O\", and the second one place \"X\".</li> <li>Players are only allowed to place characters in empty grid. Replacing a character is not allowed.</li> <li>If there is any row, column or diagonal filled with N\u00a0same characters, the game ends. The player who place the last charater wins.</li> <li>When there is no empty grid, the game ends.</li> <li>If the game ends, players cannot place any character further.</li> </ul> <p>If there is any winner, return the character that the winner used. If there's a draw, return \"Draw\". If the game doesn't end and there is no winner, return \"Pending\".</p> <p>Example 1: </p> <pre>\n\nInput:  board = [\"O X\",\" XO\",\"X O\"]\n\nOutput:  \"X\"\n\n</pre> <p>Example 2: </p> <pre>\n\nInput:  board = [\"OOX\",\"XXO\",\"OXO\"]\n\nOutput:  \"Draw\"\n\nExplanation:  no player wins and no empty grid left\n\n</pre> <p>Example 3: </p> <pre>\n\nInput:  board = [\"OOX\",\"XXO\",\"OX \"]\n\nOutput:  \"Pending\"\n\nExplanation:  no player wins but there is still a empty grid\n\n</pre> <p>Note: </p> <ul> <li><code>1 &lt;= board.length == board[i].length &lt;= 100</code></li> <li>Input follows the rules.</li> </ul>"},{"location":"lcci/16.4.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.4.html#solution-1-counting","title":"Solution 1: Counting","text":"<p>For each cell, if it is <code>X</code>, we can add $1$ to the count; if it is <code>O</code>, we can subtract $1$ from the count. When the absolute value of the count of a row, column, or diagonal equals $n$, it means that the current player has placed $n$ identical characters in that row, column, or diagonal, and the game is over. We can return the corresponding character.</p> <p>Specifically, we use a one-dimensional array $rows$ and $cols$ of length $n$ to represent the count of each row and column, and use $dg$ and $udg$ to represent the count of the two diagonals. When a player places a character at $(i, j)$, we update the corresponding elements in the arrays $rows$, $cols$, $dg$, and $udg$ based on whether the character is <code>X</code> or <code>O</code>. After each update, we check whether the absolute value of the corresponding element equals $n$. If it does, it means that the current player has placed $n$ identical characters in that row, column, or diagonal, and the game is over. We can return the corresponding character.</p> <p>Finally, we traverse the entire board. If there is a character <code></code>, it means that the game is not over yet, and we return <code>Pending</code>. Otherwise, we return <code>Draw</code>.</p> <p>The time complexity is $O(n^2)$, and the space complexity is $O(n)$, where $n$ is the side length of the board.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def tictactoe(self, board: List[str]) -&gt; str:\n        n = len(board)\n        rows = [0] * n\n        cols = [0] * n\n        dg = udg = 0\n        has_empty_grid = False\n        for i, row in enumerate(board):\n            for j, c in enumerate(row):\n                v = 1 if c == 'X' else -1\n                if c == ' ':\n                    has_empty_grid = True\n                    v = 0\n                rows[i] += v\n                cols[j] += v\n                if i == j:\n                    dg += v\n                if i + j + 1 == n:\n                    udg += v\n                if (\n                    abs(rows[i]) == n\n                    or abs(cols[j]) == n\n                    or abs(dg) == n\n                    or abs(udg) == n\n                ):\n                    return c\n        return 'Pending' if has_empty_grid else 'Draw'\n</code></pre> <pre><code>class Solution {\n    public String tictactoe(String[] board) {\n        int n = board.length;\n        int[] rows = new int[n];\n        int[] cols = new int[n];\n        int dg = 0, udg = 0;\n        boolean hasEmptyGrid = false;\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                char c = board[i].charAt(j);\n                if (c == ' ') {\n                    hasEmptyGrid = true;\n                    continue;\n                }\n                int v = c == 'X' ? 1 : -1;\n                rows[i] += v;\n                cols[j] += v;\n                if (i == j) {\n                    dg += v;\n                }\n                if (i + j + 1 == n) {\n                    udg += v;\n                }\n                if (Math.abs(rows[i]) == n || Math.abs(cols[j]) == n || Math.abs(dg) == n\n                    || Math.abs(udg) == n) {\n                    return String.valueOf(c);\n                }\n            }\n        }\n        return hasEmptyGrid ? \"Pending\" : \"Draw\";\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    string tictactoe(vector&lt;string&gt;&amp; board) {\n        int n = board.size();\n        vector&lt;int&gt; rows(n), cols(n);\n        int dg = 0, udg = 0;\n        bool hasEmptyGrid = false;\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                char c = board[i][j];\n                if (c == ' ') {\n                    hasEmptyGrid = true;\n                    continue;\n                }\n                int v = c == 'X' ? 1 : -1;\n                rows[i] += v;\n                cols[j] += v;\n                if (i == j) {\n                    dg += v;\n                }\n                if (i + j + 1 == n) {\n                    udg += v;\n                }\n                if (abs(rows[i]) == n || abs(cols[j]) == n || abs(dg) == n || abs(udg) == n) {\n                    return string(1, c);\n                }\n            }\n        }\n        return hasEmptyGrid ? \"Pending\" : \"Draw\";\n    }\n};\n</code></pre> <pre><code>func tictactoe(board []string) string {\n    n := len(board)\n    rows := make([]int, n)\n    cols := make([]int, n)\n    dg, udg := 0, 0\n    hasEmptyGrid := false\n    for i, row := range board {\n        for j, c := range row {\n            if c == ' ' {\n                hasEmptyGrid = true\n                continue\n            }\n            v := 1\n            if c == 'O' {\n                v = -1\n            }\n            rows[i] += v\n            cols[j] += v\n            if i == j {\n                dg += v\n            }\n            if i+j == n-1 {\n                udg += v\n            }\n            if abs(rows[i]) == n || abs(cols[j]) == n || abs(dg) == n || abs(udg) == n {\n                return string(c)\n            }\n        }\n    }\n    if hasEmptyGrid {\n        return \"Pending\"\n    }\n    return \"Draw\"\n}\n\nfunc abs(x int) int {\n    if x &lt; 0 {\n        return -x\n    }\n    return x\n}\n</code></pre> <pre><code>function tictactoe(board: string[]): string {\n    const n = board.length;\n    const rows = Array(n).fill(0);\n    const cols = Array(n).fill(0);\n    let [dg, udg] = [0, 0];\n    let hasEmptyGrid = false;\n    for (let i = 0; i &lt; n; ++i) {\n        for (let j = 0; j &lt; n; ++j) {\n            const c = board[i][j];\n            if (c === ' ') {\n                hasEmptyGrid = true;\n                continue;\n            }\n            const v = c === 'X' ? 1 : -1;\n            rows[i] += v;\n            cols[j] += v;\n            if (i === j) {\n                dg += v;\n            }\n            if (i + j === n - 1) {\n                udg += v;\n            }\n            if (\n                Math.abs(rows[i]) === n ||\n                Math.abs(cols[j]) === n ||\n                Math.abs(dg) === n ||\n                Math.abs(udg) === n\n            ) {\n                return c;\n            }\n        }\n    }\n    return hasEmptyGrid ? 'Pending' : 'Draw';\n}\n</code></pre>"},{"location":"lcci/16.5.html","title":"16.05. Factorial Zeros","text":""},{"location":"lcci/16.5.html#description","title":"Description","text":"<p>Write an algorithm which computes the number of trailing zeros in n factorial.</p> <p>Example 1:</p> <pre>\n\nInput: 3\n\nOutput: 0\n\nExplanation:\u00a03! = 6, no trailing zero.</pre> <p>Example\u00a02:</p> <pre>\n\nInput: 5\n\nOutput: 1\n\nExplanation:\u00a05! = 120, one trailing zero.</pre> <p>Note:\u00a0Your solution should be in logarithmic time complexity.</p>"},{"location":"lcci/16.5.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.5.html#solution-1-mathematics","title":"Solution 1: Mathematics","text":"<p>The problem is actually asking for the number of factors of $5$ in $[1,n]$.</p> <p>Let's take $130$ as an example:</p> <ol> <li>Divide $130$ by $5$ for the first time, and get $26$, which means there are $26$ numbers containing a factor of $5$.</li> <li>Divide $26$ by $5$ for the second time, and get $5$, which means there are $5$ numbers containing a factor of $5^2$.</li> <li>Divide $5$ by $5$ for the third time, and get $1$, which means there is $1$ number containing a factor of $5^3$.</li> <li>Add up all the counts to get the total number of factors of $5$ in $[1,n]$.</li> </ol> <p>The time complexity is $O(\\log n)$, and the space complexity is $O(1)$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def trailingZeroes(self, n: int) -&gt; int:\n        ans = 0\n        while n:\n            n //= 5\n            ans += n\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int trailingZeroes(int n) {\n        int ans = 0;\n        while (n &gt; 0) {\n            n /= 5;\n            ans += n;\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int trailingZeroes(int n) {\n        int ans = 0;\n        while (n) {\n            n /= 5;\n            ans += n;\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func trailingZeroes(n int) int {\n    ans := 0\n    for n &gt; 0 {\n        n /= 5\n        ans += n\n    }\n    return ans\n}\n</code></pre> <pre><code>function trailingZeroes(n: number): number {\n    let ans = 0;\n    while (n &gt; 0) {\n        n = Math.floor(n / 5);\n        ans += n;\n    }\n    return ans;\n}\n</code></pre>"},{"location":"lcci/16.6.html","title":"16.06. Smallest Difference","text":""},{"location":"lcci/16.6.html#description","title":"Description","text":"<p>Given two arrays of integers, compute the pair of values (one value in each array) with the smallest (non-negative) difference. Return the difference.</p> <p>Example: </p> <pre>\n\nInput: {1, 3, 15, 11, 2}, {23, 127, 235, 19, 8}\n\nOutput:  3, the pair (11, 8)\n\n</pre> <p>Note: </p> <ul> <li><code>1 &lt;= a.length, b.length &lt;= 100000</code></li> <li><code>-2147483648 &lt;= a[i], b[i] &lt;= 2147483647</code></li> <li>The result is in the range [-2147483648, 2147483647]</li> </ul>"},{"location":"lcci/16.6.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.6.html#solution-1-sorting-binary-search","title":"Solution 1: Sorting + Binary Search","text":"<p>We can sort the array $b$, and for each element $x$ in array $a$, perform a binary search in array $b$ to find the element $y$ closest to $x$. Then, the absolute difference between $x$ and $y$ is the absolute difference between $x$ and the closest element in $b$.</p> <p>The time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the length of array $b$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def smallestDifference(self, a: List[int], b: List[int]) -&gt; int:\n        b.sort()\n        ans = inf\n        n = len(b)\n        for x in a:\n            j = bisect_left(b, x)\n            if j &lt; n:\n                ans = min(ans, b[j] - x)\n            if j:\n                ans = min(ans, x - b[j - 1])\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int smallestDifference(int[] a, int[] b) {\n        Arrays.sort(b);\n        long ans = Long.MAX_VALUE;\n        for (int x : a) {\n            int j = search(b, x);\n            if (j &lt; b.length) {\n                ans = Math.min(ans, (long) b[j] - x);\n            }\n            if (j &gt; 0) {\n                ans = Math.min(ans, (long) x - b[j - 1]);\n            }\n        }\n        return (int) ans;\n    }\n\n    private int search(int[] nums, int x) {\n        int l = 0, r = nums.length;\n        while (l &lt; r) {\n            int mid = (l + r) &gt;&gt; 1;\n            if (nums[mid] &gt;= x) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int smallestDifference(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) {\n        sort(b.begin(), b.end());\n        long long ans = LONG_LONG_MAX;\n        for (int x : a) {\n            auto it = lower_bound(b.begin(), b.end(), x);\n            if (it != b.end()) {\n                ans = min(ans, (long long) *it - x);\n            }\n            if (it != b.begin()) {\n                ans = min(ans, x - (long long) *prev(it));\n            }\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func smallestDifference(a []int, b []int) int {\n    sort.Ints(b)\n    var ans int = 1e18\n    for _, x := range a {\n        i := sort.SearchInts(b, x)\n        if i &lt; len(b) {\n            ans = min(ans, b[i]-x)\n        }\n        if i &gt; 0 {\n            ans = min(ans, x-b[i-1])\n        }\n    }\n    return ans\n}\n</code></pre> <pre><code>function smallestDifference(a: number[], b: number[]): number {\n    b.sort((a, b) =&gt; a - b);\n    let ans = Infinity;\n    const search = (nums: number[], x: number): number =&gt; {\n        let [l, r] = [0, nums.length];\n        while (l &lt; r) {\n            const mid = (l + r) &gt;&gt; 1;\n            if (nums[mid] &gt;= x) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    };\n    for (const x of a) {\n        const j = search(b, x);\n        if (j &lt; b.length) {\n            ans = Math.min(ans, b[j] - x);\n        }\n        if (j &gt; 0) {\n            ans = Math.min(ans, x - b[j - 1]);\n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"lcci/16.6.html#solution-2-sorting-two-pointers","title":"Solution 2: Sorting + Two Pointers","text":"<p>We can sort both arrays $a$ and $b$, and use two pointers $i$ and $j$ to maintain the current positions in the two arrays. Initially, $i$ and $j$ point to the beginning of arrays $a$ and $b$, respectively. At each step, we calculate the absolute difference between $a[i]$ and $b[j]$, and update the answer. If one of the elements pointed to by $i$ and $j$ is smaller than the other, we move the pointer pointing to the smaller element forward by one step. The traversal ends when at least one of the pointers goes beyond the array range.</p> <p>The time complexity is $O(n \\times \\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the length of arrays $a$ and $b$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def smallestDifference(self, a: List[int], b: List[int]) -&gt; int:\n        a.sort()\n        b.sort()\n        i = j = 0\n        ans = inf\n        while i &lt; len(a) and j &lt; len(b):\n            ans = min(ans, abs(a[i] - b[j]))\n            if a[i] &lt; b[j]:\n                i += 1\n            else:\n                j += 1\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int smallestDifference(int[] a, int[] b) {\n        Arrays.sort(a);\n        Arrays.sort(b);\n        int i = 0, j = 0;\n        long ans = Long.MAX_VALUE;\n        while (i &lt; a.length &amp;&amp; j &lt; b.length) {\n            ans = Math.min(ans, Math.abs((long) a[i] - (long) b[j]));\n            if (a[i] &lt; b[j]) {\n                ++i;\n            } else {\n                ++j;\n            }\n        }\n        return (int) ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int smallestDifference(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) {\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n        int i = 0, j = 0;\n        long long ans = LONG_LONG_MAX;\n        while (i &lt; a.size() &amp;&amp; j &lt; b.size()) {\n            ans = min(ans, abs(1LL * a[i] - 1LL * b[j]));\n            if (a[i] &lt; b[j]) {\n                ++i;\n            } else {\n                ++j;\n            }\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func smallestDifference(a []int, b []int) int {\n    sort.Ints(a)\n    sort.Ints(b)\n    i, j := 0, 0\n    var ans int = 1e18\n    for i &lt; len(a) &amp;&amp; j &lt; len(b) {\n        ans = min(ans, abs(a[i]-b[j]))\n        if a[i] &lt; b[j] {\n            i++\n        } else {\n            j++\n        }\n    }\n    return ans\n}\n\nfunc abs(a int) int {\n    if a &lt; 0 {\n        return -a\n    }\n    return a\n}\n</code></pre> <pre><code>function smallestDifference(a: number[], b: number[]): number {\n    a.sort((a, b) =&gt; a - b);\n    b.sort((a, b) =&gt; a - b);\n    let [i, j] = [0, 0];\n    let ans = Infinity;\n    while (i &lt; a.length &amp;&amp; j &lt; b.length) {\n        ans = Math.min(ans, Math.abs(a[i] - b[j]));\n        if (a[i] &lt; b[j]) {\n            ++i;\n        } else {\n            ++j;\n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"lcci/16.7.html","title":"16.07. Maximum","text":""},{"location":"lcci/16.7.html#description","title":"Description","text":"<p>Write a method that finds the maximum of two numbers. You should not use if-else or any other comparison operator.</p> <p>Example: </p> <pre>\n\nInput:  a = 1, b = 2\n\nOutput:  2\n\n</pre>"},{"location":"lcci/16.7.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.7.html#solution-1-bitwise-operation","title":"Solution 1: Bitwise Operation","text":"<p>We can extract the sign bit $k$ of $a-b$. If the sign bit is $1$, it means $a \\lt b$; if the sign bit is $0$, it means $a \\ge b$.</p> <p>Then the final result is $a \\times (k \\oplus 1) + b \\times k$.</p> <p>The time complexity is $O(1)$, and the space complexity is $O(1)$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def maximum(self, a: int, b: int) -&gt; int:\n        k = (int(((a - b) &amp; 0xFFFFFFFFFFFFFFFF) &gt;&gt; 63)) &amp; 1\n        return a * (k ^ 1) + b * k\n</code></pre> <pre><code>class Solution {\n    public int maximum(int a, int b) {\n        int k = (int) (((long) a - (long) b) &gt;&gt; 63) &amp; 1;\n        return a * (k ^ 1) + b * k;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int maximum(int a, int b) {\n        int k = ((static_cast&lt;long long&gt;(a) - static_cast&lt;long long&gt;(b)) &gt;&gt; 63) &amp; 1;\n        return a * (k ^ 1) + b * k;\n    }\n};\n</code></pre> <pre><code>func maximum(a int, b int) int {\n    k := (a - b) &gt;&gt; 63 &amp; 1\n    return a*(k^1) + b*k\n}\n</code></pre> <pre><code>function maximum(a: number, b: number): number {\n    const k: number = Number(((BigInt(a) - BigInt(b)) &gt;&gt; BigInt(63)) &amp; BigInt(1));\n    return a * (k ^ 1) + b * k;\n}\n</code></pre>"},{"location":"lcci/16.8.html","title":"16.08. English Int","text":""},{"location":"lcci/16.8.html#description","title":"Description","text":"<p>Given any integer, print an English phrase that describes the integer (e.g., \"One Thousand Two Hundred Thirty Four\").</p> <p>Example 1:</p> <pre>\n\nInput: 123\n\nOutput: \"One Hundred Twenty Three\"\n\n</pre> <p>Example 2:</p> <pre>\n\nInput: 12345\n\nOutput: \"Twelve Thousand Three Hundred Forty Five\"</pre> <p>Example 3:</p> <pre>\n\nInput: 1234567\n\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"</pre> <p>Example 4:</p> <pre>\n\nInput: 1234567891\n\nOutput: \"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One\"</pre>"},{"location":"lcci/16.8.html#solutions","title":"Solutions","text":""},{"location":"lcci/16.9.html","title":"16.09. Operations","text":""},{"location":"lcci/16.9.html#description","title":"Description","text":"<p>rite methods to implement the multiply, subtract, and divide operations for integers. The results of all of these are integers. Use only the add operator.</p> <p>You should implement following methods:</p> <ul> <li><code>Operations()</code>\u00a0 constructor</li> <li><code>minus(a, b)</code>\u00a0 Subtraction, returns\u00a0<code>a - b</code></li> <li><code>multiply(a, b)</code>\u00a0 Multiplication, returns\u00a0<code>a * b</code></li> <li><code>divide(a, b)</code>\u00a0 Division, returns\u00a0<code>a / b</code></li> </ul> <p>Example: </p> <pre>\n\nOperations operations = new Operations();\n\noperations.minus(1, 2); //returns -1\n\noperations.multiply(3, 4); //returns 12\n\noperations.divide(5, -2); //returns -2\n\n</pre> <p>Note: </p> <ul> <li>You can assume inputs are always valid, that is, e.g., denominator will not be 0 in division.</li> <li>The number of calls will not exceed 1000.</li> </ul>"},{"location":"lcci/16.9.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.1.html","title":"17.01. Add Without Plus","text":""},{"location":"lcci/17.1.html#description","title":"Description","text":"<p>Write a function that adds two numbers. You should not use + or any arithmetic operators.</p> <p>Example:</p> <pre>\n\nInput: a = 1, b = 1\n\nOutput: 2</pre> <p> </p> <p>Note: </p> <ul> <li><code>a</code>\u00a0and\u00a0<code>b</code>\u00a0may be 0 or negative.</li> <li>The result fits in 32-bit integer.</li> </ul>"},{"location":"lcci/17.1.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.1.html#solution-1","title":"Solution 1","text":"Java <pre><code>class Solution {\n    public int add(int a, int b) {\n        int sum = 0, carry = 0;\n        while (b != 0) {\n            sum = a ^ b;\n            carry = (a &amp; b) &lt;&lt; 1;\n            a = sum;\n            b = carry;\n        }\n        return a;\n    }\n}\n</code></pre>"},{"location":"lcci/17.10.html","title":"17.10. Find Majority Element","text":""},{"location":"lcci/17.10.html#description","title":"Description","text":"<p>A majority element is an element that makes up more than half of the items in an array. Given a positive integers array, find the majority element. If there is no majority element, return -1. Do this in O(N) time and O(1) space.</p> <p>Example 1: </p> <pre>\n\nInput: [1,2,5,9,5,9,5,5,5]\n\nOutput: 5</pre> <p> </p> <p>Example 2: </p> <pre>\n\nInput: [3,2]\n\nOutput: -1</pre> <p> </p> <p>Example 3: </p> <pre>\n\nInput: [2,2,1,1,1,2,2]\n\nOutput: 2\n\n</pre>"},{"location":"lcci/17.10.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.10.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoJavaScriptC# <pre><code>class Solution:\n    def majorityElement(self, nums: List[int]) -&gt; int:\n        cnt = m = 0\n        for v in nums:\n            if cnt == 0:\n                m, cnt = v, 1\n            else:\n                cnt += 1 if m == v else -1\n        return m if nums.count(m) &gt; len(nums) // 2 else -1\n</code></pre> <pre><code>class Solution {\n    public int majorityElement(int[] nums) {\n        int cnt = 0, m = 0;\n        for (int v : nums) {\n            if (cnt == 0) {\n                m = v;\n                cnt = 1;\n            } else {\n                cnt += (m == v ? 1 : -1);\n            }\n        }\n        cnt = 0;\n        for (int v : nums) {\n            if (m == v) {\n                ++cnt;\n            }\n        }\n        return cnt &gt; nums.length / 2 ? m : -1;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) {\n        int cnt = 0, m = 0;\n        for (int&amp; v : nums) {\n            if (cnt == 0) {\n                m = v;\n                cnt = 1;\n            } else\n                cnt += (m == v ? 1 : -1);\n        }\n        cnt = count(nums.begin(), nums.end(), m);\n        return cnt &gt; nums.size() / 2 ? m : -1;\n    }\n};\n</code></pre> <pre><code>func majorityElement(nums []int) int {\n    cnt, m := 0, 0\n    for _, v := range nums {\n        if cnt == 0 {\n            m, cnt = v, 1\n        } else {\n            if m == v {\n                cnt++\n            } else {\n                cnt--\n            }\n        }\n    }\n    cnt = 0\n    for _, v := range nums {\n        if m == v {\n            cnt++\n        }\n    }\n    if cnt &gt; len(nums)/2 {\n        return m\n    }\n    return -1\n}\n</code></pre> <pre><code>/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function (nums) {\n    let cnt = 0,\n        m = 0;\n    for (const v of nums) {\n        if (cnt == 0) {\n            m = v;\n            cnt = 1;\n        } else {\n            cnt += m == v ? 1 : -1;\n        }\n    }\n    cnt = 0;\n    for (const v of nums) {\n        if (m == v) {\n            ++cnt;\n        }\n    }\n    return cnt &gt; nums.length / 2 ? m : -1;\n};\n</code></pre> <pre><code>public class Solution {\n    public int MajorityElement(int[] nums) {\n        int cnt = 0, m = 0;\n        foreach (int v in nums)\n        {\n            if (cnt == 0)\n            {\n                m = v;\n                cnt = 1;\n            }\n            else\n            {\n                cnt += m == v ? 1 : -1;\n            }\n        }\n        cnt = 0;\n        foreach (int v in nums)\n        {\n            if (m == v)\n            {\n                ++cnt;\n            }\n        }\n        return cnt &gt; nums.Length / 2 ? m : -1;\n    }\n}\n</code></pre>"},{"location":"lcci/17.11.html","title":"17.11. Find Closest","text":""},{"location":"lcci/17.11.html#description","title":"Description","text":"<p>You have a large text file containing words. Given any two words, find the shortest distance (in terms of number of words) between them in the file. If the operation will be repeated many times for the same file (but different pairs of words), can you optimize your solution?</p> <p>Example: </p> <pre>\n\nInput: words = [\"I\",\"am\",\"a\",\"student\",\"from\",\"a\",\"university\",\"in\",\"a\",\"city\"], word1 = \"a\", word2 = \"student\"\n\nOutput: 1</pre> <p>Note:</p> <ul> <li><code>words.length &lt;= 100000</code></li> </ul>"},{"location":"lcci/17.11.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.11.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRust <pre><code>class Solution:\n    def findClosest(self, words: List[str], word1: str, word2: str) -&gt; int:\n        i, j, ans = 1e5, -1e5, 1e5\n        for k, word in enumerate(words):\n            if word == word1:\n                i = k\n            elif word == word2:\n                j = k\n            ans = min(ans, abs(i - j))\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int findClosest(String[] words, String word1, String word2) {\n        int i = 100000, j = -100000, ans = 100000;\n        for (int k = 0; k &lt; words.length; ++k) {\n            String word = words[k];\n            if (word.equals(word1)) {\n                i = k;\n            } else if (word.equals(word2)) {\n                j = k;\n            }\n            ans = Math.min(ans, Math.abs(i - j));\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int findClosest(vector&lt;string&gt;&amp; words, string word1, string word2) {\n        int i = 1e5, j = -1e5, ans = 1e5;\n        for (int k = 0; k &lt; words.size(); ++k) {\n            string word = words[k];\n            if (word == word1)\n                i = k;\n            else if (word == word2)\n                j = k;\n            ans = min(ans, abs(i - j));\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func findClosest(words []string, word1 string, word2 string) int {\n    i, j, ans := 100000, -100000, 100000\n    for k, word := range words {\n        if word == word1 {\n            i = k\n        } else if word == word2 {\n            j = k\n        }\n        ans = min(ans, abs(i-j))\n    }\n    return ans\n}\n\nfunc abs(x int) int {\n    if x &lt; 0 {\n        return -x\n    }\n    return x\n}\n</code></pre> <pre><code>function findClosest(words: string[], word1: string, word2: string): number {\n    let index1 = 100000;\n    let index2 = -100000;\n    let res = 100000;\n    const n = words.length;\n    for (let i = 0; i &lt; n; i++) {\n        const word = words[i];\n        if (word === word1) {\n            index1 = i;\n        } else if (word === word2) {\n            index2 = i;\n        }\n        res = Math.min(res, Math.abs(index1 - index2));\n    }\n    return res;\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn find_closest(words: Vec&lt;String&gt;, word1: String, word2: String) -&gt; i32 {\n        let mut res = i32::MAX;\n        let mut index1 = -1;\n        let mut index2 = -1;\n        for (i, word) in words.iter().enumerate() {\n            let i = i as i32;\n            if word.eq(&amp;word1) {\n                index1 = i;\n            } else if word.eq(&amp;word2) {\n                index2 = i;\n            }\n            if index1 != -1 &amp;&amp; index2 != -1 {\n                res = res.min((index1 - index2).abs());\n            }\n        }\n        res\n    }\n}\n</code></pre>"},{"location":"lcci/17.11.html#solution-2","title":"Solution 2","text":"Python3JavaC++Go <pre><code>class Solution:\n    def findClosest(self, words: List[str], word1: str, word2: str) -&gt; int:\n        d = defaultdict(list)\n        for i, w in enumerate(words):\n            d[w].append(i)\n        ans = 1e5\n        idx1, idx2 = d[word1], d[word2]\n        i, j, m, n = 0, 0, len(idx1), len(idx2)\n        while i &lt; m and j &lt; n:\n            ans = min(ans, abs(idx1[i] - idx2[j]))\n            if idx1[i] &lt; idx2[j]:\n                i += 1\n            else:\n                j += 1\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int findClosest(String[] words, String word1, String word2) {\n        Map&lt;String, List&lt;Integer&gt;&gt; d = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; words.length; ++i) {\n            d.computeIfAbsent(words[i], k -&gt; new ArrayList&lt;&gt;()).add(i);\n        }\n        List&lt;Integer&gt; idx1 = d.get(word1), idx2 = d.get(word2);\n        int i = 0, j = 0, m = idx1.size(), n = idx2.size();\n        int ans = 100000;\n        while (i &lt; m &amp;&amp; j &lt; n) {\n            int t = Math.abs(idx1.get(i) - idx2.get(j));\n            ans = Math.min(ans, t);\n            if (idx1.get(i) &lt; idx2.get(j)) {\n                ++i;\n            } else {\n                ++j;\n            }\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int findClosest(vector&lt;string&gt;&amp; words, string word1, string word2) {\n        unordered_map&lt;string, vector&lt;int&gt;&gt; d;\n        for (int i = 0; i &lt; words.size(); ++i) d[words[i]].push_back(i);\n        vector&lt;int&gt; idx1 = d[word1], idx2 = d[word2];\n        int i = 0, j = 0, m = idx1.size(), n = idx2.size();\n        int ans = 1e5;\n        while (i &lt; m &amp;&amp; j &lt; n) {\n            int t = abs(idx1[i] - idx2[j]);\n            ans = min(ans, t);\n            if (idx1[i] &lt; idx2[j])\n                ++i;\n            else\n                ++j;\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func findClosest(words []string, word1 string, word2 string) int {\n    d := map[string][]int{}\n    for i, w := range words {\n        d[w] = append(d[w], i)\n    }\n    idx1, idx2 := d[word1], d[word2]\n    i, j, m, n := 0, 0, len(idx1), len(idx2)\n    ans := 100000\n    for i &lt; m &amp;&amp; j &lt; n {\n        t := abs(idx1[i] - idx2[j])\n        if t &lt; ans {\n            ans = t\n        }\n        if idx1[i] &lt; idx2[j] {\n            i++\n        } else {\n            j++\n        }\n    }\n    return ans\n}\n\nfunc abs(x int) int {\n    if x &lt; 0 {\n        return -x\n    }\n    return x\n}\n</code></pre>"},{"location":"lcci/17.12.html","title":"17.12. BiNode","text":""},{"location":"lcci/17.12.html#description","title":"Description","text":"<p>The data structure\u00a0<code>TreeNode</code>\u00a0is used for binary tree, but it can also used to represent a single linked list (where left is null, and right is the next node in the list). Implement a method to convert a binary search tree (implemented with <code>TreeNode</code>) into a single\u00a0linked list. The values should be kept in order and the operation should be performed in place (that is, on the original data structure).</p> <p>Return the head node of the linked list after converting.</p> <p>Note:\u00a0This problem is slightly different from the original one in the book.</p> <p> </p> <p>Example: </p> <pre>\n\nInput:  [4,2,5,1,3,null,6,0]\n\nOutput:  [0,null,1,null,2,null,3,null,4,null,5,null,6]\n\n</pre> <p>Note: </p> <ul> <li>The number of nodes will not exceed\u00a0100000.</li> </ul>"},{"location":"lcci/17.12.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.12.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def convertBiNode(self, root: TreeNode) -&gt; TreeNode:\n        def dfs(root):\n            if root is None:\n                return\n            nonlocal prev\n            dfs(root.left)\n            prev.right = root\n            root.left = None\n            prev = root\n            dfs(root.right)\n\n        dummy = TreeNode(val=0, right=root)\n        prev = dummy\n        dfs(root)\n        return dummy.right\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private TreeNode prev;\n\n    public TreeNode convertBiNode(TreeNode root) {\n        TreeNode dummy = new TreeNode(0, null, root);\n        prev = dummy;\n        dfs(root);\n        return dummy.right;\n    }\n\n    private void dfs(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        dfs(root.left);\n        prev.right = root;\n        root.left = null;\n        prev = root;\n        dfs(root.right);\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* prev;\n\n    TreeNode* convertBiNode(TreeNode* root) {\n        TreeNode* dummy = new TreeNode(0, nullptr, root);\n        prev = dummy;\n        dfs(root);\n        return dummy-&gt;right;\n    }\n\n    void dfs(TreeNode* root) {\n        if (!root) return;\n        dfs(root-&gt;left);\n        prev-&gt;right = root;\n        root-&gt;left = nullptr;\n        prev = root;\n        dfs(root-&gt;right);\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc convertBiNode(root *TreeNode) *TreeNode {\n    dummy := &amp;TreeNode{Val: 0, Right: root}\n    prev := dummy\n    var dfs func(root *TreeNode)\n    dfs = func(root *TreeNode) {\n        if root == nil {\n            return\n        }\n        dfs(root.Left)\n        prev.Right = root\n        root.Left = nil\n        prev = root\n        dfs(root.Right)\n    }\n    dfs(root)\n    return dummy.Right\n}\n</code></pre>"},{"location":"lcci/17.13.html","title":"17.13. Re-Space","text":""},{"location":"lcci/17.13.html#description","title":"Description","text":"<p>Oh, no! You have accidentally removed all spaces, punctuation, and capitalization in a lengthy document. A sentence like \"I reset the computer. It still didn't boot!\" became \"iresetthecomputeritstilldidntboot''. You'll deal with the punctuation and capi\u00adtalization later; right now you need to re-insert the spaces. Most of the words are in a dictionary but a few are not. Given a dictionary (a list of strings) and the document (a string), design an algorithm to unconcatenate the document in a way that minimizes the number of unrecognized characters. Return the number of unrecognized characters.</p> <p>Note: This\u00a0problem is slightly different from the original one in the book.</p> <p> </p> <p>Example: </p> <pre>\n\nInput: \n\ndictionary = [\"looked\",\"just\",\"like\",\"her\",\"brother\"]\n\nsentence = \"jesslookedjustliketimherbrother\"\n\nOutput:  7\n\nExplanation:  After unconcatenating, we got \"jess looked just like tim her brother\", which containing 7 unrecognized characters.\n\n</pre> <p>Note: </p> <ul> <li><code>0 &lt;= len(sentence) &lt;= 1000</code></li> <li><code>The total number of characters in\u00a0dictionary</code>\u00a0is less than or equal to 150000.</li> <li>There are only lowercase letters in\u00a0<code>dictionary</code>\u00a0and\u00a0<code>sentence</code>.</li> </ul>"},{"location":"lcci/17.13.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.13.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Solution:\n    def respace(self, dictionary: List[str], sentence: str) -&gt; int:\n        s = set(dictionary)\n        n = len(sentence)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + 1\n            for j in range(i):\n                if sentence[j:i] in s:\n                    dp[i] = min(dp[i], dp[j])\n        return dp[-1]\n</code></pre> <pre><code>class Solution {\n    public int respace(String[] dictionary, String sentence) {\n        Set&lt;String&gt; dict = new HashSet&lt;&gt;(Arrays.asList(dictionary));\n        int n = sentence.length();\n        int[] dp = new int[n + 1];\n        for (int i = 1; i &lt;= n; i++) {\n            dp[i] = dp[i - 1] + 1;\n            for (int j = 0; j &lt; i; ++j) {\n                if (dict.contains(sentence.substring(j, i))) {\n                    dp[i] = Math.min(dp[i], dp[j]);\n                }\n            }\n        }\n        return dp[n];\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int respace(vector&lt;string&gt;&amp; dictionary, string sentence) {\n        unordered_set&lt;string&gt; s(dictionary.begin(), dictionary.end());\n        int n = sentence.size();\n        vector&lt;int&gt; dp(n + 1);\n        for (int i = 1; i &lt;= n; ++i) {\n            dp[i] = dp[i - 1] + 1;\n            for (int j = 0; j &lt; i; ++j) {\n                if (s.count(sentence.substr(j, i - j))) {\n                    dp[i] = min(dp[i], dp[j]);\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n</code></pre> <pre><code>func respace(dictionary []string, sentence string) int {\n    s := map[string]bool{}\n    for _, v := range dictionary {\n        s[v] = true\n    }\n    n := len(sentence)\n    dp := make([]int, n+1)\n    for i := 1; i &lt;= n; i++ {\n        dp[i] = dp[i-1] + 1\n        for j := 0; j &lt; i; j++ {\n            if s[sentence[j:i]] {\n                dp[i] = min(dp[i], dp[j])\n            }\n        }\n    }\n    return dp[n]\n}\n</code></pre>"},{"location":"lcci/17.14.html","title":"17.14. Smallest K","text":""},{"location":"lcci/17.14.html#description","title":"Description","text":"<p>Design an algorithm to find the smallest K numbers in an array.</p> <p>Example: </p> <pre>\n\nInput:  arr = [1,3,5,7,2,4,6,8], k = 4\n\nOutput:  [1,2,3,4]\n\n</pre> <p>Note: </p> <ul> <li><code>0 &lt;= len(arr) &lt;= 100000</code></li> <li><code>0 &lt;= k &lt;= min(100000, len(arr))</code></li> </ul>"},{"location":"lcci/17.14.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.14.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Solution:\n    def smallestK(self, arr: List[int], k: int) -&gt; List[int]:\n        return sorted(arr)[:k]\n</code></pre> <pre><code>class Solution {\n    public int[] smallestK(int[] arr, int k) {\n        Arrays.sort(arr);\n        int[] ans = new int[k];\n        for (int i = 0; i &lt; k; ++i) {\n            ans[i] = arr[i];\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; smallestK(vector&lt;int&gt;&amp; arr, int k) {\n        sort(arr.begin(), arr.end());\n        vector&lt;int&gt; ans(k);\n        for (int i = 0; i &lt; k; ++i) {\n            ans[i] = arr[i];\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func smallestK(arr []int, k int) []int {\n    sort.Ints(arr)\n    ans := make([]int, k)\n    for i, v := range arr[:k] {\n        ans[i] = v\n    }\n    return ans\n}\n</code></pre>"},{"location":"lcci/17.14.html#solution-2","title":"Solution 2","text":"Python3JavaC++Go <pre><code>class Solution:\n    def smallestK(self, arr: List[int], k: int) -&gt; List[int]:\n        h = []\n        for v in arr:\n            heappush(h, -v)\n            if len(h) &gt; k:\n                heappop(h)\n        return [-v for v in h]\n</code></pre> <pre><code>class Solution {\n    public int[] smallestK(int[] arr, int k) {\n        PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);\n        for (int v : arr) {\n            q.offer(v);\n            if (q.size() &gt; k) {\n                q.poll();\n            }\n        }\n        int[] ans = new int[k];\n        int i = 0;\n        while (!q.isEmpty()) {\n            ans[i++] = q.poll();\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; smallestK(vector&lt;int&gt;&amp; arr, int k) {\n        priority_queue&lt;int&gt; q;\n        for (int&amp; v : arr) {\n            q.push(v);\n            if (q.size() &gt; k) {\n                q.pop();\n            }\n        }\n        vector&lt;int&gt; ans;\n        while (q.size()) {\n            ans.push_back(q.top());\n            q.pop();\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func smallestK(arr []int, k int) []int {\n    q := hp{}\n    for _, v := range arr {\n        heap.Push(&amp;q, v)\n        if q.Len() &gt; k {\n            heap.Pop(&amp;q)\n        }\n    }\n    ans := make([]int, k)\n    for i := range ans {\n        ans[i] = heap.Pop(&amp;q).(int)\n    }\n    return ans\n}\n\ntype hp struct{ sort.IntSlice }\n\nfunc (h hp) Less(i, j int) bool { return h.IntSlice[i] &gt; h.IntSlice[j] }\nfunc (h *hp) Push(v any)        { h.IntSlice = append(h.IntSlice, v.(int)) }\nfunc (h *hp) Pop() any {\n    a := h.IntSlice\n    v := a[len(a)-1]\n    h.IntSlice = a[:len(a)-1]\n    return v\n}\n</code></pre>"},{"location":"lcci/17.15.html","title":"17.15. Longest Word","text":""},{"location":"lcci/17.15.html#description","title":"Description","text":"<p>Given a list of words, write a program to find the longest word made of other words in the list. If there are more than one answer, return the one that has smallest lexicographic order. If no answer, return an empty string.</p> <p>Example: </p> <pre>\n\nInput:  [\"cat\",\"banana\",\"dog\",\"nana\",\"walk\",\"walker\",\"dogwalker\"]\n\nOutput:  \"dogwalker\"\n\nExplanation:  \"dogwalker\" can be made of \"dog\" and \"walker\".\n\n</pre> <p>Note: </p> <ul> <li><code>0 &lt;= len(words) &lt;= 100</code></li> <li><code>1 &lt;= len(words[i]) &lt;= 100</code></li> </ul>"},{"location":"lcci/17.15.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.15.html#solution-1","title":"Solution 1","text":"Python3JavaGo <pre><code>class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, word):\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n    def search(self, word):\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                return False\n            node = node.children[idx]\n        return node.is_end\n\n\nclass Solution:\n    def longestWord(self, words: List[str]) -&gt; str:\n        def cmp(a, b):\n            if len(a) != len(b):\n                return len(a) - len(b)\n            return -1 if a &gt; b else 1\n\n        def dfs(w):\n            return not w or any(\n                trie.search(w[:i]) and dfs(w[i:]) for i in range(1, len(w) + 1)\n            )\n\n        words.sort(key=cmp_to_key(cmp))\n        trie = Trie()\n        ans = \"\"\n        for w in words:\n            if dfs(w):\n                ans = w\n            trie.insert(w)\n        return ans\n</code></pre> <pre><code>class Trie {\n    Trie[] children = new Trie[26];\n    boolean isEnd;\n\n    void insert(String word) {\n        Trie node = this;\n        for (char c : word.toCharArray()) {\n            c -= 'a';\n            if (node.children[c] == null) {\n                node.children[c] = new Trie();\n            }\n            node = node.children[c];\n        }\n        node.isEnd = true;\n    }\n\n    boolean search(String word) {\n        Trie node = this;\n        for (char c : word.toCharArray()) {\n            c -= 'a';\n            if (node.children[c] == null) {\n                return false;\n            }\n            node = node.children[c];\n        }\n        return node.isEnd;\n    }\n}\n\nclass Solution {\n    private Trie trie = new Trie();\n\n    public String longestWord(String[] words) {\n        Arrays.sort(words, (a, b) -&gt; {\n            if (a.length() != b.length()) {\n                return a.length() - b.length();\n            }\n            return b.compareTo(a);\n        });\n        String ans = \"\";\n        for (String w : words) {\n            if (dfs(w)) {\n                ans = w;\n            }\n            trie.insert(w);\n        }\n        return ans;\n    }\n\n    private boolean dfs(String w) {\n        if (\"\".equals(w)) {\n            return true;\n        }\n        for (int i = 1; i &lt;= w.length(); ++i) {\n            if (trie.search(w.substring(0, i)) &amp;&amp; dfs(w.substring(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <pre><code>type Trie struct {\n    children [26]*Trie\n    isEnd    bool\n}\n\nfunc newTrie() *Trie {\n    return &amp;Trie{}\n}\nfunc (this *Trie) insert(word string) {\n    node := this\n    for _, c := range word {\n        c -= 'a'\n        if node.children[c] == nil {\n            node.children[c] = newTrie()\n        }\n        node = node.children[c]\n    }\n    node.isEnd = true\n}\n\nfunc (this *Trie) search(word string) bool {\n    node := this\n    for _, c := range word {\n        c -= 'a'\n        if node.children[c] == nil {\n            return false\n        }\n        node = node.children[c]\n    }\n    return node.isEnd\n}\n\nfunc longestWord(words []string) string {\n    sort.Slice(words, func(i, j int) bool {\n        a, b := words[i], words[j]\n        if len(a) != len(b) {\n            return len(a) &lt; len(b)\n        }\n        return a &gt; b\n    })\n    trie := newTrie()\n    var dfs func(string) bool\n    dfs = func(w string) bool {\n        if len(w) == 0 {\n            return true\n        }\n        for i := 1; i &lt;= len(w); i++ {\n            if trie.search(w[:i]) &amp;&amp; dfs(w[i:]) {\n                return true\n            }\n        }\n        return false\n    }\n    ans := \"\"\n    for _, w := range words {\n        if dfs(w) {\n            ans = w\n        }\n        trie.insert(w)\n    }\n    return ans\n}\n</code></pre>"},{"location":"lcci/17.16.html","title":"17.16. The Masseuse","text":""},{"location":"lcci/17.16.html#description","title":"Description","text":"<p>A popular masseuse receives a sequence of back-to-back appointment requests and is debating which ones to accept. She needs a break between appointments and therefore she cannot accept any adjacent requests. Given a sequence of back-to-back appoint\u00ad ment requests, find the optimal (highest total booked minutes) set the masseuse can honor. Return the number of minutes.</p> <p>Note:\u00a0This problem is slightly different from the original one in the book.</p> <p> </p> <p>Example 1: </p> <pre>\n\nInput:  [1,2,3,1]\n\nOutput:  4\n\nExplanation:  Accept request 1 and 3, total minutes = 1 + 3 = 4\n\n</pre> <p>Example 2: </p> <pre>\n\nInput:  [2,7,9,3,1]\n\nOutput:  12\n\nExplanation:  Accept request 1, 3 and 5, total minutes = 2 + 9 + 1 = 12\n\n</pre> <p>Example 3: </p> <pre>\n\nInput:  [2,1,4,5,3,1,1,3]\n\nOutput:  12\n\nExplanation:  Accept request 1, 3, 5 and 8, total minutes = 2 + 4 + 3 + 3 = 12\n\n</pre>"},{"location":"lcci/17.16.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.16.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def massage(self, nums: List[int]) -&gt; int:\n        f = g = 0\n        for x in nums:\n            f, g = g + x, max(f, g)\n        return max(f, g)\n</code></pre> <pre><code>class Solution {\n    public int massage(int[] nums) {\n        int f = 0, g = 0;\n        for (int x : nums) {\n            int ff = g + x;\n            int gg = Math.max(f, g);\n            f = ff;\n            g = gg;\n        }\n        return Math.max(f, g);\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int massage(vector&lt;int&gt;&amp; nums) {\n        int f = 0, g = 0;\n        for (int&amp; x : nums) {\n            int ff = g + x;\n            int gg = max(f, g);\n            f = ff;\n            g = gg;\n        }\n        return max(f, g);\n    }\n};\n</code></pre> <pre><code>func massage(nums []int) int {\n    f, g := 0, 0\n    for _, x := range nums {\n        f, g = g+x, max(f, g)\n    }\n    return max(f, g)\n}\n</code></pre> <pre><code>function massage(nums: number[]): number {\n    let f = 0,\n        g = 0;\n    for (const x of nums) {\n        const ff = g + x;\n        const gg = Math.max(f, g);\n        f = ff;\n        g = gg;\n    }\n    return Math.max(f, g);\n}\n</code></pre>"},{"location":"lcci/17.17.html","title":"17.17. Multi Search","text":""},{"location":"lcci/17.17.html#description","title":"Description","text":"<p>Given a string band an array of smaller strings T, design a method to search b for each small string in T. Output\u00a0<code>positions</code> of all strings in\u00a0<code>smalls</code>\u00a0that appear in <code>big</code>,\u00a0where <code>positions[i]</code> is all positions of <code>smalls[i]</code>.</p> <p>Example: </p> <pre>\n\nInput: \n\nbig = \"mississippi\"\n\nsmalls = [\"is\",\"ppi\",\"hi\",\"sis\",\"i\",\"ssippi\"]\n\nOutput:  [[1,4],[8],[],[3],[1,4,7,10],[5]]\n\n</pre> <p>Note: </p> <ul> <li><code>0 &lt;= len(big) &lt;= 1000</code></li> <li><code>0 &lt;= len(smalls[i]) &lt;= 1000</code></li> <li>The total number of characters in\u00a0<code>smalls</code>\u00a0will not exceed 100000.</li> <li>No duplicated strings in\u00a0<code>smalls</code>.</li> <li>All characters are lowercase letters.</li> </ul>"},{"location":"lcci/17.17.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.17.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Trie:\n    def __init__(self):\n        self.idx = -1\n        self.children = [None] * 26\n\n    def insert(self, word, i):\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.idx = i\n\n    def search(self, word):\n        res = []\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                return res\n            node = node.children[idx]\n            if node.idx != -1:\n                res.append(node.idx)\n        return res\n\n\nclass Solution:\n    def multiSearch(self, big: str, smalls: List[str]) -&gt; List[List[int]]:\n        tree = Trie()\n        for i, s in enumerate(smalls):\n            tree.insert(s, i)\n        n = len(smalls)\n        ans = [[] for _ in range(n)]\n        for i in range(len(big)):\n            s = big[i:]\n            for idx in tree.search(s):\n                ans[idx].append(i)\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int[][] multiSearch(String big, String[] smalls) {\n        Trie tree = new Trie();\n        int n = smalls.length;\n        for (int i = 0; i &lt; n; ++i) {\n            tree.insert(smalls[i], i);\n        }\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; n; ++i) {\n            res.add(new ArrayList&lt;&gt;());\n        }\n        for (int i = 0; i &lt; big.length(); ++i) {\n            String s = big.substring(i);\n            List&lt;Integer&gt; t = tree.search(s);\n            for (int idx : t) {\n                res.get(idx).add(i);\n            }\n        }\n        int[][] ans = new int[n][];\n        for (int i = 0; i &lt; n; ++i) {\n            ans[i] = res.get(i).stream().mapToInt(Integer::intValue).toArray();\n        }\n        return ans;\n    }\n}\n\nclass Trie {\n    private int idx;\n    private Trie[] children;\n\n    public Trie() {\n        idx = -1;\n        children = new Trie[26];\n    }\n\n    public void insert(String word, int i) {\n        Trie node = this;\n        for (char c : word.toCharArray()) {\n            c -= 'a';\n            if (node.children[c] == null) {\n                node.children[c] = new Trie();\n            }\n            node = node.children[c];\n        }\n        node.idx = i;\n    }\n\n    public List&lt;Integer&gt; search(String word) {\n        Trie node = this;\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        for (char c : word.toCharArray()) {\n            c -= 'a';\n            if (node.children[c] == null) {\n                return res;\n            }\n            node = node.children[c];\n            if (node.idx != -1) {\n                res.add(node.idx);\n            }\n        }\n        return res;\n    }\n}\n</code></pre> <pre><code>class Trie {\nprivate:\n    vector&lt;Trie*&gt; children;\n    int idx;\n\npublic:\n    Trie()\n        : children(26)\n        , idx(-1) {}\n\n    void insert(string word, int i) {\n        Trie* node = this;\n        for (char c : word) {\n            int idx = c - 'a';\n            if (!node-&gt;children[idx]) node-&gt;children[idx] = new Trie();\n            node = node-&gt;children[idx];\n        }\n        node-&gt;idx = i;\n    }\n\n    vector&lt;int&gt; search(string word) {\n        Trie* node = this;\n        vector&lt;int&gt; res;\n        for (char c : word) {\n            int idx = c - 'a';\n            if (!node-&gt;children[idx]) return res;\n            node = node-&gt;children[idx];\n            if (node-&gt;idx != -1) res.push_back(node-&gt;idx);\n        }\n        return res;\n    }\n};\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; multiSearch(string big, vector&lt;string&gt;&amp; smalls) {\n        Trie* tree = new Trie();\n        int n = smalls.size();\n        for (int i = 0; i &lt; n; ++i) tree-&gt;insert(smalls[i], i);\n        vector&lt;vector&lt;int&gt;&gt; ans(n);\n        for (int i = 0, m = big.size(); i &lt; m; ++i) {\n            string s = big.substr(i, m - i);\n            vector&lt;int&gt; t = tree-&gt;search(s);\n            for (int&amp; idx : t) ans[idx].push_back(i);\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>type Trie struct {\n    children [26]*Trie\n    idx      int\n}\n\nfunc newTrie() *Trie {\n    return &amp;Trie{idx: -1}\n}\n\nfunc (this *Trie) insert(word string, idx int) {\n    node := this\n    for _, c := range word {\n        idx := c - 'a'\n        if node.children[idx] == nil {\n            node.children[idx] = newTrie()\n        }\n        node = node.children[idx]\n    }\n    node.idx = idx\n}\n\nfunc (this *Trie) search(word string) []int {\n    node := this\n    var res []int\n    for _, c := range word {\n        idx := c - 'a'\n        if node.children[idx] == nil {\n            return res\n        }\n        node = node.children[idx]\n        if node.idx != -1 {\n            res = append(res, node.idx)\n        }\n    }\n    return res\n}\n\nfunc multiSearch(big string, smalls []string) [][]int {\n    tree := newTrie()\n    for i, s := range smalls {\n        tree.insert(s, i)\n    }\n    n := len(smalls)\n    ans := make([][]int, n)\n    for i := range big {\n        s := big[i:]\n        t := tree.search(s)\n        for _, idx := range t {\n            ans[idx] = append(ans[idx], i)\n        }\n    }\n    return ans\n}\n</code></pre>"},{"location":"lcci/17.18.html","title":"17.18. Shortest Supersequence","text":""},{"location":"lcci/17.18.html#description","title":"Description","text":"<p>You are given two arrays, one shorter (with all distinct elements) and one longer. Find the shortest subarray in the longer array that contains all the elements in the shorter array. The items can appear in any order.</p> <p>Return the indexes of the leftmost and the rightmost elements of the array. If there are more than one answer, return the one that has the smallest left index. If there is no answer, return an empty array.</p> <p>Example 1:</p> <pre>\n\nInput:\n\nbig = [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7]\n\nsmall = [1,5,9]\n\nOutput: [7,10]</pre> <p>Example 2:</p> <pre>\n\nInput:\n\nbig = [1,2,3]\n\nsmall = [4]\n\nOutput: []</pre> <p>Note: </p> <ul> <li><code>big.length\u00a0&lt;= 100000</code></li> <li><code>1 &lt;= small.length\u00a0&lt;= 100000</code></li> </ul>"},{"location":"lcci/17.18.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.18.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def shortestSeq(self, big: List[int], small: List[int]) -&gt; List[int]:\n        need = Counter(small)\n        window = Counter()\n        cnt, j, k, mi = len(small), 0, -1, inf\n        for i, x in enumerate(big):\n            window[x] += 1\n            if need[x] &gt;= window[x]:\n                cnt -= 1\n            while cnt == 0:\n                if i - j + 1 &lt; mi:\n                    mi = i - j + 1\n                    k = j\n                if need[big[j]] &gt;= window[big[j]]:\n                    cnt += 1\n                window[big[j]] -= 1\n                j += 1\n        return [] if k &lt; 0 else [k, k + mi - 1]\n</code></pre> <pre><code>class Solution {\n    public int[] shortestSeq(int[] big, int[] small) {\n        int cnt = small.length;\n        Map&lt;Integer, Integer&gt; need = new HashMap&lt;&gt;(cnt);\n        Map&lt;Integer, Integer&gt; window = new HashMap&lt;&gt;(cnt);\n        for (int x : small) {\n            need.put(x, 1);\n        }\n        int k = -1, mi = 1 &lt;&lt; 30;\n        for (int i = 0, j = 0; i &lt; big.length; ++i) {\n            window.merge(big[i], 1, Integer::sum);\n            if (need.getOrDefault(big[i], 0) &gt;= window.get(big[i])) {\n                --cnt;\n            }\n            while (cnt == 0) {\n                if (i - j + 1 &lt; mi) {\n                    mi = i - j + 1;\n                    k = j;\n                }\n                if (need.getOrDefault(big[j], 0) &gt;= window.get(big[j])) {\n                    ++cnt;\n                }\n                window.merge(big[j++], -1, Integer::sum);\n            }\n        }\n        return k &lt; 0 ? new int[0] : new int[] {k, k + mi - 1};\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; shortestSeq(vector&lt;int&gt;&amp; big, vector&lt;int&gt;&amp; small) {\n        int cnt = small.size();\n        unordered_map&lt;int, int&gt; need;\n        unordered_map&lt;int, int&gt; window;\n        for (int x : small) {\n            need[x] = 1;\n        }\n        int k = -1, mi = 1 &lt;&lt; 30;\n        for (int i = 0, j = 0; i &lt; big.size(); ++i) {\n            window[big[i]]++;\n            if (need[big[i]] &gt;= window[big[i]]) {\n                --cnt;\n            }\n            while (cnt == 0) {\n                if (i - j + 1 &lt; mi) {\n                    mi = i - j + 1;\n                    k = j;\n                }\n                if (need[big[j]] &gt;= window[big[j]]) {\n                    ++cnt;\n                }\n                window[big[j++]]--;\n            }\n        }\n        if (k &lt; 0) {\n            return {};\n        }\n        return {k, k + mi - 1};\n    }\n};\n</code></pre> <pre><code>func shortestSeq(big []int, small []int) []int {\n    cnt := len(small)\n    need := map[int]int{}\n    window := map[int]int{}\n    for _, x := range small {\n        need[x] = 1\n    }\n    j, k, mi := 0, -1, 1&lt;&lt;30\n    for i, x := range big {\n        window[x]++\n        if need[x] &gt;= window[x] {\n            cnt--\n        }\n        for cnt == 0 {\n            if t := i - j + 1; t &lt; mi {\n                mi = t\n                k = j\n            }\n            if need[big[j]] &gt;= window[big[j]] {\n                cnt++\n            }\n            window[big[j]]--\n            j++\n        }\n    }\n    if k &lt; 0 {\n        return []int{}\n    }\n    return []int{k, k + mi - 1}\n}\n</code></pre> <pre><code>function shortestSeq(big: number[], small: number[]): number[] {\n    let cnt = small.length;\n    const need: Map&lt;number, number&gt; = new Map();\n    const window: Map&lt;number, number&gt; = new Map();\n    for (const x of small) {\n        need.set(x, 1);\n    }\n    let k = -1;\n    let mi = 1 &lt;&lt; 30;\n    for (let i = 0, j = 0; i &lt; big.length; ++i) {\n        window.set(big[i], (window.get(big[i]) ?? 0) + 1);\n        if ((need.get(big[i]) ?? 0) &gt;= window.get(big[i])!) {\n            --cnt;\n        }\n        while (cnt === 0) {\n            if (i - j + 1 &lt; mi) {\n                mi = i - j + 1;\n                k = j;\n            }\n            if ((need.get(big[j]) ?? 0) &gt;= window.get(big[j])!) {\n                ++cnt;\n            }\n            window.set(big[j], window.get(big[j])! - 1);\n            ++j;\n        }\n    }\n    return k &lt; 0 ? [] : [k, k + mi - 1];\n}\n</code></pre>"},{"location":"lcci/17.19.html","title":"17.19. Missing Two","text":""},{"location":"lcci/17.19.html#description","title":"Description","text":"<p>You are given an array with all the numbers from 1 to N appearing exactly once, except for two number that is missing. How can you find the missing number in O(N) time and 0(1) space?</p> <p>You can return the missing numbers in any order.</p> <p>Example 1:</p> <pre>\n\nInput: [1]\n\nOutput: [2,3]</pre> <p>Example 2:</p> <pre>\n\nInput: [2,3]\n\nOutput: [1,4]</pre> <p>Note: </p> <ul> <li><code>nums.length &lt;=\u00a030000</code></li> </ul>"},{"location":"lcci/17.19.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.19.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Solution:\n    def missingTwo(self, nums: List[int]) -&gt; List[int]:\n        n = len(nums) + 2\n        xor = 0\n        for v in nums:\n            xor ^= v\n        for i in range(1, n + 1):\n            xor ^= i\n\n        diff = xor &amp; (-xor)\n        a = 0\n        for v in nums:\n            if v &amp; diff:\n                a ^= v\n        for i in range(1, n + 1):\n            if i &amp; diff:\n                a ^= i\n        b = xor ^ a\n        return [a, b]\n</code></pre> <pre><code>class Solution {\n    public int[] missingTwo(int[] nums) {\n        int n = nums.length + 2;\n        int xor = 0;\n        for (int v : nums) {\n            xor ^= v;\n        }\n        for (int i = 1; i &lt;= n; ++i) {\n            xor ^= i;\n        }\n        int diff = xor &amp; (-xor);\n        int a = 0;\n        for (int v : nums) {\n            if ((v &amp; diff) != 0) {\n                a ^= v;\n            }\n        }\n        for (int i = 1; i &lt;= n; ++i) {\n            if ((i &amp; diff) != 0) {\n                a ^= i;\n            }\n        }\n        int b = xor ^ a;\n        return new int[] {a, b};\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; missingTwo(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size() + 2;\n        int eor = 0;\n        for (int v : nums) eor ^= v;\n        for (int i = 1; i &lt;= n; ++i) eor ^= i;\n\n        int diff = eor &amp; -eor;\n        int a = 0;\n        for (int v : nums)\n            if (v &amp; diff) a ^= v;\n        for (int i = 1; i &lt;= n; ++i)\n            if (i &amp; diff) a ^= i;\n        int b = eor ^ a;\n        return {a, b};\n    }\n};\n</code></pre> <pre><code>func missingTwo(nums []int) []int {\n    n := len(nums) + 2\n    xor := 0\n    for _, v := range nums {\n        xor ^= v\n    }\n    for i := 1; i &lt;= n; i++ {\n        xor ^= i\n    }\n    diff := xor &amp; -xor\n    a := 0\n    for _, v := range nums {\n        if (v &amp; diff) != 0 {\n            a ^= v\n        }\n    }\n    for i := 1; i &lt;= n; i++ {\n        if (i &amp; diff) != 0 {\n            a ^= i\n        }\n    }\n    b := xor ^ a\n    return []int{a, b}\n}\n</code></pre>"},{"location":"lcci/17.20.html","title":"17.20. Continuous Median","text":""},{"location":"lcci/17.20.html#description","title":"Description","text":"<p>Numbers are randomly generated and passed to a method. Write a program to find and maintain the median value as new values are generated.</p> <p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p> <p>For example,</p> <p>[2,3,4], the median is\u00a03</p> <p>[2,3], the median is (2 + 3) / 2 = 2.5</p> <p>Design a data structure that supports the following two operations:</p> <ul> <li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li> <li>double findMedian() - Return the median of all elements so far.</li> </ul> <p>Example: </p> <pre>\n\naddNum(1)\n\naddNum(2)\n\nfindMedian() -&gt; 1.5\n\naddNum(3) \n\nfindMedian() -&gt; 2\n\n</pre>"},{"location":"lcci/17.20.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.20.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class MedianFinder:\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.h1 = []\n        self.h2 = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.h1, num)\n        heappush(self.h2, -heappop(self.h1))\n        if len(self.h2) - len(self.h1) &gt; 1:\n            heappush(self.h1, -heappop(self.h2))\n\n    def findMedian(self) -&gt; float:\n        if len(self.h2) &gt; len(self.h1):\n            return -self.h2[0]\n        return (self.h1[0] - self.h2[0]) / 2\n\n\n# Your MedianFinder object will be instantiated and called as such:\n# obj = MedianFinder()\n# obj.addNum(num)\n# param_2 = obj.findMedian()\n</code></pre> <pre><code>class MedianFinder {\n    private PriorityQueue&lt;Integer&gt; q1 = new PriorityQueue&lt;&gt;();\n    private PriorityQueue&lt;Integer&gt; q2 = new PriorityQueue&lt;&gt;(Collections.reverseOrder());\n\n    /** initialize your data structure here. */\n    public MedianFinder() {\n    }\n\n    public void addNum(int num) {\n        q1.offer(num);\n        q2.offer(q1.poll());\n        if (q2.size() - q1.size() &gt; 1) {\n            q1.offer(q2.poll());\n        }\n    }\n\n    public double findMedian() {\n        if (q2.size() &gt; q1.size()) {\n            return q2.peek();\n        }\n        return (q1.peek() + q2.peek()) * 1.0 / 2;\n    }\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.addNum(num);\n * double param_2 = obj.findMedian();\n */\n</code></pre> <pre><code>class MedianFinder {\npublic:\n    /** initialize your data structure here. */\n    MedianFinder() {\n    }\n\n    void addNum(int num) {\n        q1.push(num);\n        q2.push(q1.top());\n        q1.pop();\n        if (q2.size() - q1.size() &gt; 1) {\n            q1.push(q2.top());\n            q2.pop();\n        }\n    }\n\n    double findMedian() {\n        if (q2.size() &gt; q1.size()) {\n            return q2.top();\n        }\n        return (double) (q1.top() + q2.top()) / 2;\n    }\n\nprivate:\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q1;\n    priority_queue&lt;int&gt; q2;\n};\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder* obj = new MedianFinder();\n * obj-&gt;addNum(num);\n * double param_2 = obj-&gt;findMedian();\n */\n</code></pre> <pre><code>type MedianFinder struct {\n    q1 hp\n    q2 hp\n}\n\n/** initialize your data structure here. */\nfunc Constructor() MedianFinder {\n    return MedianFinder{hp{}, hp{}}\n}\n\nfunc (this *MedianFinder) AddNum(num int) {\n    heap.Push(&amp;this.q1, num)\n    heap.Push(&amp;this.q2, -heap.Pop(&amp;this.q1).(int))\n    if this.q2.Len()-this.q1.Len() &gt; 1 {\n        heap.Push(&amp;this.q1, -heap.Pop(&amp;this.q2).(int))\n    }\n}\n\nfunc (this *MedianFinder) FindMedian() float64 {\n    if this.q2.Len() &gt; this.q1.Len() {\n        return -float64(this.q2.IntSlice[0])\n    }\n    return float64(this.q1.IntSlice[0]-this.q2.IntSlice[0]) / 2.0\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * obj := Constructor();\n * obj.AddNum(num);\n * param_2 := obj.FindMedian();\n */\n\ntype hp struct{ sort.IntSlice }\n\nfunc (h hp) Less(i, j int) bool { return h.IntSlice[i] &lt; h.IntSlice[j] }\nfunc (h *hp) Push(v any)        { h.IntSlice = append(h.IntSlice, v.(int)) }\nfunc (h *hp) Pop() any {\n    a := h.IntSlice\n    v := a[len(a)-1]\n    h.IntSlice = a[:len(a)-1]\n    return v\n}\n</code></pre>"},{"location":"lcci/17.21.html","title":"17.21. Volume of Histogram","text":""},{"location":"lcci/17.21.html#description","title":"Description","text":"<p>Imagine a histogram (bar graph). Design an algorithm to compute the volume of water it could hold if someone poured water across the top. You can assume that each histogram bar has width 1.</p> <p></p> <p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of water (blue section) are being trapped. Thanks Marcos for contributing this image!</p> <p>Example:</p> <pre>\n\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\n\nOutput: 6</pre>"},{"location":"lcci/17.21.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.21.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptC# <pre><code>class Solution:\n    def trap(self, height: List[int]) -&gt; int:\n        n = len(height)\n        if n &lt; 3:\n            return 0\n        left = [height[0]] * n\n        right = [height[-1]] * n\n        for i in range(1, n):\n            left[i] = max(left[i - 1], height[i])\n            right[n - i - 1] = max(right[n - i], height[n - i - 1])\n        return sum(min(l, r) - h for l, r, h in zip(left, right, height))\n</code></pre> <pre><code>class Solution {\n    public int trap(int[] height) {\n        int n = height.length;\n        if (n &lt; 3) {\n            return 0;\n        }\n        int[] left = new int[n];\n        int[] right = new int[n];\n        left[0] = height[0];\n        right[n - 1] = height[n - 1];\n        for (int i = 1; i &lt; n; ++i) {\n            left[i] = Math.max(left[i - 1], height[i]);\n            right[n - i - 1] = Math.max(right[n - i], height[n - i - 1]);\n        }\n        int ans = 0;\n        for (int i = 0; i &lt; n; ++i) {\n            ans += Math.min(left[i], right[i]) - height[i];\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        int n = height.size();\n        if (n &lt; 3) {\n            return 0;\n        }\n        int left[n], right[n];\n        left[0] = height[0];\n        right[n - 1] = height[n - 1];\n        for (int i = 1; i &lt; n; ++i) {\n            left[i] = max(left[i - 1], height[i]);\n            right[n - i - 1] = max(right[n - i], height[n - i - 1]);\n        }\n        int ans = 0;\n        for (int i = 0; i &lt; n; ++i) {\n            ans += min(left[i], right[i]) - height[i];\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func trap(height []int) (ans int) {\n    n := len(height)\n    if n &lt; 3 {\n        return 0\n    }\n    left := make([]int, n)\n    right := make([]int, n)\n    left[0], right[n-1] = height[0], height[n-1]\n    for i := 1; i &lt; n; i++ {\n        left[i] = max(left[i-1], height[i])\n        right[n-i-1] = max(right[n-i], height[n-i-1])\n    }\n    for i, h := range height {\n        ans += min(left[i], right[i]) - h\n    }\n    return\n}\n</code></pre> <pre><code>function trap(height: number[]): number {\n    const n = height.length;\n    if (n &lt; 3) {\n        return 0;\n    }\n    const left: number[] = new Array(n).fill(height[0]);\n    const right: number[] = new Array(n).fill(height[n - 1]);\n    for (let i = 1; i &lt; n; ++i) {\n        left[i] = Math.max(left[i - 1], height[i]);\n        right[n - i - 1] = Math.max(right[n - i], height[n - i - 1]);\n    }\n    let ans = 0;\n    for (let i = 0; i &lt; n; ++i) {\n        ans += Math.min(left[i], right[i]) - height[i];\n    }\n    return ans;\n}\n</code></pre> <pre><code>public class Solution {\n    public int Trap(int[] height) {\n        int n = height.Length;\n        if (n &lt; 3) {\n            return 0;\n        }\n        int[] left = new int[n];\n        int[] right = new int[n];\n        left[0] = height[0];\n        right[n - 1] = height[n - 1];\n        for (int i = 1; i &lt; n; ++i) {\n            left[i] = Math.Max(left[i - 1], height[i]);\n            right[n - i - 1] = Math.Max(right[n - i], height[n - i - 1]);\n        }\n        int ans = 0;\n        for (int i = 0; i &lt; n; ++i) {\n            ans += Math.Min(left[i], right[i]) - height[i];\n        }\n        return ans;\n    }\n}\n</code></pre>"},{"location":"lcci/17.22.html","title":"17.22. Word Transformer","text":""},{"location":"lcci/17.22.html#description","title":"Description","text":"<p>Given two words of equal length that are in a dictionary, write a method to transform one word into another word by changing only one letter at a time. The new word you get in each step must be in the dictionary.</p> <p>Write code to return a possible transforming sequence. If there are more that one sequence, any one is ok.</p> <p>Example 1:</p> <pre>\n\nInput:\n\nbeginWord = \"hit\",\n\nendWord = \"cog\",\n\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\n\n\nOutput:\n\n[\"hit\",\"hot\",\"dot\",\"lot\",\"log\",\"cog\"]\n\n</pre> <p>Example 2:</p> <pre>\n\nInput:\n\nbeginWord = \"hit\"\n\nendWord = \"cog\"\n\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\n\n\nOutput: []\n\n\n\nExplanation:\u00a0endWord \"cog\" is not in the dictionary, so there's no possible transforming sequence.</pre>"},{"location":"lcci/17.22.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.22.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Solution:\n    def findLadders(\n        self, beginWord: str, endWord: str, wordList: List[str]\n    ) -&gt; List[str]:\n        def check(a, b):\n            return sum(a[i] != b[i] for i in range(len(a))) == 1\n\n        def dfs(begin, end, t):\n            nonlocal ans\n            if ans:\n                return\n            if begin == end:\n                ans = t.copy()\n                return\n            for word in wordList:\n                if word in visited or not check(begin, word):\n                    continue\n                visited.add(word)\n                t.append(word)\n                dfs(word, end, t)\n                t.pop()\n\n        ans = []\n        visited = set()\n        dfs(beginWord, endWord, [beginWord])\n        return ans\n</code></pre> <pre><code>class Solution {\n    private List&lt;String&gt; words;\n    private List&lt;String&gt; ans;\n    private Set&lt;String&gt; visited;\n\n    public List&lt;String&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) {\n        words = wordList;\n        ans = new ArrayList&lt;&gt;();\n        visited = new HashSet&lt;&gt;();\n        List&lt;String&gt; t = new ArrayList&lt;&gt;();\n        t.add(beginWord);\n        dfs(beginWord, endWord, t);\n        return ans;\n    }\n\n    private void dfs(String begin, String end, List&lt;String&gt; t) {\n        if (!ans.isEmpty()) {\n            return;\n        }\n        if (Objects.equals(begin, end)) {\n            ans = new ArrayList&lt;&gt;(t);\n            return;\n        }\n        for (String word : words) {\n            if (visited.contains(word) || !check(begin, word)) {\n                continue;\n            }\n            t.add(word);\n            visited.add(word);\n            dfs(word, end, t);\n            t.remove(t.size() - 1);\n        }\n    }\n\n    private boolean check(String a, String b) {\n        if (a.length() != b.length()) {\n            return false;\n        }\n        int cnt = 0;\n        for (int i = 0; i &lt; a.length(); ++i) {\n            if (a.charAt(i) != b.charAt(i)) {\n                ++cnt;\n            }\n        }\n        return cnt == 1;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;string&gt; words;\n    vector&lt;string&gt; ans;\n    unordered_set&lt;string&gt; visited;\n\n    vector&lt;string&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        this-&gt;words = wordList;\n        ans.resize(0);\n        vector&lt;string&gt; t;\n        t.push_back(beginWord);\n        dfs(beginWord, endWord, t);\n        return ans;\n    }\n\n    void dfs(string begin, string end, vector&lt;string&gt;&amp; t) {\n        if (!ans.empty()) return;\n        if (begin == end) {\n            ans = t;\n            return;\n        }\n        for (auto word : words) {\n            if (visited.count(word) || !check(begin, word)) continue;\n            visited.insert(word);\n            t.push_back(word);\n            dfs(word, end, t);\n            t.pop_back();\n        }\n    }\n\n    bool check(string a, string b) {\n        if (a.size() != b.size()) return false;\n        int cnt = 0;\n        for (int i = 0; i &lt; a.size(); ++i)\n            if (a[i] != b[i]) ++cnt;\n        return cnt == 1;\n    }\n};\n</code></pre> <pre><code>func findLadders(beginWord string, endWord string, wordList []string) []string {\n    var ans []string\n    visited := make(map[string]bool)\n\n    check := func(a, b string) bool {\n        if len(a) != len(b) {\n            return false\n        }\n        cnt := 0\n        for i := 0; i &lt; len(a); i++ {\n            if a[i] != b[i] {\n                cnt++\n            }\n        }\n        return cnt == 1\n    }\n\n    var dfs func(begin, end string, t []string)\n    dfs = func(begin, end string, t []string) {\n        if len(ans) &gt; 0 {\n            return\n        }\n        if begin == end {\n            ans = make([]string, len(t))\n            copy(ans, t)\n            return\n        }\n        for _, word := range wordList {\n            if visited[word] || !check(begin, word) {\n                continue\n            }\n            t = append(t, word)\n            visited[word] = true\n            dfs(word, end, t)\n            t = t[:len(t)-1]\n        }\n    }\n\n    var t []string\n    t = append(t, beginWord)\n    dfs(beginWord, endWord, t)\n    return ans\n}\n</code></pre>"},{"location":"lcci/17.23.html","title":"17.23. Max Black Square","text":""},{"location":"lcci/17.23.html#description","title":"Description","text":"<p>Imagine you have a square matrix, where each cell (pixel) is either black or white Design an algorithm to find the maximum subsquare such that all four borders are filled with black pixels.</p> <p>Return an array\u00a0<code>[r, c, size]</code>, where\u00a0<code>r</code>,\u00a0<code>c</code>\u00a0are the row number and the column number of the subsquare's upper left corner respectively, and <code>size</code>\u00a0is the side length of the subsquare. If there are more than one answers, return the one that has smallest <code>r</code>. If there are more than one answers that have the same <code>r</code>, return the one that has smallest <code>c</code>. If there's no answer, return an empty array.</p> <p>Example 1:</p> <pre>\n\nInput:\n\n[\n\n\u00a0 [1,0,1],\n\n\u00a0 [0,0,1],\n\n\u00a0 [0,0,1]\n\n]\n\nOutput: [1,0,2]\n\nExplanation: 0 represents black, and 1 represents white, bold elements in the input is the answer.\n\n</pre> <p>Example 2:</p> <pre>\n\nInput:\n\n[\n\n\u00a0 [0,1,1],\n\n\u00a0 [1,0,1],\n\n\u00a0 [1,1,0]\n\n]\n\nOutput: [0,0,1]\n\n</pre> <p>Note: </p> <ul> <li><code>matrix.length == matrix[0].length &lt;= 200</code></li> </ul>"},{"location":"lcci/17.23.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.23.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def findSquare(self, matrix: List[List[int]]) -&gt; List[int]:\n        n = len(matrix)\n        down = [[0] * n for _ in range(n)]\n        right = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if matrix[i][j] == 0:\n                    down[i][j] = down[i + 1][j] + 1 if i + 1 &lt; n else 1\n                    right[i][j] = right[i][j + 1] + 1 if j + 1 &lt; n else 1\n        for k in range(n, 0, -1):\n            for i in range(n - k + 1):\n                for j in range(n - k + 1):\n                    if (\n                        down[i][j] &gt;= k\n                        and right[i][j] &gt;= k\n                        and right[i + k - 1][j] &gt;= k\n                        and down[i][j + k - 1] &gt;= k\n                    ):\n                        return [i, j, k]\n        return []\n</code></pre> <pre><code>class Solution {\n    public int[] findSquare(int[][] matrix) {\n        int n = matrix.length;\n        int[][] down = new int[n][n];\n        int[][] right = new int[n][n];\n        for (int i = n - 1; i &gt;= 0; --i) {\n            for (int j = n - 1; j &gt;= 0; --j) {\n                if (matrix[i][j] == 0) {\n                    down[i][j] = i + 1 &lt; n ? down[i + 1][j] + 1 : 1;\n                    right[i][j] = j + 1 &lt; n ? right[i][j + 1] + 1 : 1;\n                }\n            }\n        }\n        for (int k = n; k &gt; 0; --k) {\n            for (int i = 0; i &lt;= n - k; ++i) {\n                for (int j = 0; j &lt;= n - k; ++j) {\n                    if (down[i][j] &gt;= k &amp;&amp; right[i][j] &gt;= k &amp;&amp; right[i + k - 1][j] &gt;= k\n                        &amp;&amp; down[i][j + k - 1] &gt;= k) {\n                        return new int[] {i, j, k};\n                    }\n                }\n            }\n        }\n        return new int[0];\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; findSquare(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int n = matrix.size();\n        int down[n][n];\n        int right[n][n];\n        memset(down, 0, sizeof(down));\n        memset(right, 0, sizeof(right));\n        for (int i = n - 1; i &gt;= 0; --i) {\n            for (int j = n - 1; j &gt;= 0; --j) {\n                if (matrix[i][j] == 0) {\n                    down[i][j] = i + 1 &lt; n ? down[i + 1][j] + 1 : 1;\n                    right[i][j] = j + 1 &lt; n ? right[i][j + 1] + 1 : 1;\n                }\n            }\n        }\n        for (int k = n; k &gt; 0; --k) {\n            for (int i = 0; i &lt;= n - k; ++i) {\n                for (int j = 0; j &lt;= n - k; ++j) {\n                    if (down[i][j] &gt;= k &amp;&amp; right[i][j] &gt;= k &amp;&amp; right[i + k - 1][j] &gt;= k &amp;&amp; down[i][j + k - 1] &gt;= k) {\n                        return {i, j, k};\n                    }\n                }\n            }\n        }\n        return {};\n    }\n};\n</code></pre> <pre><code>func findSquare(matrix [][]int) []int {\n    n := len(matrix)\n    down := make([][]int, n)\n    right := make([][]int, n)\n    for i := range down {\n        down[i] = make([]int, n)\n        right[i] = make([]int, n)\n    }\n    for i := n - 1; i &gt;= 0; i-- {\n        for j := n - 1; j &gt;= 0; j-- {\n            if matrix[i][j] == 0 {\n                down[i][j], right[i][j] = 1, 1\n                if i+1 &lt; n {\n                    down[i][j] += down[i+1][j]\n                }\n                if j+1 &lt; n {\n                    right[i][j] += right[i][j+1]\n                }\n            }\n        }\n    }\n    for k := n; k &gt; 0; k-- {\n        for i := 0; i &lt;= n-k; i++ {\n            for j := 0; j &lt;= n-k; j++ {\n                if down[i][j] &gt;= k &amp;&amp; right[i][j] &gt;= k &amp;&amp; right[i+k-1][j] &gt;= k &amp;&amp; down[i][j+k-1] &gt;= k {\n                    return []int{i, j, k}\n                }\n            }\n        }\n    }\n    return []int{}\n}\n</code></pre> <pre><code>function findSquare(matrix: number[][]): number[] {\n    const n = matrix.length;\n    const down: number[][] = new Array(n).fill(0).map(() =&gt; new Array(n).fill(0));\n    const right: number[][] = new Array(n).fill(0).map(() =&gt; new Array(n).fill(0));\n    for (let i = n - 1; i &gt;= 0; --i) {\n        for (let j = n - 1; j &gt;= 0; --j) {\n            if (matrix[i][j] === 0) {\n                down[i][j] = i + 1 &lt; n ? down[i + 1][j] + 1 : 1;\n                right[i][j] = j + 1 &lt; n ? right[i][j + 1] + 1 : 1;\n            }\n        }\n    }\n    for (let k = n; k &gt; 0; --k) {\n        for (let i = 0; i &lt;= n - k; ++i) {\n            for (let j = 0; j &lt;= n - k; ++j) {\n                if (\n                    down[i][j] &gt;= k &amp;&amp;\n                    right[i][j] &gt;= k &amp;&amp;\n                    right[i + k - 1][j] &gt;= k &amp;&amp;\n                    down[i][j + k - 1] &gt;= k\n                ) {\n                    return [i, j, k];\n                }\n            }\n        }\n    }\n    return [];\n}\n</code></pre>"},{"location":"lcci/17.24.html","title":"17.24. Max Submatrix","text":""},{"location":"lcci/17.24.html#description","title":"Description","text":"<p>Given an NxN matrix of positive and negative integers, write code to find the submatrix with the largest possible sum.</p> <p>Return an array\u00a0<code>[r1, c1, r2, c2]</code>, where\u00a0<code>r1</code>, <code>c1</code> are the row number and the column number of the submatrix's upper left corner respectively, and\u00a0<code>r2</code>, <code>c2</code> are the row number of and the column number of lower right corner. If there are more than one answers, return any one of them.</p> <p>Note:\u00a0This problem is slightly different from the original one in the book.</p> <p>Example:</p> <pre>\n\nInput:\n\n<code>[\n\n\u00a0  [-1,0],\n\n\u00a0  [0,-1]\n\n]</code>\n\nOutput: [0,1,0,1]</pre> <p>Note: </p> <ul> <li><code>1 &lt;= matrix.length, matrix[0].length &lt;= 200</code></li> </ul>"},{"location":"lcci/17.24.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.24.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Solution:\n    def getMaxMatrix(self, matrix: List[List[int]]) -&gt; List[int]:\n        m, n = len(matrix), len(matrix[0])\n        s = [[0] * n for _ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                # \u200b\u6784\u9020\u200b\u5217\u200b\u524d\u7f00\u200b\u548c\u200b\n                s[i + 1][j] = s[i][j] + matrix[i][j]\n\n        mx = matrix[0][0]\n        ans = [0, 0, 0, 0]\n        for i1 in range(m):\n            for i2 in range(i1, m):\n                nums = [0] * n\n                for j in range(n):\n                    nums[j] = s[i2 + 1][j] - s[i1][j]\n\n                start = 0\n                f = nums[0]\n                for j in range(1, n):\n                    if f &gt; 0:\n                        f += nums[j]\n                    else:\n                        f = nums[j]\n                        start = j\n                    if f &gt; mx:\n                        mx = f\n                        ans = [i1, start, i2, j]\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int[] getMaxMatrix(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int[][] s = new int[m + 1][n];\n        for (int i = 0; i &lt; m; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                s[i + 1][j] = s[i][j] + matrix[i][j];\n            }\n        }\n        int mx = matrix[0][0];\n        int[] ans = new int[] {0, 0, 0, 0};\n        for (int i1 = 0; i1 &lt; m; ++i1) {\n            for (int i2 = i1; i2 &lt; m; ++i2) {\n                int[] nums = new int[n];\n                for (int j = 0; j &lt; n; ++j) {\n                    nums[j] = s[i2 + 1][j] - s[i1][j];\n                }\n                int start = 0;\n                int f = nums[0];\n                for (int j = 1; j &lt; n; ++j) {\n                    if (f &gt; 0) {\n                        f += nums[j];\n                    } else {\n                        f = nums[j];\n                        start = j;\n                    }\n                    if (f &gt; mx) {\n                        mx = f;\n                        ans = new int[] {i1, start, i2, j};\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; getMaxMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; s(m + 1, vector&lt;int&gt;(n));\n        for (int i = 0; i &lt; m; ++i)\n            for (int j = 0; j &lt; n; ++j)\n                s[i + 1][j] = s[i][j] + matrix[i][j];\n        int mx = matrix[0][0];\n        vector&lt;int&gt; ans(4);\n        for (int i1 = 0; i1 &lt; m; ++i1) {\n            for (int i2 = i1; i2 &lt; m; ++i2) {\n                vector&lt;int&gt; nums;\n                for (int j = 0; j &lt; n; ++j)\n                    nums.push_back(s[i2 + 1][j] - s[i1][j]);\n                int start = 0;\n                int f = nums[0];\n                for (int j = 1; j &lt; n; ++j) {\n                    if (f &gt; 0)\n                        f += nums[j];\n                    else {\n                        f = nums[j];\n                        start = j;\n                    }\n                    if (f &gt; mx) {\n                        mx = f;\n                        ans[0] = i1;\n                        ans[1] = start;\n                        ans[2] = i2;\n                        ans[3] = j;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func getMaxMatrix(matrix [][]int) []int {\n    m, n := len(matrix), len(matrix[0])\n    s := make([][]int, m+1)\n    for i := range s {\n        s[i] = make([]int, n)\n    }\n    for i := 0; i &lt; m; i++ {\n        for j := 0; j &lt; n; j++ {\n            s[i+1][j] = s[i][j] + matrix[i][j]\n        }\n    }\n    mx := matrix[0][0]\n    ans := make([]int, 4)\n    for i1 := 0; i1 &lt; m; i1++ {\n        for i2 := i1; i2 &lt; m; i2++ {\n            var nums []int\n            for j := 0; j &lt; n; j++ {\n                nums = append(nums, s[i2+1][j]-s[i1][j])\n            }\n            start := 0\n            f := nums[0]\n            for j := 1; j &lt; n; j++ {\n                if f &gt; 0 {\n                    f += nums[j]\n                } else {\n                    f = nums[j]\n                    start = j\n                }\n                if f &gt; mx {\n                    mx = f\n                    ans = []int{i1, start, i2, j}\n                }\n            }\n        }\n    }\n    return ans\n}\n</code></pre>"},{"location":"lcci/17.25.html","title":"17.25. Word Rectangle","text":""},{"location":"lcci/17.25.html#description","title":"Description","text":"<p>Given a list of millions of words, design an algorithm to create the largest possible rectangle of letters such that every row forms a word (reading left to right) and every column forms a word (reading top to bottom). The words need not be chosen consecutively from the list but all rows must be the same length and all columns must be the same height.</p> <p>If there are more than one answer, return any one of them. A word can be used more than once.</p> <p>Example 1:</p> <pre>\n\nInput: [\"this\", \"real\", \"hard\", \"trh\", \"hea\", \"iar\", \"sld\"]\n\nOutput:\n\n[\n\n\u00a0 \"this\",\n\n\u00a0 \"real\",\n\n\u00a0 \"hard\"\n\n]</pre> <p>Example 2:</p> <pre>\n\nInput: [\"aa\"]\n\nOutput: [\"aa\",\"aa\"]</pre> <p>Notes: </p> <ul> <li><code>words.length &lt;= 1000</code></li> <li><code>words[i].length &lt;= 100</code></li> <li>It's guaranteed that\u00a0all the words are randomly generated.</li> </ul>"},{"location":"lcci/17.25.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.25.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, w):\n        node = self\n        for c in w:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n\nclass Solution:\n    def maxRectangle(self, words: List[str]) -&gt; List[str]:\n        def check(mat):\n            m, n = len(mat), len(mat[0])\n            ans = 1\n            for j in range(n):\n                node = trie\n                for i in range(m):\n                    idx = ord(mat[i][j]) - ord(\"a\")\n                    if node.children[idx] is None:\n                        return 0\n                    node = node.children[idx]\n                if not node.is_end:\n                    ans = 2\n            return ans\n\n        def dfs(ws):\n            nonlocal ans, max_s, max_l\n            if len(ws[0]) * max_l &lt;= max_s or len(t) &gt;= max_l:\n                return\n\n            for w in ws:\n                t.append(w)\n                st = check(t)\n                if st == 0:\n                    t.pop()\n                    continue\n                if st == 1 and max_s &lt; len(t) * len(t[0]):\n                    ans = t[:]\n                    max_s = len(t) * len(t[0])\n                dfs(ws)\n                t.pop()\n\n        d = defaultdict(list)\n        trie = Trie()\n        max_l = 0\n        for w in words:\n            trie.insert(w)\n            max_l = max(max_l, len(w))\n            d[len(w)].append(w)\n\n        max_s = 0\n        ans = []\n        for ws in d.values():\n            t = []\n            dfs(ws)\n        return ans\n</code></pre> <pre><code>class Trie {\n    Trie[] children = new Trie[26];\n    boolean isEnd;\n\n    void insert(String word) {\n        Trie node = this;\n        for (char c : word.toCharArray()) {\n            c -= 'a';\n            if (node.children[c] == null) {\n                node.children[c] = new Trie();\n            }\n            node = node.children[c];\n        }\n        node.isEnd = true;\n    }\n}\n\nclass Solution {\n    private int maxL;\n    private int maxS;\n    private String[] ans;\n    private Trie trie = new Trie();\n    private List&lt;String&gt; t = new ArrayList&lt;&gt;();\n\n    public String[] maxRectangle(String[] words) {\n        Map&lt;Integer, List&lt;String&gt;&gt; d = new HashMap&lt;&gt;(100);\n        for (String w : words) {\n            maxL = Math.max(maxL, w.length());\n            trie.insert(w);\n            d.computeIfAbsent(w.length(), k -&gt; new ArrayList&lt;&gt;()).add(w);\n        }\n        for (List&lt;String&gt; ws : d.values()) {\n            t.clear();\n            dfs(ws);\n        }\n        return ans;\n    }\n\n    private void dfs(List&lt;String&gt; ws) {\n        if (ws.get(0).length() * maxL &lt;= maxS || t.size() &gt;= maxL) {\n            return;\n        }\n        for (String w : ws) {\n            t.add(w);\n            int st = check(t);\n            if (st == 0) {\n                t.remove(t.size() - 1);\n                continue;\n            }\n            if (st == 1 &amp;&amp; maxS &lt; t.size() * t.get(0).length()) {\n                maxS = t.size() * t.get(0).length();\n                ans = t.toArray(new String[0]);\n            }\n            dfs(ws);\n            t.remove(t.size() - 1);\n        }\n    }\n\n    private int check(List&lt;String&gt; mat) {\n        int m = mat.size(), n = mat.get(0).length();\n        int ans = 1;\n        for (int j = 0; j &lt; n; ++j) {\n            Trie node = trie;\n            for (int i = 0; i &lt; m; ++i) {\n                int idx = mat.get(i).charAt(j) - 'a';\n                if (node.children[idx] == null) {\n                    return 0;\n                }\n                node = node.children[idx];\n            }\n            if (!node.isEnd) {\n                ans = 2;\n            }\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Trie {\npublic:\n    vector&lt;Trie*&gt; children;\n    bool is_end;\n\n    Trie() {\n        children = vector&lt;Trie*&gt;(26, nullptr);\n        is_end = false;\n    }\n\n    void insert(const string&amp; word) {\n        Trie* cur = this;\n        for (char c : word) {\n            c -= 'a';\n            if (cur-&gt;children[c] == nullptr) {\n                cur-&gt;children[c] = new Trie;\n            }\n            cur = cur-&gt;children[c];\n        }\n        cur-&gt;is_end = true;\n    }\n};\n\nclass Solution {\npublic:\n    vector&lt;string&gt; maxRectangle(vector&lt;string&gt;&amp; words) {\n        unordered_map&lt;int, vector&lt;string&gt;&gt; d;\n        int maxL = 0, maxS = 0;\n        vector&lt;string&gt; ans;\n        vector&lt;string&gt; t;\n        Trie* trie = new Trie();\n        for (auto&amp; w : words) {\n            maxL = max(maxL, (int) w.size());\n            d[w.size()].emplace_back(w);\n            trie-&gt;insert(w);\n        }\n        auto check = [&amp;](vector&lt;string&gt;&amp; mat) {\n            int m = mat.size(), n = mat[0].size();\n            int ans = 1;\n            for (int j = 0; j &lt; n; ++j) {\n                Trie* node = trie;\n                for (int i = 0; i &lt; m; ++i) {\n                    int idx = mat[i][j] - 'a';\n                    if (!node-&gt;children[idx]) {\n                        return 0;\n                    }\n                    node = node-&gt;children[idx];\n                }\n                if (!node-&gt;is_end) {\n                    ans = 2;\n                }\n            }\n            return ans;\n        };\n\n        function&lt;void(vector&lt;string&gt;&amp;)&gt; dfs = [&amp;](vector&lt;string&gt;&amp; ws) {\n            if (ws[0].size() * maxL &lt;= maxS || t.size() &gt;= maxL) {\n                return;\n            }\n            for (auto&amp; w : ws) {\n                t.emplace_back(w);\n                int st = check(t);\n                if (st == 0) {\n                    t.pop_back();\n                    continue;\n                }\n                if (st == 1 &amp;&amp; maxS &lt; t.size() * t[0].size()) {\n                    maxS = t.size() * t[0].size();\n                    ans = t;\n                }\n                dfs(ws);\n                t.pop_back();\n            }\n        };\n        for (auto&amp; [_, ws] : d) {\n            t.clear();\n            dfs(ws);\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>type Trie struct {\n    children [26]*Trie\n    isEnd    bool\n}\n\nfunc newTrie() *Trie {\n    return &amp;Trie{}\n}\nfunc (this *Trie) insert(word string) {\n    node := this\n    for _, c := range word {\n        c -= 'a'\n        if node.children[c] == nil {\n            node.children[c] = newTrie()\n        }\n        node = node.children[c]\n    }\n    node.isEnd = true\n}\n\nfunc maxRectangle(words []string) (ans []string) {\n    trie := newTrie()\n    d := map[int][]string{}\n    t := []string{}\n    var maxL, maxS int\n    for _, w := range words {\n        maxL = max(maxL, len(w))\n        d[len(w)] = append(d[len(w)], w)\n        trie.insert(w)\n    }\n    check := func(mat []string) int {\n        m, n := len(mat), len(mat[0])\n        ans := 1\n        for j := 0; j &lt; n; j++ {\n            node := trie\n            for i := 0; i &lt; m; i++ {\n                idx := mat[i][j] - 'a'\n                if node.children[idx] == nil {\n                    return 0\n                }\n                node = node.children[idx]\n            }\n            if !node.isEnd {\n                ans = 2\n            }\n        }\n        return ans\n    }\n    var dfs func([]string)\n    dfs = func(ws []string) {\n        if len(ws[0])*maxL &lt;= maxS || len(t) &gt;= maxL {\n            return\n        }\n        for _, w := range ws {\n            t = append(t, w)\n            st := check(t)\n            if st == 0 {\n                t = t[:len(t)-1]\n                continue\n            }\n            if st == 1 &amp;&amp; maxS &lt; len(t)*len(t[0]) {\n                maxS = len(t) * len(t[0])\n                ans = append([]string{}, t...)\n            }\n            dfs(ws)\n            t = t[:len(t)-1]\n        }\n    }\n    for _, ws := range d {\n        dfs(ws)\n    }\n    return\n}\n</code></pre>"},{"location":"lcci/17.26.html","title":"17.26. Sparse Similarity","text":""},{"location":"lcci/17.26.html#description","title":"Description","text":"<p>The similarity of two documents (each with distinct words) is defined to be the size of the intersection divided by the size of the union. For example, if the documents consist of integers, the similarity of {1, 5, 3} and {1, 7, 2, 3} is 0.4, because the intersection has size 2 and the union has size 5.\u00a0We have a long list of documents (with distinct values and each with an associated ID) where the similarity is believed to be \"sparse\". That is, any two arbitrarily selected documents are very likely to have similarity 0. Design an algorithm that returns a list of pairs of document IDs and the associated similarity.</p> <p>Input is a 2D array\u00a0<code>docs</code>, where\u00a0<code>docs[i]</code>\u00a0is the document with id\u00a0<code>i</code>. Return an array of strings, where each string represents a pair of documents with similarity greater than 0. The string should be formatted as\u00a0 <code>{id1},{id2}: {similarity}</code>, where <code>id1</code>\u00a0is the smaller id in the two documents, and <code>similarity</code> is the similarity rounded to four decimal places. You can return the array in any order.</p> <p>Example:</p> <pre>\n\nInput:\n\n<code>[\n\n\u00a0 [14, 15, 100, 9, 3],\n\n\u00a0 [32, 1, 9, 3, 5],\n\n\u00a0 [15, 29, 2, 6, 8, 7],\n\n\u00a0 [7, 10]\n\n]</code>\n\nOutput:\n\n[\n\n\u00a0 \"0,1: 0.2500\",\n\n\u00a0 \"0,2: 0.1000\",\n\n\u00a0 \"2,3: 0.1429\"\n\n]</pre> <p>Note: </p> <ul> <li><code>docs.length &lt;= 500</code></li> <li><code>docs[i].length &lt;= 500</code></li> <li>The number of document pairs with similarity greater than 0 will not exceed 1000.</li> </ul>"},{"location":"lcci/17.26.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.26.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Solution:\n    def computeSimilarities(self, docs: List[List[int]]) -&gt; List[str]:\n        eps = 1e-9\n        d = defaultdict(list)\n        for i, v in enumerate(docs):\n            for x in v:\n                d[x].append(i)\n        cnt = Counter()\n        for ids in d.values():\n            n = len(ids)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    cnt[(ids[i], ids[j])] += 1\n        ans = []\n        for (i, j), v in cnt.items():\n            tot = len(docs[i]) + len(docs[j]) - v\n            x = v / tot + eps\n            ans.append(f'{i},{j}: {x:.4f}')\n        return ans\n</code></pre> <pre><code>class Solution {\n    public List&lt;String&gt; computeSimilarities(int[][] docs) {\n        Map&lt;Integer, List&lt;Integer&gt;&gt; d = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; docs.length; ++i) {\n            for (int v : docs[i]) {\n                d.computeIfAbsent(v, k -&gt; new ArrayList&lt;&gt;()).add(i);\n            }\n        }\n        Map&lt;String, Integer&gt; cnt = new HashMap&lt;&gt;();\n        for (var ids : d.values()) {\n            int n = ids.size();\n            for (int i = 0; i &lt; n; ++i) {\n                for (int j = i + 1; j &lt; n; ++j) {\n                    String k = ids.get(i) + \",\" + ids.get(j);\n                    cnt.put(k, cnt.getOrDefault(k, 0) + 1);\n                }\n            }\n        }\n        List&lt;String&gt; ans = new ArrayList&lt;&gt;();\n        for (var e : cnt.entrySet()) {\n            String k = e.getKey();\n            int v = e.getValue();\n            String[] t = k.split(\",\");\n            int i = Integer.parseInt(t[0]), j = Integer.parseInt(t[1]);\n            int tot = docs[i].length + docs[j].length - v;\n            double x = (double) v / tot;\n            ans.add(String.format(\"%s: %.4f\", k, x));\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>using pii = pair&lt;int, int&gt;;\n\nclass Solution {\npublic:\n    vector&lt;string&gt; computeSimilarities(vector&lt;vector&lt;int&gt;&gt;&amp; docs) {\n        double eps = 1e-9;\n        unordered_map&lt;int, vector&lt;int&gt;&gt; d;\n        for (int i = 0; i &lt; docs.size(); ++i) {\n            for (int v : docs[i]) {\n                d[v].push_back(i);\n            }\n        }\n        map&lt;pii, int&gt; cnt;\n        for (auto&amp; [_, ids] : d) {\n            int n = ids.size();\n            for (int i = 0; i &lt; n; ++i) {\n                for (int j = i + 1; j &lt; n; ++j) {\n                    cnt[{ids[i], ids[j]}]++;\n                }\n            }\n        }\n        vector&lt;string&gt; ans;\n        for (auto&amp; [k, v] : cnt) {\n            auto [i, j] = k;\n            int tot = docs[i].size() + docs[j].size() - v;\n            double x = (double) v / tot + eps;\n            char t[20];\n            sprintf(t, \"%d,%d: %0.4lf\", i, j, x);\n            ans.push_back(t);\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func computeSimilarities(docs [][]int) []string {\n    d := map[int][]int{}\n    for i, v := range docs {\n        for _, x := range v {\n            d[x] = append(d[x], i)\n        }\n    }\n    type pair struct{ i, j int }\n    cnt := map[pair]int{}\n    for _, ids := range d {\n        n := len(ids)\n        for i := 0; i &lt; n; i++ {\n            for j := i + 1; j &lt; n; j++ {\n                k := pair{ids[i], ids[j]}\n                cnt[k]++\n            }\n        }\n    }\n    ans := []string{}\n    for k, v := range cnt {\n        i, j := k.i, k.j\n        tot := len(docs[i]) + len(docs[j]) - v\n        x := float64(v)/float64(tot) + 1e-9\n        ans = append(ans, strconv.Itoa(i)+\",\"+strconv.Itoa(j)+\": \"+fmt.Sprintf(\"%.4f\", x))\n    }\n    return ans\n}\n</code></pre>"},{"location":"lcci/17.4.html","title":"17.04. Missing Number","text":""},{"location":"lcci/17.4.html#description","title":"Description","text":"<p>An array\u00a0contains all the integers from 0 to n, except for one number which is missing.\u00a0 Write code to find the missing integer. Can you do it in O(n) time?</p> <p>Note: This problem is slightly different from the original one the book.</p> <p>Example 1: </p> <pre>\n\nInput: [3,0,1]\n\nOutput: 2</pre> <p> </p> <p>Example 2: </p> <pre>\n\nInput: [9,6,4,2,3,5,7,0,1]\n\nOutput: 8\n\n</pre>"},{"location":"lcci/17.4.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.4.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoRustJavaScript <pre><code>class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        nums.sort()\n        for i, x in enumerate(nums):\n            if i != x:\n                return i\n        return len(nums)\n</code></pre> <pre><code>class Solution {\n    public int missingNumber(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        for (int i = 0; i &lt; n; ++i) {\n            if (i != nums[i]) {\n                return i;\n            }\n        }\n        return n;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int missingNumber(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        for (int i = 0; i &lt; n; ++i) {\n            if (i != nums[i]) {\n                return i;\n            }\n        }\n        return n;\n    }\n};\n</code></pre> <pre><code>func missingNumber(nums []int) int {\n    sort.Ints(nums)\n    for i, x := range nums {\n        if i != x {\n            return i\n        }\n    }\n    return len(nums)\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn missing_number(mut nums: Vec&lt;i32&gt;) -&gt; i32 {\n        nums.sort();\n        let n = nums.len() as i32;\n        for i in 0..n {\n            if i != nums[i as usize] {\n                return i;\n            }\n        }\n        n\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingNumber = function (nums) {\n    nums.sort((a, b) =&gt; a - b);\n    const n = nums.length;\n    for (let i = 0; i &lt; n; ++i) {\n        if (i != nums[i]) {\n            return i;\n        }\n    }\n    return n;\n};\n</code></pre>"},{"location":"lcci/17.4.html#solution-2","title":"Solution 2","text":"Python3JavaC++GoRustJavaScript <pre><code>class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        return sum(range(len(nums) + 1)) - sum(nums)\n</code></pre> <pre><code>class Solution {\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        int ans = n;\n        for (int i = 0; i &lt; n; ++i) {\n            ans += i - nums[i];\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int missingNumber(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        int ans = n;\n        for (int i = 0; i &lt; n; ++i) {\n            ans += i - nums[i];\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func missingNumber(nums []int) (ans int) {\n    ans = len(nums)\n    for i, x := range nums {\n        ans += i - x\n    }\n    return\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn missing_number(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        let n = nums.len() as i32;\n        let mut sum = 0;\n        let mut max = 0;\n        for num in nums {\n            sum += num;\n            max = max.max(num);\n        }\n        if max == n {\n            ((1 + max) * max) / 2 - sum\n        } else {\n            n\n        }\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingNumber = function (nums) {\n    const n = nums.length;\n    let ans = n;\n    for (let i = 0; i &lt; n; ++i) {\n        ans += i - nums[i];\n    }\n    return ans;\n};\n</code></pre>"},{"location":"lcci/17.4.html#solution-3","title":"Solution 3","text":"Python3JavaC++GoRustJavaScript <pre><code>class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        ans = 0\n        for i, x in enumerate(nums, 1):\n            ans ^= i ^ x\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int missingNumber(int[] nums) {\n        int ans = 0;\n        for (int i = 1; i &lt;= nums.length; ++i) {\n            ans ^= i ^ nums[i - 1];\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int missingNumber(vector&lt;int&gt;&amp; nums) {\n        int ans = 0;\n        for (int i = 1; i &lt;= nums.size(); ++i) {\n            ans ^= i ^ nums[i - 1];\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func missingNumber(nums []int) (ans int) {\n    for i, x := range nums {\n        ans ^= (i + 1) ^ x\n    }\n    return\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn missing_number(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        let mut res = 0;\n        let n = nums.len();\n        for i in 0..n {\n            res ^= nums[i] ^ ((i + 1) as i32);\n        }\n        res\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingNumber = function (nums) {\n    let ans = 0;\n    for (let i = 1; i &lt;= nums.length; ++i) {\n        ans ^= i ^ nums[i - 1];\n    }\n    return ans;\n};\n</code></pre>"},{"location":"lcci/17.5.html","title":"17.05. Find Longest Subarray","text":""},{"location":"lcci/17.5.html#description","title":"Description","text":"<p>Given an array filled with letters and numbers, find the longest subarray with an equal number of letters and numbers.</p> <p>Return the subarray. If there are more than one answer, return the one which has the smallest\u00a0index of its left endpoint. If there is no answer, return an empty arrary.</p> <p>Example 1:</p> <pre>\n\nInput: [\"A\",\"1\",\"B\",\"C\",\"D\",\"2\",\"3\",\"4\",\"E\",\"5\",\"F\",\"G\",\"6\",\"7\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\"]\n\n\n\nOutput: [\"A\",\"1\",\"B\",\"C\",\"D\",\"2\",\"3\",\"4\",\"E\",\"5\",\"F\",\"G\",\"6\",\"7\"]\n\n</pre> <p>Example 2:</p> <pre>\n\nInput: [\"A\",\"A\"]\n\n\n\nOutput: []\n\n</pre> <p>Note: </p> <ul> <li><code>array.length &lt;= 100000</code></li> </ul>"},{"location":"lcci/17.5.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.5.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def findLongestSubarray(self, array: List[str]) -&gt; List[str]:\n        vis = {0: -1}\n        s = mx = k = 0\n        for i, x in enumerate(array):\n            s += 1 if x.isalpha() else -1\n            if s in vis:\n                if mx &lt; i - (j := vis[s]):\n                    mx = i - j\n                    k = j + 1\n            else:\n                vis[s] = i\n        return array[k : k + mx]\n</code></pre> <pre><code>class Solution {\n    public String[] findLongestSubarray(String[] array) {\n        Map&lt;Integer, Integer&gt; vis = new HashMap&lt;&gt;();\n        vis.put(0, -1);\n        int s = 0, mx = 0, k = 0;\n        for (int i = 0; i &lt; array.length; ++i) {\n            s += array[i].charAt(0) &gt;= 'A' ? 1 : -1;\n            if (vis.containsKey(s)) {\n                int j = vis.get(s);\n                if (mx &lt; i - j) {\n                    mx = i - j;\n                    k = j + 1;\n                }\n            } else {\n                vis.put(s, i);\n            }\n        }\n        String[] ans = new String[mx];\n        System.arraycopy(array, k, ans, 0, mx);\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;string&gt; findLongestSubarray(vector&lt;string&gt;&amp; array) {\n        unordered_map&lt;int, int&gt; vis{{0, -1}};\n        int s = 0, mx = 0, k = 0;\n        for (int i = 0; i &lt; array.size(); ++i) {\n            s += array[i][0] &gt;= 'A' ? 1 : -1;\n            if (vis.count(s)) {\n                int j = vis[s];\n                if (mx &lt; i - j) {\n                    mx = i - j;\n                    k = j + 1;\n                }\n            } else {\n                vis[s] = i;\n            }\n        }\n        return vector&lt;string&gt;(array.begin() + k, array.begin() + k + mx);\n    }\n};\n</code></pre> <pre><code>func findLongestSubarray(array []string) []string {\n    vis := map[int]int{0: -1}\n    var s, mx, k int\n    for i, x := range array {\n        if x[0] &gt;= 'A' {\n            s++\n        } else {\n            s--\n        }\n        if j, ok := vis[s]; ok {\n            if mx &lt; i-j {\n                mx = i - j\n                k = j + 1\n            }\n        } else {\n            vis[s] = i\n        }\n    }\n    return array[k : k+mx]\n}\n</code></pre> <pre><code>function findLongestSubarray(array: string[]): string[] {\n    const vis = new Map();\n    vis.set(0, -1);\n    let s = 0,\n        mx = 0,\n        k = 0;\n    for (let i = 0; i &lt; array.length; ++i) {\n        s += array[i] &gt;= 'A' ? 1 : -1;\n        if (vis.has(s)) {\n            const j = vis.get(s);\n            if (mx &lt; i - j) {\n                mx = i - j;\n                k = j + 1;\n            }\n        } else {\n            vis.set(s, i);\n        }\n    }\n    return array.slice(k, k + mx);\n}\n</code></pre>"},{"location":"lcci/17.6.html","title":"17.06. Number Of 2s In Range","text":""},{"location":"lcci/17.6.html#description","title":"Description","text":"<p>Write a method to count the number of 2s that appear in all the numbers between 0\u00a0and n (inclusive).</p> <p>Example:</p> <pre>\n\nInput: 25\n\nOutput: 9\n\nExplanation: (2, 12, 20, 21, 22, 23, 24, 25)(Note that 22 counts for two 2s.)</pre> <p>Note:</p> <ul> <li><code>n &lt;= 10^9</code></li> </ul>"},{"location":"lcci/17.6.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.6.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Solution:\n    def numberOf2sInRange(self, n: int) -&gt; int:\n        @cache\n        def dfs(pos, cnt, limit):\n            if pos &lt;= 0:\n                return cnt\n            up = a[pos] if limit else 9\n            ans = 0\n            for i in range(up + 1):\n                ans += dfs(pos - 1, cnt + (i == 2), limit and i == up)\n            return ans\n\n        a = [0] * 12\n        l = 0\n        while n:\n            l += 1\n            a[l] = n % 10\n            n //= 10\n        return dfs(l, 0, True)\n</code></pre> <pre><code>class Solution {\n    private int[] a = new int[12];\n    private int[][] dp = new int[12][12];\n\n    public int numberOf2sInRange(int n) {\n        int len = 0;\n        while (n &gt; 0) {\n            a[++len] = n % 10;\n            n /= 10;\n        }\n        for (var e : dp) {\n            Arrays.fill(e, -1);\n        }\n        return dfs(len, 0, true);\n    }\n\n    private int dfs(int pos, int cnt, boolean limit) {\n        if (pos &lt;= 0) {\n            return cnt;\n        }\n        if (!limit &amp;&amp; dp[pos][cnt] != -1) {\n            return dp[pos][cnt];\n        }\n        int up = limit ? a[pos] : 9;\n        int ans = 0;\n        for (int i = 0; i &lt;= up; ++i) {\n            ans += dfs(pos - 1, cnt + (i == 2 ? 1 : 0), limit &amp;&amp; i == up);\n        }\n        if (!limit) {\n            dp[pos][cnt] = ans;\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int a[12];\n    int dp[12][12];\n\n    int numberOf2sInRange(int n) {\n        int len = 0;\n        while (n) {\n            a[++len] = n % 10;\n            n /= 10;\n        }\n        memset(dp, -1, sizeof dp);\n        return dfs(len, 0, true);\n    }\n\n    int dfs(int pos, int cnt, bool limit) {\n        if (pos &lt;= 0) {\n            return cnt;\n        }\n        if (!limit &amp;&amp; dp[pos][cnt] != -1) {\n            return dp[pos][cnt];\n        }\n        int ans = 0;\n        int up = limit ? a[pos] : 9;\n        for (int i = 0; i &lt;= up; ++i) {\n            ans += dfs(pos - 1, cnt + (i == 2), limit &amp;&amp; i == up);\n        }\n        if (!limit) {\n            dp[pos][cnt] = ans;\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func numberOf2sInRange(n int) int {\n    a := make([]int, 12)\n    dp := make([][]int, 12)\n    for i := range dp {\n        dp[i] = make([]int, 12)\n        for j := range dp[i] {\n            dp[i][j] = -1\n        }\n    }\n    l := 0\n    for n &gt; 0 {\n        l++\n        a[l] = n % 10\n        n /= 10\n    }\n    var dfs func(int, int, bool) int\n    dfs = func(pos, cnt int, limit bool) int {\n        if pos &lt;= 0 {\n            return cnt\n        }\n        if !limit &amp;&amp; dp[pos][cnt] != -1 {\n            return dp[pos][cnt]\n        }\n        up := 9\n        if limit {\n            up = a[pos]\n        }\n        ans := 0\n        for i := 0; i &lt;= up; i++ {\n            t := cnt\n            if i == 2 {\n                t++\n            }\n            ans += dfs(pos-1, t, limit &amp;&amp; i == up)\n        }\n        if !limit {\n            dp[pos][cnt] = ans\n        }\n        return ans\n    }\n    return dfs(l, 0, true)\n}\n</code></pre>"},{"location":"lcci/17.7.html","title":"17.07. Baby Names","text":""},{"location":"lcci/17.7.html#description","title":"Description","text":"<p>Each year, the government releases a list of the 10000 most common baby names and their frequencies (the number of babies with that name). The only problem with this is that some names have multiple spellings. For example,\"John\" and ''Jon\" are essentially the same name but would be listed separately in the list. Given two lists, one of names/frequencies and the other of pairs of equivalent names, write an algorithm to print a new list of the true frequency of each name. Note that if John and Jon are synonyms, and Jon and Johnny are synonyms, then John and Johnny are synonyms. (It is both transitive and symmetric.) In the final list, choose the name that are lexicographically smallest as the \"real\" name.</p> <p>Example: </p> <pre>\n\nInput: names = [\"John(15)\",\"Jon(12)\",\"Chris(13)\",\"Kris(4)\",\"Christopher(19)\"], synonyms = [\"(Jon,John)\",\"(John,Johnny)\",\"(Chris,Kris)\",\"(Chris,Christopher)\"]\n\nOutput: [\"John(27)\",\"Chris(36)\"]</pre> <p>Note:</p> <ul> <li><code>names.length &lt;= 100000</code></li> </ul>"},{"location":"lcci/17.7.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.7.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def trulyMostPopular(self, names: List[str], synonyms: List[str]) -&gt; List[str]:\n        def dfs(a):\n            vis.add(a)\n            mi, x = a, cnt[a]\n            for b in g[a]:\n                if b not in vis:\n                    t, y = dfs(b)\n                    if mi &gt; t:\n                        mi = t\n                    x += y\n            return mi, x\n\n        g = defaultdict(list)\n        for e in synonyms:\n            a, b = e[1:-1].split(',')\n            g[a].append(b)\n            g[b].append(a)\n        s = set()\n        cnt = defaultdict(int)\n        for x in names:\n            name, freq = x[:-1].split(\"(\")\n            s.add(name)\n            cnt[name] = int(freq)\n        vis = set()\n        ans = []\n        for name in s:\n            if name not in vis:\n                name, freq = dfs(name)\n                ans.append(f\"{name}({freq})\")\n        return ans\n</code></pre> <pre><code>class Solution {\n    private Map&lt;String, List&lt;String&gt;&gt; g = new HashMap&lt;&gt;();\n    private Map&lt;String, Integer&gt; cnt = new HashMap&lt;&gt;();\n    private Set&lt;String&gt; vis = new HashSet&lt;&gt;();\n    private int freq;\n\n    public String[] trulyMostPopular(String[] names, String[] synonyms) {\n        for (String pairs : synonyms) {\n            String[] pair = pairs.substring(1, pairs.length() - 1).split(\",\");\n            String a = pair[0], b = pair[1];\n            g.computeIfAbsent(a, k -&gt; new ArrayList&lt;&gt;()).add(b);\n            g.computeIfAbsent(b, k -&gt; new ArrayList&lt;&gt;()).add(a);\n        }\n        Set&lt;String&gt; s = new HashSet&lt;&gt;();\n        for (String x : names) {\n            int i = x.indexOf('(');\n            String name = x.substring(0, i);\n            s.add(name);\n            cnt.put(name, Integer.parseInt(x.substring(i + 1, x.length() - 1)));\n        }\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n        for (String name : s) {\n            if (!vis.contains(name)) {\n                freq = 0;\n                name = dfs(name);\n                res.add(name + \"(\" + freq + \")\");\n            }\n        }\n        return res.toArray(new String[0]);\n    }\n\n    private String dfs(String a) {\n        String mi = a;\n        vis.add(a);\n        freq += cnt.getOrDefault(a, 0);\n        for (String b : g.getOrDefault(a, new ArrayList&lt;&gt;())) {\n            if (!vis.contains(b)) {\n                String t = dfs(b);\n                if (t.compareTo(mi) &lt; 0) {\n                    mi = t;\n                }\n            }\n        }\n        return mi;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;string&gt; trulyMostPopular(vector&lt;string&gt;&amp; names, vector&lt;string&gt;&amp; synonyms) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; g;\n        unordered_map&lt;string, int&gt; cnt;\n        for (auto&amp; e : synonyms) {\n            int i = e.find(',');\n            string a = e.substr(1, i - 1);\n            string b = e.substr(i + 1, e.size() - i - 2);\n            g[a].emplace_back(b);\n            g[b].emplace_back(a);\n        }\n        unordered_set&lt;string&gt; s;\n        for (auto&amp; e : names) {\n            int i = e.find('(');\n            string name = e.substr(0, i);\n            s.insert(name);\n            cnt[name] += stoi(e.substr(i + 1, e.size() - i - 2));\n        }\n        unordered_set&lt;string&gt; vis;\n        int freq = 0;\n\n        function&lt;string(string)&gt; dfs = [&amp;](string a) -&gt; string {\n            string res = a;\n            vis.insert(a);\n            freq += cnt[a];\n            for (auto&amp; b : g[a]) {\n                if (!vis.count(b)) {\n                    string t = dfs(b);\n                    if (t &lt; res) {\n                        res = move(t);\n                    }\n                }\n            }\n            return move(res);\n        };\n\n        vector&lt;string&gt; ans;\n        for (auto&amp; name : s) {\n            if (!vis.count(name)) {\n                freq = 0;\n                string x = dfs(name);\n                ans.emplace_back(x + \"(\" + to_string(freq) + \")\");\n            }\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func trulyMostPopular(names []string, synonyms []string) (ans []string) {\n    g := map[string][]string{}\n    for _, s := range synonyms {\n        i := strings.Index(s, \",\")\n        a, b := s[1:i], s[i+1:len(s)-1]\n        g[a] = append(g[a], b)\n        g[b] = append(g[b], a)\n    }\n    s := map[string]struct{}{}\n    cnt := map[string]int{}\n    for _, e := range names {\n        i := strings.Index(e, \"(\")\n        name, num := e[:i], e[i+1:len(e)-1]\n        x, _ := strconv.Atoi(num)\n        cnt[name] += x\n        s[name] = struct{}{}\n    }\n    freq := 0\n    vis := map[string]struct{}{}\n    var dfs func(string) string\n    dfs = func(a string) string {\n        vis[a] = struct{}{}\n        freq += cnt[a]\n        res := a\n        for _, b := range g[a] {\n            if _, ok := vis[b]; !ok {\n                t := dfs(b)\n                if t &lt; res {\n                    res = t\n                }\n            }\n        }\n        return res\n    }\n    for name := range s {\n        if _, ok := vis[name]; !ok {\n            freq = 0\n            root := dfs(name)\n            ans = append(ans, root+\"(\"+strconv.Itoa(freq)+\")\")\n        }\n    }\n    return\n}\n</code></pre> <pre><code>function trulyMostPopular(names: string[], synonyms: string[]): string[] {\n    const map = new Map&lt;string, string&gt;();\n    for (const synonym of synonyms) {\n        const [k1, k2] = [...synonym]\n            .slice(1, synonym.length - 1)\n            .join('')\n            .split(',');\n        const [v1, v2] = [map.get(k1) ?? k1, map.get(k2) ?? k2];\n        const min = v1 &lt; v2 ? v1 : v2;\n        const max = v1 &lt; v2 ? v2 : v1;\n        map.set(k1, min);\n        map.set(k2, min);\n        for (const [k, v] of map.entries()) {\n            if (v === max) {\n                map.set(k, min);\n            }\n        }\n    }\n\n    const keyCount = new Map&lt;string, number&gt;();\n    for (const name of names) {\n        const num = name.match(/\\d+/)[0];\n        const k = name.split('(')[0];\n        const key = map.get(k) ?? k;\n        keyCount.set(key, (keyCount.get(key) ?? 0) + Number(num));\n    }\n    return [...keyCount.entries()].map(([k, v]) =&gt; `${k}(${v})`);\n}\n</code></pre>"},{"location":"lcci/17.8.html","title":"17.08. Circus Tower","text":""},{"location":"lcci/17.8.html#description","title":"Description","text":"<p>A circus is designing a tower routine consisting of people standing atop one anoth\u00ader's shoulders. For practical and aesthetic reasons, each person must be both shorter and lighter than the person below him or her. Given the heights and weights of each person in the circus, write a method to compute the largest possible number of people in such a tower.</p> <p>Example: </p> <pre>\n\nInput: height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110]\n\nOutput: 6\n\nExplanation: The longest tower is length 6 and includes from top to bottom: (56,90), (60,95), (65,100), (68,110), (70,150), (75,190)</pre> <p>Note:</p> <ul> <li><code>height.length == weight.length &lt;= 10000</code></li> </ul>"},{"location":"lcci/17.8.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.8.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x, delta):\n        while x &lt;= self.n:\n            self.c[x] = max(self.c[x], delta)\n            x += x &amp; -x\n\n    def query(self, x):\n        s = 0\n        while x:\n            s = max(s, self.c[x])\n            x -= x &amp; -x\n        return s\n\n\nclass Solution:\n    def bestSeqAtIndex(self, height: List[int], weight: List[int]) -&gt; int:\n        arr = list(zip(height, weight))\n        arr.sort(key=lambda x: (x[0], -x[1]))\n        alls = sorted({w for _, w in arr})\n        m = {w: i for i, w in enumerate(alls, 1)}\n        tree = BinaryIndexedTree(len(m))\n        ans = 1\n        for _, w in arr:\n            x = m[w]\n            t = tree.query(x - 1) + 1\n            ans = max(ans, t)\n            tree.update(x, t)\n        return ans\n</code></pre> <pre><code>class BinaryIndexedTree {\n    private int n;\n    private int[] c;\n\n    public BinaryIndexedTree(int n) {\n        this.n = n;\n        c = new int[n + 1];\n    }\n\n    public void update(int x, int val) {\n        while (x &lt;= n) {\n            this.c[x] = Math.max(this.c[x], val);\n            x += x &amp; -x;\n        }\n    }\n\n    public int query(int x) {\n        int s = 0;\n        while (x &gt; 0) {\n            s = Math.max(s, this.c[x]);\n            x -= x &amp; -x;\n        }\n        return s;\n    }\n}\n\nclass Solution {\n    public int bestSeqAtIndex(int[] height, int[] weight) {\n        int n = height.length;\n        int[][] arr = new int[n][2];\n        for (int i = 0; i &lt; n; ++i) {\n            arr[i] = new int[] {height[i], weight[i]};\n        }\n        Arrays.sort(arr, (a, b) -&gt; a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\n        Set&lt;Integer&gt; s = new HashSet&lt;&gt;();\n        for (int[] e : arr) {\n            s.add(e[1]);\n        }\n        List&lt;Integer&gt; alls = new ArrayList&lt;&gt;(s);\n        Collections.sort(alls);\n        Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;(alls.size());\n        for (int i = 0; i &lt; alls.size(); ++i) {\n            m.put(alls.get(i), i + 1);\n        }\n        BinaryIndexedTree tree = new BinaryIndexedTree(alls.size());\n        int ans = 1;\n        for (int[] e : arr) {\n            int x = m.get(e[1]);\n            int t = tree.query(x - 1) + 1;\n            ans = Math.max(ans, t);\n            tree.update(x, t);\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class BinaryIndexedTree {\npublic:\n    BinaryIndexedTree(int _n)\n        : n(_n)\n        , c(_n + 1) {}\n\n    void update(int x, int val) {\n        while (x &lt;= n) {\n            c[x] = max(c[x], val);\n            x += x &amp; -x;\n        }\n    }\n\n    int query(int x) {\n        int s = 0;\n        while (x &gt; 0) {\n            s = max(s, c[x]);\n            x -= x &amp; -x;\n        }\n        return s;\n    }\n\nprivate:\n    int n;\n    vector&lt;int&gt; c;\n};\n\nclass Solution {\npublic:\n    int bestSeqAtIndex(vector&lt;int&gt;&amp; height, vector&lt;int&gt;&amp; weight) {\n        int n = height.size();\n        vector&lt;pair&lt;int, int&gt;&gt; people;\n        for (int i = 0; i &lt; n; ++i) {\n            people.emplace_back(height[i], weight[i]);\n        }\n        sort(people.begin(), people.end(), [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) {\n            if (a.first == b.first) {\n                return a.second &gt; b.second;\n            }\n            return a.first &lt; b.first;\n        });\n        vector&lt;int&gt; alls = weight;\n        sort(alls.begin(), alls.end());\n        alls.erase(unique(alls.begin(), alls.end()), alls.end());\n        BinaryIndexedTree tree(alls.size());\n        int ans = 1;\n        for (auto&amp; [_, w] : people) {\n            int x = lower_bound(alls.begin(), alls.end(), w) - alls.begin() + 1;\n            int t = tree.query(x - 1) + 1;\n            ans = max(ans, t);\n            tree.update(x, t);\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>type BinaryIndexedTree struct {\n    n int\n    c []int\n}\n\nfunc newBinaryIndexedTree(n int) *BinaryIndexedTree {\n    c := make([]int, n+1)\n    return &amp;BinaryIndexedTree{n, c}\n}\n\nfunc (this *BinaryIndexedTree) update(x, val int) {\n    for x &lt;= this.n {\n        if this.c[x] &lt; val {\n            this.c[x] = val\n        }\n        x += x &amp; -x\n    }\n}\n\nfunc (this *BinaryIndexedTree) query(x int) int {\n    s := 0\n    for x &gt; 0 {\n        if s &lt; this.c[x] {\n            s = this.c[x]\n        }\n        x -= x &amp; -x\n    }\n    return s\n}\n\nfunc bestSeqAtIndex(height []int, weight []int) int {\n    n := len(height)\n    people := make([][2]int, n)\n    s := map[int]bool{}\n    for i := range people {\n        people[i] = [2]int{height[i], weight[i]}\n        s[weight[i]] = true\n    }\n    sort.Slice(people, func(i, j int) bool {\n        a, b := people[i], people[j]\n        return a[0] &lt; b[0] || a[0] == b[0] &amp;&amp; a[1] &gt; b[1]\n    })\n    alls := make([]int, 0, len(s))\n    for k := range s {\n        alls = append(alls, k)\n    }\n    sort.Ints(alls)\n    tree := newBinaryIndexedTree(len(alls))\n    ans := 1\n    for _, p := range people {\n        x := sort.SearchInts(alls, p[1]) + 1\n        t := tree.query(x-1) + 1\n        ans = max(ans, t)\n        tree.update(x, t)\n    }\n    return ans\n}\n</code></pre>"},{"location":"lcci/17.9.html","title":"17.09. Get Kth Magic Number","text":""},{"location":"lcci/17.9.html#description","title":"Description","text":"<p>Design an algorithm to find the kth number such that the only prime factors are 3, 5, and 7. Note that 3, 5, and 7 do not have to be factors, but it should not have any other prime factors. For example, the first several multiples would be (in order) 1, 3, 5, 7, 9, 15, 21.</p> <p>Example 1:</p> <pre>\n\nInput: k = 5\n\nOutput: 9\n\n</pre>"},{"location":"lcci/17.9.html#solutions","title":"Solutions","text":""},{"location":"lcci/17.9.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRustC <pre><code>class Solution:\n    def getKthMagicNumber(self, k: int) -&gt; int:\n        h = [1]\n        vis = {1}\n        for _ in range(k - 1):\n            cur = heappop(h)\n            for f in (3, 5, 7):\n                if (nxt := cur * f) not in vis:\n                    vis.add(nxt)\n                    heappush(h, nxt)\n        return h[0]\n</code></pre> <pre><code>class Solution {\n    private static final int[] FACTORS = new int[] {3, 5, 7};\n\n    public int getKthMagicNumber(int k) {\n        PriorityQueue&lt;Long&gt; q = new PriorityQueue&lt;&gt;();\n        Set&lt;Long&gt; vis = new HashSet&lt;&gt;();\n        q.offer(1L);\n        vis.add(1L);\n        while (--k &gt; 0) {\n            long cur = q.poll();\n            for (int f : FACTORS) {\n                long nxt = cur * f;\n                if (!vis.contains(nxt)) {\n                    q.offer(nxt);\n                    vis.add(nxt);\n                }\n            }\n        }\n        long ans = q.poll();\n        return (int) ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    const vector&lt;int&gt; factors = {3, 5, 7};\n\n    int getKthMagicNumber(int k) {\n        priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt; q;\n        unordered_set&lt;long&gt; vis;\n        q.push(1l);\n        vis.insert(1l);\n        for (int i = 0; i &lt; k - 1; ++i) {\n            long cur = q.top();\n            q.pop();\n            for (int f : factors) {\n                long nxt = cur * f;\n                if (!vis.count(nxt)) {\n                    vis.insert(nxt);\n                    q.push(nxt);\n                }\n            }\n        }\n        return (int) q.top();\n    }\n};\n</code></pre> <pre><code>func getKthMagicNumber(k int) int {\n    q := hp{[]int{1}}\n    vis := map[int]bool{1: true}\n    for i := 0; i &lt; k-1; i++ {\n        cur := heap.Pop(&amp;q).(int)\n        for _, f := range []int{3, 5, 7} {\n            nxt := cur * f\n            if !vis[nxt] {\n                vis[nxt] = true\n                heap.Push(&amp;q, nxt)\n            }\n        }\n    }\n    return q.IntSlice[0]\n}\n\ntype hp struct{ sort.IntSlice }\n\nfunc (h *hp) Push(v any) { h.IntSlice = append(h.IntSlice, v.(int)) }\nfunc (h *hp) Pop() any {\n    a := h.IntSlice\n    v := a[len(a)-1]\n    h.IntSlice = a[:len(a)-1]\n    return v\n}\n</code></pre> <pre><code>function getKthMagicNumber(k: number): number {\n    const dp = [1];\n    const index = [0, 0, 0];\n    while (dp.length &lt; k) {\n        const a = dp[index[0]] * 3;\n        const b = dp[index[1]] * 5;\n        const c = dp[index[2]] * 7;\n        const num = Math.min(a, b, c);\n        dp.push(num);\n        if (a === num) {\n            index[0]++;\n        }\n        if (b === num) {\n            index[1]++;\n        }\n        if (c === num) {\n            index[2]++;\n        }\n    }\n    return dp[k - 1];\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn get_kth_magic_number(k: i32) -&gt; i32 {\n        let k = k as usize;\n        let mut dp = vec![1];\n        let mut index = [0, 0, 0];\n        for _ in 1..k {\n            let a = dp[index[0]] * 3;\n            let b = dp[index[1]] * 5;\n            let c = dp[index[2]] * 7;\n            let num = a.min(b.min(c));\n            dp.push(num);\n            if a == num {\n                index[0] += 1;\n            }\n            if b == num {\n                index[1] += 1;\n            }\n            if c == num {\n                index[2] += 1;\n            }\n        }\n        dp[k - 1]\n    }\n}\n</code></pre> <pre><code>#define min(a, b) (((a) &lt; (b)) ? (a) : (b))\n\nint getKthMagicNumber(int k) {\n    int* dp = (int*) malloc(sizeof(int) * k);\n    dp[0] = 1;\n    int index[3] = {0, 0, 0};\n    for (int i = 1; i &lt; k; i++) {\n        int a = dp[index[0]] * 3;\n        int b = dp[index[1]] * 5;\n        int c = dp[index[2]] * 7;\n        int num = min(a, min(b, c));\n        dp[i] = num;\n        if (a == num) {\n            index[0]++;\n        }\n        if (b == num) {\n            index[1]++;\n        }\n        if (c == num) {\n            index[2]++;\n        }\n    }\n    int res = dp[k - 1];\n    free(dp);\n    return res;\n}\n</code></pre>"},{"location":"lcci/17.9.html#solution-2","title":"Solution 2","text":"Python3JavaC++Go <pre><code>class Solution:\n    def getKthMagicNumber(self, k: int) -&gt; int:\n        dp = [1] * (k + 1)\n        p3 = p5 = p7 = 1\n        for i in range(2, k + 1):\n            a, b, c = dp[p3] * 3, dp[p5] * 5, dp[p7] * 7\n            v = min(a, b, c)\n            dp[i] = v\n            if v == a:\n                p3 += 1\n            if v == b:\n                p5 += 1\n            if v == c:\n                p7 += 1\n        return dp[k]\n</code></pre> <pre><code>class Solution {\n    public int getKthMagicNumber(int k) {\n        int[] dp = new int[k + 1];\n        Arrays.fill(dp, 1);\n        int p3 = 1, p5 = 1, p7 = 1;\n        for (int i = 2; i &lt;= k; ++i) {\n            int a = dp[p3] * 3, b = dp[p5] * 5, c = dp[p7] * 7;\n            int v = Math.min(Math.min(a, b), c);\n            dp[i] = v;\n            if (v == a) {\n                ++p3;\n            }\n            if (v == b) {\n                ++p5;\n            }\n            if (v == c) {\n                ++p7;\n            }\n        }\n        return dp[k];\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int getKthMagicNumber(int k) {\n        vector&lt;int&gt; dp(k + 1, 1);\n        int p3 = 1, p5 = 1, p7 = 1;\n        for (int i = 2; i &lt;= k; ++i) {\n            int a = dp[p3] * 3, b = dp[p5] * 5, c = dp[p7] * 7;\n            int v = min(min(a, b), c);\n            dp[i] = v;\n            if (v == a) {\n                ++p3;\n            }\n            if (v == b) {\n                ++p5;\n            }\n            if (v == c) {\n                ++p7;\n            }\n        }\n        return dp[k];\n    }\n};\n</code></pre> <pre><code>func getKthMagicNumber(k int) int {\n    dp := make([]int, k+1)\n    dp[1] = 1\n    p3, p5, p7 := 1, 1, 1\n    for i := 2; i &lt;= k; i++ {\n        a, b, c := dp[p3]*3, dp[p5]*5, dp[p7]*7\n        v := min(min(a, b), c)\n        dp[i] = v\n        if v == a {\n            p3++\n        }\n        if v == b {\n            p5++\n        }\n        if v == c {\n            p7++\n        }\n    }\n    return dp[k]\n}\n</code></pre>"},{"location":"lcci/2.1.html","title":"02.01. Remove Duplicate Node","text":""},{"location":"lcci/2.1.html#description","title":"Description","text":"<p>Write code to remove duplicates from an unsorted linked list.</p> <p>Example1:</p> <pre>\n\n Input: [1, 2, 3, 3, 2, 1]\n\n Output: [1, 2, 3]\n\n</pre> <p>Example2:</p> <pre>\n\n Input: [1, 1, 1, 1, 2]\n\n Output: [1, 2]\n\n</pre> <p>Note: </p> <ol> <li>The length of the list is within the range[0, 20000].</li> <li>The values of the list elements are within the range [0, 20000].</li> </ol> <p>Follow Up: </p> <p>How would you solve this problem if a temporary buffer is not allowed?</p>"},{"location":"lcci/2.1.html#solutions","title":"Solutions","text":""},{"location":"lcci/2.1.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRustJavaScript <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:\n        if head is None or head.next is None:\n            return head\n        cache = set()\n        cache.add(head.val)\n        cur, p = head, head.next\n        while p:\n            if p.val not in cache:\n                cur.next = p\n                cur = cur.next\n                cache.add(p.val)\n            p = p.next\n        cur.next = None\n        return head\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeDuplicateNodes(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        Set&lt;Integer&gt; s = new HashSet&lt;&gt;();\n        s.add(head.val);\n        ListNode cur = head;\n        for (ListNode p = head.next; p != null; p = p.next) {\n            if (!s.contains(p.val)) {\n                cur.next = p;\n                cur = cur.next;\n                s.add(p.val);\n            }\n        }\n        cur.next = null;\n        return head;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeDuplicateNodes(ListNode* head) {\n        if (head == nullptr || head-&gt;next == nullptr) {\n            return head;\n        }\n        unordered_set&lt;int&gt; cache = {head-&gt;val};\n        ListNode* cur = head;\n        for (ListNode* p = head-&gt;next; p != nullptr; p = p-&gt;next) {\n            if (!cache.count(p-&gt;val)) {\n                cur-&gt;next = p;\n                cur = cur-&gt;next;\n                cache.insert(p-&gt;val);\n            }\n        }\n        cur-&gt;next = nullptr;\n        return head;\n    }\n};\n</code></pre> <pre><code>func removeDuplicateNodes(head *ListNode) *ListNode {\n    if head == nil {\n        return nil\n    }\n    vis := map[int]bool{head.Val: true}\n    p := head\n    for p.Next != nil {\n        if vis[p.Next.Val] {\n            p.Next = p.Next.Next\n        } else {\n            vis[p.Next.Val] = true\n            p = p.Next\n        }\n    }\n    return head\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction removeDuplicateNodes(head: ListNode | null): ListNode | null {\n    if (head == null) {\n        return head;\n    }\n    const set = new Set&lt;number&gt;([head.val]);\n    let cur = head;\n    while (cur.next != null) {\n        if (set.has(cur.next.val)) {\n            cur.next = cur.next.next;\n        } else {\n            set.add(cur.next.val);\n            cur = cur.next;\n        }\n    }\n    return head;\n}\n</code></pre> <pre><code>// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -&gt; Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nuse std::collections::HashSet;\n\nimpl Solution {\n    pub fn remove_duplicate_nodes(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n        match head {\n            None =&gt; head,\n            Some(mut head) =&gt; {\n                let mut set = HashSet::new();\n                set.insert(head.val);\n                let mut pre = &amp;mut head;\n                while let Some(cur) = &amp;pre.next {\n                    if set.contains(&amp;cur.val) {\n                        pre.next = pre.next.take().unwrap().next;\n                    } else {\n                        set.insert(cur.val);\n                        pre = pre.next.as_mut().unwrap();\n                    }\n                }\n                Some(head)\n            }\n        }\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar removeDuplicateNodes = function (head) {\n    if (head == null || head.next == null) return head;\n    const cache = new Set([]);\n    cache.add(head.val);\n    let cur = head,\n        fast = head.next;\n    while (fast !== null) {\n        if (!cache.has(fast.val)) {\n            cur.next = fast;\n            cur = cur.next;\n            cache.add(fast.val);\n        }\n        fast = fast.next;\n    }\n    cur.next = null;\n    return head;\n};\n</code></pre>"},{"location":"lcci/2.2.html","title":"02.02. Kth Node From End of List","text":""},{"location":"lcci/2.2.html#description","title":"Description","text":"<p>Implement an algorithm to find the kth to last element of a singly linked list.\u00a0Return the value of the element.</p> <p>Note: This problem is slightly different from the original one in the book.</p> <p>Example: </p> <pre>\n\nInput:  1-&gt;2-&gt;3-&gt;4-&gt;5 \u200b\u548c\u200b k = 2\n\nOutput:  4</pre> <p>Note: </p> <p>k is always valid.</p>"},{"location":"lcci/2.2.html#solutions","title":"Solutions","text":""},{"location":"lcci/2.2.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoRustJavaScript <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def kthToLast(self, head: ListNode, k: int) -&gt; int:\n        slow = fast = head\n        for _ in range(k):\n            fast = fast.next\n        while fast:\n            slow, fast = slow.next, fast.next\n        return slow.val\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int kthToLast(ListNode head, int k) {\n        ListNode slow = head, fast = head;\n        while (k-- &gt; 0) {\n            fast = fast.next;\n        }\n        while (fast != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow.val;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int kthToLast(ListNode* head, int k) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while (k-- &gt; 0) {\n            fast = fast-&gt;next;\n        }\n        while (fast) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next;\n        }\n        return slow-&gt;val;\n    }\n};\n</code></pre> <pre><code>func kthToLast(head *ListNode, k int) int {\n    slow, fast := head, head\n    for i := 0; i &lt; k; i++ {\n        fast = fast.Next\n    }\n    for fast != nil {\n        slow = slow.Next\n        fast = fast.Next\n    }\n    return slow.Val\n}\n</code></pre> <pre><code>// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -&gt; Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn kth_to_last(head: Option&lt;Box&lt;ListNode&gt;&gt;, k: i32) -&gt; i32 {\n        let mut fast = &amp;head;\n        for _ in 0..k {\n            fast = &amp;fast.as_ref().unwrap().next;\n        }\n        let mut slow = &amp;head;\n        while let (Some(f), Some(s)) = (fast, slow) {\n            fast = &amp;f.next;\n            slow = &amp;s.next;\n        }\n        slow.as_ref().unwrap().val\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {number}\n */\nvar kthToLast = function (head, k) {\n    let fast = head,\n        slow = head;\n    for (let i = 0; i &lt; k; i++) {\n        fast = fast.next;\n    }\n    while (fast != null) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return slow.val;\n};\n</code></pre>"},{"location":"lcci/2.3.html","title":"02.03. Delete Middle Node","text":""},{"location":"lcci/2.3.html#description","title":"Description","text":"<p>Implement an algorithm to delete a node in the middle (i.e., any node but the first and last node, not necessarily the exact middle) of a singly linked list, given only access to that node.</p> <p> </p> <p>Example: </p> <pre>\n\nInput: the node c from the linked list a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f\n\nOutput: nothing is returned, but the new linked list looks like a-&gt;b-&gt;d-&gt;e-&gt;f\n\n</pre>"},{"location":"lcci/2.3.html#solutions","title":"Solutions","text":""},{"location":"lcci/2.3.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoJavaScript <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def deleteNode(self, node):\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        \"\"\"\n        node.val = node.next.val\n        node.next = node.next.next\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public void deleteNode(ListNode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node-&gt;val = node-&gt;next-&gt;val;\n        node-&gt;next = node-&gt;next-&gt;next;\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc deleteNode(node *ListNode) {\n    node.Val = node.Next.Val\n    node.Next = node.Next.Next\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} node\n * @return {void} Do not return anything, modify node in-place instead.\n */\nvar deleteNode = function (node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n};\n</code></pre>"},{"location":"lcci/2.4.html","title":"02.04. Partition List","text":""},{"location":"lcci/2.4.html#description","title":"Description","text":"<p>Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater than or equal to x. If x is contained within the list, the values of x only need to be after the elements less than x (see below). The partition element x can appear anywhere in the \"right partition\"; it does not need to appear between the left and right partitions.</p> <p>Example:</p> <pre>\n\nInput: head = 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1, x = 5\n\nOutput: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8\n\n</pre>"},{"location":"lcci/2.4.html#solutions","title":"Solutions","text":""},{"location":"lcci/2.4.html#solution-1","title":"Solution 1","text":"Python3JavaC++TypeScript <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def partition(self, head: ListNode, x: int) -&gt; ListNode:\n        l1, l2 = ListNode(0), ListNode(0)\n        cur1, cur2 = l1, l2\n        while head:\n            if head.val &lt; x:\n                cur1.next = head\n                cur1 = cur1.next\n            else:\n                cur2.next = head\n                cur2 = cur2.next\n            head = head.next\n        cur1.next = l2.next\n        cur2.next = None\n        return l1.next\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        ListNode l1 = new ListNode(0);\n        ListNode l2 = new ListNode(0);\n        ListNode cur1 = l1, cur2 = l2;\n        while (head != null) {\n            if (head.val &lt; x) {\n                cur1.next = head;\n                cur1 = cur1.next;\n            } else {\n                cur2.next = head;\n                cur2 = cur2.next;\n            }\n            head = head.next;\n        }\n        cur1.next = l2.next;\n        cur2.next = null;\n        return l1.next;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode* l1 = new ListNode();\n        ListNode* l2 = new ListNode();\n        ListNode* cur1 = l1;\n        ListNode* cur2 = l2;\n        while (head != nullptr) {\n            if (head-&gt;val &lt; x) {\n                cur1-&gt;next = head;\n                cur1 = cur1-&gt;next;\n            } else {\n                cur2-&gt;next = head;\n                cur2 = cur2-&gt;next;\n            }\n            head = head-&gt;next;\n        }\n        cur1-&gt;next = l2-&gt;next;\n        cur2-&gt;next = nullptr;\n        return l1-&gt;next;\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction partition(head: ListNode | null, x: number): ListNode | null {\n    if (head == null) {\n        return head;\n    }\n    let cur = head;\n    while (cur.next != null) {\n        let node = cur.next;\n        if (node.val &lt; x) {\n            [head, node.next, cur.next] = [node, head, node.next];\n        } else {\n            cur = cur.next;\n        }\n    }\n    return head;\n}\n</code></pre>"},{"location":"lcci/2.5.html","title":"02.05. Sum Lists","text":""},{"location":"lcci/2.5.html#description","title":"Description","text":"<p>You have two numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1's digit is at the head of the list. Write a function that adds the two numbers and returns the sum as a linked list.</p> <p> </p> <p>Example: </p> <pre>\n\nInput: (7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2). That is, 617 + 295.\n\nOutput: 2 -&gt; 1 -&gt; 9. That is, 912.\n\n</pre> <p>Follow Up:\u00a0Suppose the digits are stored in forward order. Repeat the above problem.</p> <p>Example: </p> <pre>\n\nInput: (6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5). That is, 617 + 295.\n\nOutput: 9 -&gt; 1 -&gt; 2. That is, 912.\n\n</pre>"},{"location":"lcci/2.5.html#solutions","title":"Solutions","text":""},{"location":"lcci/2.5.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRustJavaScript <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:\n        dummy = cur = ListNode(0)\n        carry = 0\n        while l1 or l2 or carry:\n            carry += (0 if not l1 else l1.val) + (0 if not l2 else l2.val)\n            cur.next = ListNode(carry % 10)\n            cur = cur.next\n            carry //= 10\n            l1 = None if not l1 else l1.next\n            l2 = None if not l2 else l2.next\n        return dummy.next\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        int carry = 0;\n        ListNode dummy = new ListNode(-1);\n        ListNode cur = dummy;\n        while (l1 != null || l2 != null || carry != 0) {\n            int s = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry;\n            carry = s / 10;\n            cur.next = new ListNode(s % 10);\n            cur = cur.next;\n            l1 = l1 == null ? null : l1.next;\n            l2 = l2 == null ? null : l2.next;\n        }\n        return dummy.next;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode(0);\n        ListNode* cur = dummy;\n        int carry = 0;\n        while (l1 || l2 || carry) {\n            carry += (!l1 ? 0 : l1-&gt;val) + (!l2 ? 0 : l2-&gt;val);\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n            l1 = l1 ? l1-&gt;next : l1;\n            l2 = l2 ? l2-&gt;next : l2;\n        }\n        return dummy-&gt;next;\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    dummy := &amp;ListNode{}\n    cur := dummy\n    carry := 0\n    for l1 != nil || l2 != nil || carry &gt; 0 {\n        if l1 != nil {\n            carry += l1.Val\n            l1 = l1.Next\n        }\n        if l2 != nil {\n            carry += l2.Val\n            l2 = l2.Next\n        }\n        cur.Next = &amp;ListNode{Val: carry % 10}\n        cur = cur.Next\n        carry /= 10\n    }\n    return dummy.Next\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    if (l1 == null || l2 == null) {\n        return l1 &amp;&amp; l2;\n    }\n    const dummy = new ListNode(0);\n    let cur = dummy;\n    while (l1 != null || l2 != null) {\n        let val = 0;\n        if (l1 != null) {\n            val += l1.val;\n            l1 = l1.next;\n        }\n        if (l2 != null) {\n            val += l2.val;\n            l2 = l2.next;\n        }\n        if (cur.val &gt;= 10) {\n            cur.val %= 10;\n            val++;\n        }\n        cur.next = new ListNode(val);\n        cur = cur.next;\n    }\n    if (cur.val &gt;= 10) {\n        cur.val %= 10;\n        cur.next = new ListNode(1);\n    }\n    return dummy.next;\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn add_two_numbers(\n        mut l1: Option&lt;Box&lt;ListNode&gt;&gt;,\n        mut l2: Option&lt;Box&lt;ListNode&gt;&gt;\n    ) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n        let mut dummy = Some(Box::new(ListNode::new(0)));\n        let mut cur = dummy.as_mut();\n        while l1.is_some() || l2.is_some() {\n            let mut val = 0;\n            if let Some(node) = l1 {\n                val += node.val;\n                l1 = node.next;\n            }\n            if let Some(node) = l2 {\n                val += node.val;\n                l2 = node.next;\n            }\n            if let Some(node) = cur {\n                if node.val &gt;= 10 {\n                    val += 1;\n                    node.val %= 10;\n                }\n                node.next = Some(Box::new(ListNode::new(val)));\n                cur = node.next.as_mut();\n            }\n        }\n        if let Some(node) = cur {\n            if node.val &gt;= 10 {\n                node.val %= 10;\n                node.next = Some(Box::new(ListNode::new(1)));\n            }\n        }\n        dummy.unwrap().next\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n    let carry = 0;\n    const dummy = new ListNode(0);\n    let cur = dummy;\n    while (l1 || l2 || carry) {\n        carry += (l1?.val || 0) + (l2?.val || 0);\n        cur.next = new ListNode(carry % 10);\n        carry = Math.floor(carry / 10);\n        cur = cur.next;\n        l1 = l1?.next;\n        l2 = l2?.next;\n    }\n    return dummy.next;\n};\n</code></pre>"},{"location":"lcci/2.6.html","title":"02.06. Palindrome Linked List","text":""},{"location":"lcci/2.6.html#description","title":"Description","text":"<p>Implement a function to check if a linked list is a palindrome.</p> <p> </p> <p>Example 1: </p> <pre>\n\nInput:  1-&gt;2\n\nOutput:  false\n\n</pre> <p>Example 2: </p> <pre>\n\nInput:  1-&gt;2-&gt;2-&gt;1\n\nOutput:  true\n\n</pre> <p> </p> <p>Follow up:  Could you do it in O(n) time and O(1) space?</p>"},{"location":"lcci/2.6.html#solutions","title":"Solutions","text":""},{"location":"lcci/2.6.html#solution-1","title":"Solution 1","text":"Python3JavaGoTypeScriptJavaScriptC# <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def isPalindrome(self, head: ListNode) -&gt; bool:\n        if head is None or head.next is None:\n            return True\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        pre, cur = None, slow.next\n        while cur:\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        while pre:\n            if pre.val != head.val:\n                return False\n            pre, head = pre.next, head.next\n        return True\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) {\n            return true;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null &amp;&amp; fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode cur = slow.next;\n        slow.next = null;\n        ListNode pre = null;\n        while (cur != null) {\n            ListNode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        while (pre != null) {\n            if (pre.val != head.val) {\n                return false;\n            }\n            pre = pre.next;\n            head = head.next;\n        }\n        return true;\n    }\n}\n</code></pre> <pre><code>func isPalindrome(head *ListNode) bool {\n    if head == nil {\n        return true\n    }\n    m := mid(head)\n    temp := reverse(m.Next)\n    m.Next = nil\n    p, q := head, temp\n    res := true\n    for p != nil &amp;&amp; q != nil {\n        if p.Val != q.Val {\n            res = false\n            break\n        }\n        p = p.Next\n        q = q.Next\n    }\n    m.Next = reverse(temp)\n    return res\n}\n\nfunc mid(head *ListNode) *ListNode {\n    slow, fast := head, head.Next\n    for fast != nil &amp;&amp; fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    return slow\n}\n\nfunc reverse(head *ListNode) *ListNode {\n    var prev *ListNode = nil\n    for head != nil {\n        temp := head.Next\n        head.Next = prev\n        prev = head\n        head = temp\n    }\n    return prev\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction isPalindrome(head: ListNode | null): boolean {\n    if (head == null || head.next == null) return true;\n    // \u200b\u5feb\u6162\u200b\u6307\u9488\u200b\u5b9a\u4f4d\u200b\u5230\u200b\u4e2d\u70b9\u200b\n    let slow: ListNode = head,\n        fast: ListNode = head.next;\n    while (fast != null &amp;&amp; fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    // \u200b\u7ffb\u8f6c\u200b\u94fe\u8868\u200b\n    let cur: ListNode = slow.next;\n    slow.next = null;\n    let prev: ListNode = null;\n    while (cur != null) {\n        let t: ListNode = cur.next;\n        cur.next = prev;\n        prev = cur;\n        cur = t;\n    }\n    // \u200b\u5224\u65ad\u200b\u56de\u6587\u200b\n    while (prev != null) {\n        if (prev.val != head.val) return false;\n        prev = prev.next;\n        head = head.next;\n    }\n    return true;\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar isPalindrome = function (head) {\n    if (!head || !head.next) {\n        return true;\n    }\n    let slow = head;\n    let fast = head.next;\n    while (fast &amp;&amp; fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    let cur = slow.next;\n    slow.next = null;\n    let pre = null;\n    while (cur) {\n        let t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    while (pre) {\n        if (pre.val !== head.val) {\n            return false;\n        }\n        pre = pre.next;\n        head = head.next;\n    }\n    return true;\n};\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsPalindrome(ListNode head) {\n        if (head == null || head.next == null)\n        {\n            return true;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null &amp;&amp; fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode cur = slow.next;\n        slow.next = null;\n        ListNode pre = null;\n        while (cur != null)\n        {\n            ListNode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        while (pre != null)\n        {\n            if (pre.val != head.val)\n            {\n                return false;\n            }\n            pre = pre.next;\n            head = head.next;\n        }\n        return true;\n    }\n}\n</code></pre>"},{"location":"lcci/2.6.html#solution-2","title":"Solution 2","text":"TypeScript <pre><code>/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction isPalindrome(head: ListNode | null): boolean {\n    let root = head;\n    const dfs = (node: ListNode | null): boolean =&gt; {\n        if (node == null) {\n            return true;\n        }\n        if (dfs(node.next) &amp;&amp; node.val === root.val) {\n            root = root.next;\n            return true;\n        }\n        return false;\n    };\n    return dfs(head);\n}\n</code></pre>"},{"location":"lcci/2.7.html","title":"02.07. Intersection of Two Linked Lists","text":""},{"location":"lcci/2.7.html#description","title":"Description","text":"<p>Given two (singly) linked lists, determine if the two lists intersect. Return the inter\u00ad secting node. Note that the intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact same node (by reference) as the jth node of the second linked list, then they are intersecting.</p> <p>Example 1: </p> <pre>\n\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n\nOutput: Reference of the node with value = 8\n\nInput Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</pre> <p>Example 2: </p> <pre>\n\nInput: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n\nOutput: Reference of the node with value = 2\n\nInput Explanation:\u00a0The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</pre> <p>Example 3: </p> <pre>\n\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n\nOutput: null\n\nInput Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\n\nExplanation: The two lists do not intersect, so return null.</pre> <p>Notes:</p> <ul> <li>If the two linked lists have no intersection at all, return\u00a0<code>null</code>.</li> <li>The linked lists must retain their original structure after the function returns.</li> <li>You may assume there are no cycles anywhere in the entire linked structure.</li> <li>Your code should preferably run in O(n) time and use only O(1) memory.</li> </ul>"},{"location":"lcci/2.7.html#solutions","title":"Solutions","text":""},{"location":"lcci/2.7.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoJavaScript <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:\n        cur1, cur2 = headA, headB\n        while cur1 != cur2:\n            cur1 = headB if cur1 is None else cur1.next\n            cur2 = headA if cur2 is None else cur2.next\n        return cur1\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode cur1 = headA, cur2 = headB;\n        while (cur1 != cur2) {\n            cur1 = cur1 == null ? headB : cur1.next;\n            cur2 = cur2 == null ? headA : cur2.next;\n        }\n        return cur1;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\n        ListNode* cur1 = headA;\n        ListNode* cur2 = headB;\n        while (cur1 != cur2) {\n            cur1 = cur1 ? cur1-&gt;next : headB;\n            cur2 = cur2 ? cur2-&gt;next : headA;\n        }\n        return cur1;\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    cur1, cur2 := headA, headB\n    for cur1 != cur2 {\n        if cur1 == nil {\n            cur1 = headB\n        } else {\n            cur1 = cur1.Next\n        }\n        if cur2 == nil {\n            cur2 = headA\n        } else {\n            cur2 = cur2.Next\n        }\n    }\n    return cur1\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n    let cur1 = headA;\n    let cur2 = headB;\n    while (cur1 != cur2) {\n        cur1 = cur1 ? cur1.next : headB;\n        cur2 = cur2 ? cur2.next : headA;\n    }\n    return cur1;\n};\n</code></pre>"},{"location":"lcci/2.8.html","title":"02.08. Linked List Cycle","text":""},{"location":"lcci/2.8.html#description","title":"Description","text":"<p>Given a circular linked list, implement an algorithm that returns the node at the beginning of the loop.</p> <p>Circular linked list: A (corrupt) linked list in which a node's next pointer points to an earlier node, so as to make a loop in the linked list.</p> <p>Example 1: </p> <pre>\n\nInput: head = [3,2,0,-4], pos = 1\n\nOutput: tail connects to node index 1</pre> <p>Example 2: </p> <pre>\n\nInput: head = [1,2], pos = 0\n\nOutput: tail connects to node index 0</pre> <p>Example 3: </p> <pre>\n\nInput: head = [1], pos = -1\n\nOutput: no cycle</pre> <p>Follow Up:   Can you solve it without using additional space?</p>"},{"location":"lcci/2.8.html#solutions","title":"Solutions","text":""},{"location":"lcci/2.8.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoJavaScript <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -&gt; ListNode:\n        slow = fast = head\n        has_cycle = False\n        while not has_cycle and fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            has_cycle = slow == fast\n        if not has_cycle:\n            return None\n        p = head\n        while p != slow:\n            p, slow = p.next, slow.next\n        return p\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        boolean hasCycle = false;\n        while (!hasCycle &amp;&amp; fast != null &amp;&amp; fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            hasCycle = slow == fast;\n        }\n        if (!hasCycle) {\n            return null;\n        }\n        ListNode p = head;\n        while (p != slow) {\n            p = p.next;\n            slow = slow.next;\n        }\n        return p;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* detectCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        bool hasCycle = false;\n        while (!hasCycle &amp;&amp; fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n            hasCycle = slow == fast;\n        }\n        if (!hasCycle) {\n            return nullptr;\n        }\n        ListNode* p = head;\n        while (p != slow) {\n            p = p-&gt;next;\n            slow = slow-&gt;next;\n        }\n        return p;\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    slow, fast := head, head\n    hasCycle := false\n    for !hasCycle &amp;&amp; fast != nil &amp;&amp; fast.Next != nil {\n        slow, fast = slow.Next, fast.Next.Next\n        hasCycle = slow == fast\n    }\n    if !hasCycle {\n        return nil\n    }\n    p := head\n    for p != slow {\n        p, slow = p.Next, slow.Next\n    }\n    return p\n}\n</code></pre> <pre><code>/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function (head) {\n    let slow = head;\n    let fast = head;\n    let hasCycle = false;\n    while (!hasCycle &amp;&amp; fast &amp;&amp; fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        hasCycle = slow == fast;\n    }\n    if (!hasCycle) {\n        return null;\n    }\n    let p = head;\n    while (p != slow) {\n        p = p.next;\n        slow = slow.next;\n    }\n    return p;\n};\n</code></pre>"},{"location":"lcci/3.1.html","title":"03.01. Three in One","text":""},{"location":"lcci/3.1.html#description","title":"Description","text":"<p>Describe how you could use a single array to implement three stacks.</p> <p>Yout should implement\u00a0<code>push(stackNum, value)</code>\u3001<code>pop(stackNum)</code>\u3001<code>isEmpty(stackNum)</code>\u3001<code>peek(stackNum)</code>\u00a0methods.\u00a0<code>stackNum </code>is the index of the stack.\u00a0<code>value</code>\u00a0is the value that pushed to the stack.</p> <p>The constructor requires a\u00a0<code>stackSize</code>\u00a0parameter, which represents the size of each stack.</p> <p>Example1:</p> <pre>\n\n Input:\n\n[\"TripleInOne\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"isEmpty\"]\n\n[[1], [0, 1], [0, 2], [0], [0], [0], [0]]\n\n Output:\n\n[null, null, null, 1, -1, -1, true]\n\nExplanation: When the stack is empty, `pop, peek` return -1. When the stack is full, `push` does nothing.\n\n</pre> <p>Example2:</p> <pre>\n\n Input:\n\n[\"TripleInOne\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"peek\"]\n\n[[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]\n\n Output:\n\n[null, null, null, null, 2, 1, -1, -1]\n\n</pre>"},{"location":"lcci/3.1.html#solutions","title":"Solutions","text":""},{"location":"lcci/3.1.html#solution-1","title":"Solution 1","text":"Python3JavaGo <pre><code>class TripleInOne:\n    def __init__(self, stackSize: int):\n        self._capacity = stackSize\n        self._s = [[], [], []]\n\n    def push(self, stackNum: int, value: int) -&gt; None:\n        if len(self._s[stackNum]) &lt; self._capacity:\n            self._s[stackNum].append(value)\n\n    def pop(self, stackNum: int) -&gt; int:\n        return -1 if self.isEmpty(stackNum) else self._s[stackNum].pop()\n\n    def peek(self, stackNum: int) -&gt; int:\n        return -1 if self.isEmpty(stackNum) else self._s[stackNum][-1]\n\n    def isEmpty(self, stackNum: int) -&gt; bool:\n        return len(self._s[stackNum]) == 0\n\n\n# Your TripleInOne object will be instantiated and called as such:\n# obj = TripleInOne(stackSize)\n# obj.push(stackNum,value)\n# param_2 = obj.pop(stackNum)\n# param_3 = obj.peek(stackNum)\n# param_4 = obj.isEmpty(stackNum)\n</code></pre> <pre><code>class TripleInOne {\n    private int[] s;\n    private int capacity;\n\n    public TripleInOne(int stackSize) {\n        s = new int[stackSize * 3 + 3];\n        capacity = stackSize;\n    }\n\n    public void push(int stackNum, int value) {\n        if (s[stackNum + 3 * capacity] &lt; capacity) {\n            s[s[stackNum + 3 * capacity] * 3 + stackNum] = value;\n            ++s[stackNum + 3 * capacity];\n        }\n    }\n\n    public int pop(int stackNum) {\n        if (isEmpty(stackNum)) {\n            return -1;\n        }\n        --s[stackNum + 3 * capacity];\n        return s[s[stackNum + 3 * capacity] * 3 + stackNum];\n    }\n\n    public int peek(int stackNum) {\n        return isEmpty(stackNum) ? -1 : s[(s[stackNum + 3 * capacity] - 1) * 3 + stackNum];\n    }\n\n    public boolean isEmpty(int stackNum) {\n        return s[stackNum + 3 * capacity] == 0;\n    }\n}\n\n/**\n * Your TripleInOne object will be instantiated and called as such:\n * TripleInOne obj = new TripleInOne(stackSize);\n * obj.push(stackNum,value);\n * int param_2 = obj.pop(stackNum);\n * int param_3 = obj.peek(stackNum);\n * boolean param_4 = obj.isEmpty(stackNum);\n */\n</code></pre> <pre><code>type TripleInOne struct {\n    data      []int\n    offset    [3]int\n    stackSize int\n}\n\nfunc Constructor(stackSize int) TripleInOne {\n    total := stackSize * 3\n    data := make([]int, total)\n    offset := [3]int{}\n    for i := 0; i &lt; 3; i++ {\n        offset[i] = i * stackSize\n    }\n    return TripleInOne{\n        data:      data,\n        offset:    offset,\n        stackSize: stackSize,\n    }\n}\n\nfunc (this *TripleInOne) Push(stackNum int, value int) {\n    i := this.offset[stackNum]\n    if i &lt; (stackNum+1)*this.stackSize {\n        this.data[i] = value\n        this.offset[stackNum]++\n    }\n}\n\nfunc (this *TripleInOne) Pop(stackNum int) int {\n    i := this.offset[stackNum]\n    if i == stackNum*this.stackSize {\n        return -1\n    }\n    this.offset[stackNum]--\n    return this.data[i-1]\n}\n\nfunc (this *TripleInOne) Peek(stackNum int) int {\n    i := this.offset[stackNum]\n    if i == stackNum*this.stackSize {\n        return -1\n    }\n    return this.data[i-1]\n}\n\nfunc (this *TripleInOne) IsEmpty(stackNum int) bool {\n    return this.offset[stackNum] == stackNum*this.stackSize\n}\n\n/**\n * Your TripleInOne object will be instantiated and called as such:\n * obj := Constructor(stackSize);\n * obj.Push(stackNum,value);\n * param_2 := obj.Pop(stackNum);\n * param_3 := obj.Peek(stackNum);\n * param_4 := obj.IsEmpty(stackNum);\n */\n</code></pre>"},{"location":"lcci/3.2.html","title":"03.02. Min Stack","text":""},{"location":"lcci/3.2.html#description","title":"Description","text":"<p>How would you design a stack which, in addition to push and pop, has a function min which returns the minimum element? Push, pop and min should all operate in 0(1) time.</p> <p>Example: </p> <pre>\n\nMinStack minStack = new MinStack();\n\nminStack.push(-2);\n\nminStack.push(0);\n\nminStack.push(-3);\n\nminStack.getMin();   --&gt; return -3.\n\nminStack.pop();\n\nminStack.top();      --&gt; return 0.\n\nminStack.getMin();   --&gt; return -2.</pre>"},{"location":"lcci/3.2.html#solutions","title":"Solutions","text":""},{"location":"lcci/3.2.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRustC# <pre><code>class MinStack:\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.s = []\n        self.mins = [inf]\n\n    def push(self, val: int) -&gt; None:\n        self.s.append(val)\n        self.mins.append(min(self.mins[-1], val))\n\n    def pop(self) -&gt; None:\n        self.s.pop()\n        self.mins.pop()\n\n    def top(self) -&gt; int:\n        return self.s[-1]\n\n    def getMin(self) -&gt; int:\n        return self.mins[-1]\n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()\n</code></pre> <pre><code>class MinStack {\n    private Deque&lt;Integer&gt; stk1 = new ArrayDeque&lt;&gt;();\n    private Deque&lt;Integer&gt; stk2 = new ArrayDeque&lt;&gt;();\n\n    /** initialize your data structure here. */\n    public MinStack() {\n        stk2.push(Integer.MAX_VALUE);\n    }\n\n    public void push(int x) {\n        stk1.push(x);\n        stk2.push(Math.min(x, stk2.peek()));\n    }\n\n    public void pop() {\n        stk1.pop();\n        stk2.pop();\n    }\n\n    public int top() {\n        return stk1.peek();\n    }\n\n    public int getMin() {\n        return stk2.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n</code></pre> <pre><code>class MinStack {\npublic:\n    /** initialize your data structure here. */\n    MinStack() {\n        stk2.push(INT_MAX);\n    }\n\n    void push(int x) {\n        stk1.push(x);\n        stk2.push(min(x, stk2.top()));\n    }\n\n    void pop() {\n        stk1.pop();\n        stk2.pop();\n    }\n\n    int top() {\n        return stk1.top();\n    }\n\n    int getMin() {\n        return stk2.top();\n    }\n\nprivate:\n    stack&lt;int&gt; stk1;\n    stack&lt;int&gt; stk2;\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj-&gt;push(x);\n * obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * int param_4 = obj-&gt;getMin();\n */\n</code></pre> <pre><code>type MinStack struct {\n    stk1 []int\n    stk2 []int\n}\n\n/** initialize your data structure here. */\nfunc Constructor() MinStack {\n    return MinStack{[]int{}, []int{math.MaxInt32}}\n}\n\nfunc (this *MinStack) Push(x int) {\n    this.stk1 = append(this.stk1, x)\n    this.stk2 = append(this.stk2, min(x, this.stk2[len(this.stk2)-1]))\n}\n\nfunc (this *MinStack) Pop() {\n    this.stk1 = this.stk1[:len(this.stk1)-1]\n    this.stk2 = this.stk2[:len(this.stk2)-1]\n}\n\nfunc (this *MinStack) Top() int {\n    return this.stk1[len(this.stk1)-1]\n}\n\nfunc (this *MinStack) GetMin() int {\n    return this.stk2[len(this.stk2)-1]\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.GetMin();\n */\n</code></pre> <pre><code>class MinStack {\n    stack: number[];\n    mins: number[];\n    constructor() {\n        this.stack = [];\n        this.mins = [];\n    }\n\n    push(x: number): void {\n        this.stack.push(x);\n        this.mins.push(Math.min(this.getMin(), x));\n    }\n\n    pop(): void {\n        this.stack.pop();\n        this.mins.pop();\n    }\n\n    top(): number {\n        return this.stack[this.stack.length - 1];\n    }\n\n    getMin(): number {\n        return this.mins.length == 0 ? Infinity : this.mins[this.mins.length - 1];\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(x)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */\n</code></pre> <pre><code>use std::collections::VecDeque;\nstruct MinStack {\n    stack: VecDeque&lt;i32&gt;,\n    min_stack: VecDeque&lt;i32&gt;,\n}\n\n/**\n * `&amp;self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&amp;mut self` instead.\n */\nimpl MinStack {\n    /** initialize your data structure here. */\n    fn new() -&gt; Self {\n        Self { stack: VecDeque::new(), min_stack: VecDeque::new() }\n    }\n\n    fn push(&amp;mut self, x: i32) {\n        self.stack.push_back(x);\n        if self.min_stack.is_empty() || *self.min_stack.back().unwrap() &gt;= x {\n            self.min_stack.push_back(x);\n        }\n    }\n\n    fn pop(&amp;mut self) {\n        let val = self.stack.pop_back().unwrap();\n        if *self.min_stack.back().unwrap() == val {\n            self.min_stack.pop_back();\n        }\n    }\n\n    fn top(&amp;self) -&gt; i32 {\n        *self.stack.back().unwrap()\n    }\n\n    fn get_min(&amp;self) -&gt; i32 {\n        *self.min_stack.back().unwrap()\n    }\n}/**\n * Your MinStack object will be instantiated and called as such:\n * let obj = MinStack::new();\n * obj.push(x);\n * obj.pop();\n * let ret_3: i32 = obj.top();\n * let ret_4: i32 = obj.get_min();\n */\n</code></pre> <pre><code>public class MinStack {\n    private Stack&lt;int&gt; stk1 = new Stack&lt;int&gt;();\n    private Stack&lt;int&gt; stk2 = new Stack&lt;int&gt;();\n\n    /** initialize your data structure here. */\n    public MinStack() {\n        stk2.Push(int.MaxValue);\n    }\n\n    public void Push(int x) {\n        stk1.Push(x);\n        stk2.Push(Math.Min(x, GetMin()));\n    }\n\n    public void Pop() {\n        stk1.Pop();\n        stk2.Pop();\n    }\n\n    public int Top() {\n        return stk1.Peek();\n    }\n\n    public int GetMin() {\n        return stk2.Peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.Push(x);\n * obj.Pop();\n * int param_3 = obj.Top();\n * int param_4 = obj.GetMin();\n */\n</code></pre>"},{"location":"lcci/3.3.html","title":"03.03. Stack of Plates","text":""},{"location":"lcci/3.3.html#description","title":"Description","text":"<p>Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure <code>SetOfStacks</code> that mimics this.\u00a0<code>SetOfStacks</code> should be composed of several stacks and should create a new stack once the previous one exceeds capacity. <code>SetOfStacks.push()</code> and <code>SetOfStacks.pop()</code> should behave identically to a single stack (that is, <code>pop()</code> should return the same values as it would if there were just a single stack). Follow Up: Implement a function <code>popAt(int index)</code> which performs a pop operation on a specific sub-stack.</p> <p>You should delete the sub-stack when it becomes empty. <code>pop</code>, <code>popAt</code> should return -1 when there's no element to pop.</p> <p>Example1:</p> <pre>\n\n Input:\n\n[\"StackOfPlates\", \"push\", \"push\", \"popAt\", \"pop\", \"pop\"]\n\n[[1], [1], [2], [1], [], []]\n\n Output:\n\n[null, null, null, 2, 1, -1]\n\n Explanation:\n\n</pre> <p>Example2:</p> <pre>\n\n Input:\n\n[\"StackOfPlates\", \"push\", \"push\", \"push\", \"popAt\", \"popAt\", \"popAt\"]\n\n[[2], [1], [2], [3], [0], [0], [0]]\n\n Output:\n\n[null, null, null, null, 2, 1, 3]\n\n</pre>"},{"location":"lcci/3.3.html#solutions","title":"Solutions","text":""},{"location":"lcci/3.3.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScript <pre><code>class StackOfPlates:\n    def __init__(self, cap: int):\n        self.cap = cap\n        self.stk = []\n\n    def push(self, val: int) -&gt; None:\n        if self.cap == 0:\n            return\n        if not self.stk or len(self.stk[-1]) &gt;= self.cap:\n            self.stk.append([])\n        self.stk[-1].append(val)\n\n    def pop(self) -&gt; int:\n        return self.popAt(len(self.stk) - 1)\n\n    def popAt(self, index: int) -&gt; int:\n        ans = -1\n        if 0 &lt;= index &lt; len(self.stk):\n            ans = self.stk[index].pop()\n            if not self.stk[index]:\n                self.stk.pop(index)\n        return ans\n\n\n# Your StackOfPlates object will be instantiated and called as such:\n# obj = StackOfPlates(cap)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAt(index)\n</code></pre> <pre><code>class StackOfPlates {\n    private List&lt;Deque&lt;Integer&gt;&gt; stk = new ArrayList&lt;&gt;();\n    private int cap;\n\n    public StackOfPlates(int cap) {\n        this.cap = cap;\n    }\n\n    public void push(int val) {\n        if (cap == 0) {\n            return;\n        }\n        if (stk.isEmpty() || stk.get(stk.size() - 1).size() &gt;= cap) {\n            stk.add(new ArrayDeque&lt;&gt;());\n        }\n        stk.get(stk.size() - 1).push(val);\n    }\n\n    public int pop() {\n        return popAt(stk.size() - 1);\n    }\n\n    public int popAt(int index) {\n        int ans = -1;\n        if (index &gt;= 0 &amp;&amp; index &lt; stk.size()) {\n            ans = stk.get(index).pop();\n            if (stk.get(index).isEmpty()) {\n                stk.remove(index);\n            }\n        }\n        return ans;\n    }\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * StackOfPlates obj = new StackOfPlates(cap);\n * obj.push(val);\n * int param_2 = obj.pop();\n * int param_3 = obj.popAt(index);\n */\n</code></pre> <pre><code>class StackOfPlates {\npublic:\n    StackOfPlates(int cap) {\n        this-&gt;cap = cap;\n    }\n\n    void push(int val) {\n        if (!cap) return;\n        if (stk.empty() || stk[stk.size() - 1].size() &gt;= cap) stk.emplace_back(stack&lt;int&gt;());\n        stk[stk.size() - 1].push(val);\n    }\n\n    int pop() {\n        return popAt(stk.size() - 1);\n    }\n\n    int popAt(int index) {\n        int ans = -1;\n        if (index &gt;= 0 &amp;&amp; index &lt; stk.size()) {\n            ans = stk[index].top();\n            stk[index].pop();\n            if (stk[index].empty()) {\n                stk.erase(stk.begin() + index);\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    vector&lt;stack&lt;int&gt;&gt; stk;\n    int cap;\n};\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * StackOfPlates* obj = new StackOfPlates(cap);\n * obj-&gt;push(val);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;popAt(index);\n */\n</code></pre> <pre><code>type StackOfPlates struct {\n    stk [][]int\n    cap int\n}\n\nfunc Constructor(cap int) StackOfPlates {\n    return StackOfPlates{[][]int{}, cap}\n}\n\nfunc (this *StackOfPlates) Push(val int) {\n    if this.cap == 0 {\n        return\n    }\n    if len(this.stk) == 0 || len(this.stk[len(this.stk)-1]) &gt;= this.cap {\n        this.stk = append(this.stk, []int{})\n    }\n    this.stk[len(this.stk)-1] = append(this.stk[len(this.stk)-1], val)\n}\n\nfunc (this *StackOfPlates) Pop() int {\n    return this.PopAt(len(this.stk) - 1)\n}\n\nfunc (this *StackOfPlates) PopAt(index int) int {\n    ans := -1\n    if index &gt;= 0 &amp;&amp; index &lt; len(this.stk) {\n        t := this.stk[index]\n        ans = t[len(t)-1]\n        this.stk[index] = this.stk[index][:len(t)-1]\n        if len(this.stk[index]) == 0 {\n            this.stk = append(this.stk[:index], this.stk[index+1:]...)\n        }\n    }\n    return ans\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * obj := Constructor(cap);\n * obj.Push(val);\n * param_2 := obj.Pop();\n * param_3 := obj.PopAt(index);\n */\n</code></pre> <pre><code>class StackOfPlates {\n    private cap: number;\n    private stacks: number[][];\n    constructor(cap: number) {\n        this.cap = cap;\n        this.stacks = [];\n    }\n    push(val: number): void {\n        if (this.cap === 0) {\n            return;\n        }\n        const n = this.stacks.length;\n        const stack = this.stacks[n - 1];\n        if (stack == null || stack.length === this.cap) {\n            this.stacks.push([val]);\n        } else {\n            stack.push(val);\n        }\n    }\n    pop(): number {\n        const n = this.stacks.length;\n        if (n === 0) {\n            return -1;\n        }\n        const stack = this.stacks[n - 1];\n        const res = stack.pop();\n        if (stack.length === 0) {\n            this.stacks.pop();\n        }\n        return res;\n    }\n    popAt(index: number): number {\n        if (index &gt;= this.stacks.length) {\n            return -1;\n        }\n        const stack = this.stacks[index];\n        const res = stack.pop();\n        if (stack.length === 0) {\n            this.stacks.splice(index, 1);\n        }\n        return res;\n    }\n}\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * var obj = new StackOfPlates(cap)\n * obj.push(val)\n * var param_2 = obj.pop()\n * var param_3 = obj.popAt(index)\n */\n</code></pre>"},{"location":"lcci/3.4.html","title":"03.04. Implement Queue using Stacks","text":""},{"location":"lcci/3.4.html#description","title":"Description","text":"<p>Implement a MyQueue class which implements a queue using two stacks.</p> <p> </p> <p>Example: </p> <pre>\n\nMyQueue queue = new MyQueue();\n\n\n\nqueue.push(1);\n\nqueue.push(2);\n\nqueue.peek();  // return 1\n\nqueue.pop();   // return 1\n\nqueue.empty(); // return false</pre> <p> </p> <p>Notes:</p> <ul> <li>You must use\u00a0only\u00a0standard operations of a stack -- which means only\u00a0<code>push to top</code>,\u00a0<code>peek/pop from top</code>,\u00a0<code>size</code>, and\u00a0<code>is empty</code>\u00a0operations are valid.</li> <li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li> <li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li> </ul> <p> </p>"},{"location":"lcci/3.4.html#solutions","title":"Solutions","text":""},{"location":"lcci/3.4.html#solution-1","title":"Solution 1","text":"Python3JavaGoTypeScript <pre><code>class MyQueue:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self._s1, self._s2 = [], []\n\n    def push(self, x: int) -&gt; None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self._s1.append(x)\n\n    def pop(self) -&gt; int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if len(self._s2) == 0:\n            while self._s1:\n                self._s2.append(self._s1.pop())\n        return self._s2.pop()\n\n    def peek(self) -&gt; int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if len(self._s2) == 0:\n            while self._s1:\n                self._s2.append(self._s1.pop())\n        return self._s2[-1]\n\n    def empty(self) -&gt; bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self._s1) + len(self._s2) == 0\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n</code></pre> <pre><code>class MyQueue {\n    private Stack&lt;Integer&gt; s1;\n    private Stack&lt;Integer&gt; s2;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        s1 = new Stack&lt;&gt;();\n        s2 = new Stack&lt;&gt;();\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        s1.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (s2.empty()) {\n            while (!s1.empty()) {\n                s2.push(s1.pop());\n            }\n        }\n        return s2.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        if (s2.empty()) {\n            while (!s1.empty()) {\n                s2.push(s1.pop());\n            }\n        }\n        return s2.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return s1.empty() &amp;&amp; s2.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n</code></pre> <pre><code>type MyQueue struct {\n    s1, s2 []int\n}\n\n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n    return MyQueue{\n        s1: make([]int, 0),\n        s2: make([]int, 0),\n    }\n}\n\n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int) {\n    this.s1 = append(this.s1, x)\n}\n\n/** Removes the element from in front of queue and returns that element. */\nfunc (this *MyQueue) Pop() int {\n    if len(this.s2) == 0 {\n        this.transfer()\n    }\n    v := this.s2[len(this.s2)-1]\n    this.s2 = this.s2[:len(this.s2)-1]\n    return v\n}\n\n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {\n    if len(this.s2) == 0 {\n        this.transfer()\n    }\n    return this.s2[len(this.s2)-1]\n}\n\n/** Returns whether the queue is empty. */\nfunc (this *MyQueue) Empty() bool {\n    return len(this.s1) == 0 &amp;&amp; len(this.s2) == 0\n}\n\nfunc (this *MyQueue) transfer() {\n    for len(this.s1) &gt; 0 {\n        this.s2 = append(this.s2, this.s1[len(this.s1)-1])\n        this.s1 = this.s1[:len(this.s1)-1]\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */\n</code></pre> <pre><code>class MyQueue {\n    private inStack: number[];\n    private outStack: number[];\n\n    constructor() {\n        this.inStack = [];\n        this.outStack = [];\n    }\n\n    push(x: number): void {\n        this.inStack.push(x);\n    }\n\n    pop(): number {\n        if (this.outStack.length === 0) {\n            this.inToOut();\n        }\n        return this.outStack.pop() ?? -1;\n    }\n\n    peek(): number {\n        if (this.outStack.length === 0) {\n            this.inToOut();\n        }\n        return this.outStack[this.outStack.length - 1] ?? -1;\n    }\n\n    empty(): boolean {\n        return this.inStack.length === 0 &amp;&amp; this.outStack.length === 0;\n    }\n\n    inToOut() {\n        while (this.inStack.length !== 0) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n</code></pre>"},{"location":"lcci/3.5.html","title":"03.05. Sort of Stacks","text":""},{"location":"lcci/3.5.html#description","title":"Description","text":"<p>Write a program to sort a stack such that the smallest items are on the top. You can use an additional temporary stack, but you may not copy the elements into any other data structure (such as an array). The stack supports the following operations: <code>push</code>, <code>pop</code>, <code>peek</code>, and <code>isEmpty</code>. When the stack is empty, <code>peek</code> should return -1.</p> <p>Example1:</p> <pre>\n\n Input:\n\n[\"SortedStack\", \"push\", \"push\", \"peek\", \"pop\", \"peek\"]\n\n[[], [1], [2], [], [], []]\n\n Output:\n\n[null,null,null,1,null,2]\n\n</pre> <p>Example2:</p> <pre>\n\n Input:\n\n[\"SortedStack\", \"pop\", \"pop\", \"push\", \"pop\", \"isEmpty\"]\n\n[[], [], [], [1], [], []]\n\n Output:\n\n[null,null,null,null,null,true]\n\n</pre> <p>Note:</p> <ol> <li>The total number of elements in the stack is within the range [0, 5000].</li> </ol>"},{"location":"lcci/3.5.html#solutions","title":"Solutions","text":""},{"location":"lcci/3.5.html#solution-1","title":"Solution 1","text":"Python3JavaGoTypeScriptRust <pre><code>class SortedStack:\n    def __init__(self):\n        self.s = []\n\n    def push(self, val: int) -&gt; None:\n        t = []\n        while not self.isEmpty() and self.s[-1] &lt; val:\n            t.append(self.s.pop())\n        self.s.append(val)\n        while len(t) &gt; 0:\n            self.s.append(t.pop())\n\n    def pop(self) -&gt; None:\n        if not self.isEmpty():\n            self.s.pop()\n\n    def peek(self) -&gt; int:\n        return -1 if self.isEmpty() else self.s[-1]\n\n    def isEmpty(self) -&gt; bool:\n        return len(self.s) == 0\n</code></pre> <pre><code>class SortedStack {\n    private Stack&lt;Integer&gt; s;\n    public SortedStack() {\n        s = new Stack&lt;&gt;();\n    }\n\n    public void push(int val) {\n        Stack&lt;Integer&gt; t = new Stack&lt;&gt;();\n        while (!isEmpty() &amp;&amp; s.peek() &lt; val) {\n            t.push(s.pop());\n        }\n        s.push(val);\n        while (!t.isEmpty()) {\n            s.push(t.pop());\n        }\n    }\n\n    public void pop() {\n        if (!isEmpty()) {\n            s.pop();\n        }\n    }\n\n    public int peek() {\n        return isEmpty() ? -1 : s.peek();\n    }\n\n    public boolean isEmpty() {\n        return s.isEmpty();\n    }\n}\n\n/**\n * Your SortedStack object will be instantiated and called as such:\n * SortedStack obj = new SortedStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.isEmpty();\n */\n</code></pre> <pre><code>type SortedStack struct {\n    data []int\n}\n\nfunc Constructor() SortedStack {\n    return SortedStack{make([]int, 0)}\n}\n\nfunc (s *SortedStack) Push(val int) {\n    temp := make([]int, 0)\n    for !s.IsEmpty() &amp;&amp; s.Peek() &lt; val {\n        temp = append(temp, s.Peek())\n        s.Pop()\n    }\n    s.data = append(s.data, val)\n    for len(temp) &gt; 0 {\n        s.data = append(s.data, temp[len(temp)-1])\n        temp = temp[:len(temp)-1]\n    }\n}\n\nfunc (s *SortedStack) Pop() {\n    if !s.IsEmpty() {\n        s.data = s.data[:len(s.data)-1]\n    }\n}\n\nfunc (s *SortedStack) Peek() int {\n    if !s.IsEmpty() {\n        return s.data[len(s.data)-1]\n    }\n    return -1\n}\n\nfunc (s *SortedStack) IsEmpty() bool {\n    return len(s.data) == 0\n}\n</code></pre> <pre><code>class SortedStack {\n    stack: number[];\n    constructor() {\n        this.stack = [];\n    }\n\n    push(val: number): void {\n        let t = [];\n        while (!this.isEmpty() &amp;&amp; this.peek() &lt; val) {\n            t.push(this.stack.pop());\n        }\n        this.stack.push(val);\n        while (t.length &gt; 0) {\n            this.stack.push(t.pop());\n        }\n    }\n\n    pop(): void {\n        this.stack.pop();\n    }\n\n    peek(): number {\n        return this.isEmpty() ? -1 : this.stack[this.stack.length - 1];\n    }\n\n    isEmpty(): boolean {\n        return this.stack.length == 0;\n    }\n}\n\n/**\n * Your SortedStack object will be instantiated and called as such:\n * var obj = new SortedStack()\n * obj.push(val)\n * obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.isEmpty()\n */\n</code></pre> <pre><code>use std::collections::VecDeque;\nstruct SortedStack {\n    stack: VecDeque&lt;i32&gt;,\n}\n\n/**\n * `&amp;self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&amp;mut self` instead.\n */\nimpl SortedStack {\n    fn new() -&gt; Self {\n        Self { stack: VecDeque::new() }\n    }\n\n    fn push(&amp;mut self, val: i32) {\n        if self.is_empty() || self.peek() &gt; val {\n            self.stack.push_back(val);\n            return;\n        }\n        let t = self.stack.pop_back().unwrap();\n        self.push(val);\n        self.stack.push_back(t);\n    }\n\n    fn pop(&amp;mut self) {\n        self.stack.pop_back();\n    }\n\n    fn peek(&amp;self) -&gt; i32 {\n        *self.stack.back().unwrap_or(&amp;-1)\n    }\n\n    fn is_empty(&amp;self) -&gt; bool {\n        self.stack.is_empty()\n    }\n}/**\n * Your SortedStack object will be instantiated and called as such:\n * let obj = SortedStack::new();\n * obj.push(val);\n * obj.pop();\n * let ret_3: i32 = obj.peek();\n * let ret_4: bool = obj.is_empty();\n */\n</code></pre>"},{"location":"lcci/3.5.html#solution-2","title":"Solution 2","text":"TypeScript <pre><code>class SortedStack {\n    private stack: number[];\n\n    constructor() {\n        this.stack = [];\n    }\n\n    push(val: number): void {\n        if (this.isEmpty() || this.peek() &gt; val) {\n            this.stack.push(val);\n            return;\n        }\n\n        const tmp = this.stack.pop();\n        this.push(val);\n        this.stack.push(tmp);\n    }\n\n    pop(): void {\n        this.stack.pop();\n    }\n\n    peek(): number {\n        return this.stack[this.stack.length - 1] ?? -1;\n    }\n\n    isEmpty(): boolean {\n        return this.stack.length === 0;\n    }\n}\n\n/**\n * Your SortedStack object will be instantiated and called as such:\n * var obj = new SortedStack()\n * obj.push(val)\n * obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.isEmpty()\n */\n</code></pre>"},{"location":"lcci/3.6.html","title":"03.06. Animal Shelter","text":""},{"location":"lcci/3.6.html#description","title":"Description","text":"<p>An animal shelter, which holds only dogs and cats, operates on a strictly\"first in, first out\" basis. People must adopt either the\"oldest\" (based on arrival time) of all animals at the shelter, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like. Create the data structures to maintain this system and implement operations such as <code>enqueue</code>, <code>dequeueAny</code>, <code>dequeueDog</code>, and <code>dequeueCat</code>. You may use the built-in Linked list data structure.</p> <p><code>enqueue</code> method has a <code>animal</code> parameter, <code>animal[0]</code> represents the number of the animal, <code>animal[1]</code> represents the type of the animal, 0 for cat and 1 for dog.</p> <p><code>dequeue*</code> method returns <code>[animal number, animal type]</code>, if there's no animal that can be adopted, return <code>[-1, -1]</code>.</p> <p>Example1:</p> <pre>\n\n Input: \n\n[\"AnimalShelf\", \"enqueue\", \"enqueue\", \"dequeueCat\", \"dequeueDog\", \"dequeueAny\"]\n\n[[], [[0, 0]], [[1, 0]], [], [], []]\n\n Output: \n\n[null,null,null,[0,0],[-1,-1],[1,0]]\n\n</pre> <p>Example2:</p> <pre>\n\n Input: \n\n[\"AnimalShelf\", \"enqueue\", \"enqueue\", \"enqueue\", \"dequeueDog\", \"dequeueCat\", \"dequeueAny\"]\n\n[[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []]\n\n Output: \n\n[null,null,null,null,[2,1],[0,0],[1,0]]\n\n</pre> <p>Note:</p> <ol> <li>The number of animals in the shelter will not exceed 20000.</li> </ol>"},{"location":"lcci/3.6.html#solutions","title":"Solutions","text":""},{"location":"lcci/3.6.html#solution-1","title":"Solution 1","text":"Python3JavaTypeScriptRust <pre><code>class AnimalShelf:\n    def __init__(self):\n        self.cats = []\n        self.dogs = []\n\n    def enqueue(self, animal: List[int]) -&gt; None:\n        if animal[1] == 0:\n            self.cats.insert(0, animal[0])\n        else:\n            self.dogs.insert(0, animal[0])\n\n    def dequeueAny(self) -&gt; List[int]:\n        if len(self.dogs) == 0:\n            return self.dequeueCat()\n        if len(self.cats) == 0:\n            return self.dequeueDog()\n        return self.dequeueDog() if self.dogs[-1] &lt; self.cats[-1] else self.dequeueCat()\n\n    def dequeueDog(self) -&gt; List[int]:\n        return [-1, -1] if len(self.dogs) == 0 else [self.dogs.pop(), 1]\n\n    def dequeueCat(self) -&gt; List[int]:\n        return [-1, -1] if len(self.cats) == 0 else [self.cats.pop(), 0]\n\n\n# Your AnimalShelf object will be instantiated and called as such:\n# obj = AnimalShelf()\n# obj.enqueue(animal)\n# param_2 = obj.dequeueAny()\n# param_3 = obj.dequeueDog()\n# param_4 = obj.dequeueCat()\n</code></pre> <pre><code>class AnimalShelf {\n    Queue&lt;Integer&gt; cats;\n    Queue&lt;Integer&gt; dogs;\n    public AnimalShelf() {\n        cats = new LinkedList&lt;&gt;();\n        dogs = new LinkedList&lt;&gt;();\n    }\n\n    public void enqueue(int[] animal) {\n        if (animal[1] == 0) {\n            cats.offer(animal[0]);\n        } else {\n            dogs.offer(animal[0]);\n        }\n    }\n\n    public int[] dequeueAny() {\n        return dogs.isEmpty()\n            ? dequeueCat()\n            : (cats.isEmpty() ? dequeueDog()\n                              : (dogs.peek() &lt; cats.peek() ? dequeueDog() : dequeueCat()));\n    }\n\n    public int[] dequeueDog() {\n        return dogs.isEmpty() ? new int[] {-1, -1} : new int[] {dogs.poll(), 1};\n    }\n\n    public int[] dequeueCat() {\n        return cats.isEmpty() ? new int[] {-1, -1} : new int[] {cats.poll(), 0};\n    }\n}\n\n/**\n * Your AnimalShelf object will be instantiated and called as such:\n * AnimalShelf obj = new AnimalShelf();\n * obj.enqueue(animal);\n * int[] param_2 = obj.dequeueAny();\n * int[] param_3 = obj.dequeueDog();\n * int[] param_4 = obj.dequeueCat();\n */\n</code></pre> <pre><code>class AnimalShelf {\n    private cats: number[];\n    private dogs: number[];\n\n    constructor() {\n        this.cats = [];\n        this.dogs = [];\n    }\n\n    enqueue(animal: number[]): void {\n        const [i, j] = animal;\n        this[j === 0 ? 'cats' : 'dogs'].push(i);\n    }\n\n    dequeueAny(): number[] {\n        const n = this.dogs.length;\n        const m = this.cats.length;\n        if (n === 0 &amp;&amp; m === 0) {\n            return [-1, -1];\n        }\n        if ((this.dogs[0] ?? Infinity) &lt; (this.cats[0] ?? Infinity)) {\n            return [this.dogs.shift(), 1];\n        } else {\n            return [this.cats.shift(), 0];\n        }\n    }\n\n    dequeueDog(): number[] {\n        if (this.dogs.length === 0) {\n            return [-1, -1];\n        }\n        return [this.dogs.shift(), 1];\n    }\n\n    dequeueCat(): number[] {\n        if (this.cats.length === 0) {\n            return [-1, -1];\n        }\n        return [this.cats.shift(), 0];\n    }\n}\n\n/**\n * Your AnimalShelf object will be instantiated and called as such:\n * var obj = new AnimalShelf()\n * obj.enqueue(animal)\n * var param_2 = obj.dequeueAny()\n * var param_3 = obj.dequeueDog()\n * var param_4 = obj.dequeueCat()\n */\n</code></pre> <pre><code>use std::collections::VecDeque;\n\nstruct AnimalShelf {\n    cats: VecDeque&lt;i32&gt;,\n    dogs: VecDeque&lt;i32&gt;,\n}\n\n/**\n * `&amp;self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&amp;mut self` instead.\n */\nimpl AnimalShelf {\n    fn new() -&gt; Self {\n        Self {\n            cats: VecDeque::new(),\n            dogs: VecDeque::new(),\n        }\n    }\n\n    fn enqueue(&amp;mut self, animal: Vec&lt;i32&gt;) {\n        if animal[1] == 0 {\n            self.cats.push_back(animal[0]);\n        } else {\n            self.dogs.push_back(animal[0]);\n        }\n    }\n\n    fn dequeue_any(&amp;mut self) -&gt; Vec&lt;i32&gt; {\n        match (self.cats.is_empty(), self.dogs.is_empty()) {\n            (true, true) =&gt; vec![-1, -1],\n            (true, false) =&gt; self.dequeue_dog(),\n            (false, true) =&gt; self.dequeue_cat(),\n            (false, false) =&gt; {\n                if self.dogs[0] &lt; self.cats[0] { self.dequeue_dog() } else { self.dequeue_cat() }\n            }\n        }\n    }\n\n    fn dequeue_dog(&amp;mut self) -&gt; Vec&lt;i32&gt; {\n        if self.dogs.is_empty() {\n            return vec![-1, -1];\n        }\n        vec![self.dogs.pop_front().unwrap(), 1]\n    }\n\n    fn dequeue_cat(&amp;mut self) -&gt; Vec&lt;i32&gt; {\n        if self.cats.is_empty() {\n            return vec![-1, -1];\n        }\n        vec![self.cats.pop_front().unwrap(), 0]\n    }\n}/**\n * Your AnimalShelf object will be instantiated and called as such:\n * let obj = AnimalShelf::new();\n * obj.enqueue(animal);\n * let ret_2: Vec&lt;i32&gt; = obj.dequeue_any();\n * let ret_3: Vec&lt;i32&gt; = obj.dequeue_dog();\n * let ret_4: Vec&lt;i32&gt; = obj.dequeue_cat();\n */\n</code></pre>"},{"location":"lcci/4.1.html","title":"04.01. Route Between Nodes","text":""},{"location":"lcci/4.1.html#description","title":"Description","text":"<p>Given a directed graph, design an algorithm to find out whether there is a route between two nodes.</p> <p>Example1:</p> <pre>\n\n Input: n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2\n\n Output: true\n\n</pre> <p>Example2:</p> <pre>\n\n Input: n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4\n\n Output true\n\n</pre> <p>Note: </p> <ol> <li><code>0 &lt;= n &lt;= 100000</code></li> <li>All node numbers are within the range [0, n].</li> <li>There might be self cycles and duplicated edges.</li> </ol>"},{"location":"lcci/4.1.html#solutions","title":"Solutions","text":""},{"location":"lcci/4.1.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Solution:\n    def findWhetherExistsPath(\n        self, n: int, graph: List[List[int]], start: int, target: int\n    ) -&gt; bool:\n        def dfs(u):\n            if u == target:\n                return True\n            for v in g[u]:\n                if v not in vis:\n                    vis.add(v)\n                    if dfs(v):\n                        return True\n            return False\n\n        g = defaultdict(list)\n        for u, v in graph:\n            g[u].append(v)\n        vis = {start}\n        return dfs(start)\n</code></pre> <pre><code>class Solution {\n    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {\n        Map&lt;Integer, List&lt;Integer&gt;&gt; g = new HashMap&lt;&gt;();\n        for (int[] e : graph) {\n            g.computeIfAbsent(e[0], k -&gt; new ArrayList&lt;&gt;()).add(e[1]);\n        }\n        Set&lt;Integer&gt; vis = new HashSet&lt;&gt;();\n        vis.add(start);\n        return dfs(start, target, g, vis);\n    }\n\n    private boolean dfs(int u, int target, Map&lt;Integer, List&lt;Integer&gt;&gt; g, Set&lt;Integer&gt; vis) {\n        if (u == target) {\n            return true;\n        }\n        for (int v : g.getOrDefault(u, Collections.emptyList())) {\n            if (!vis.contains(v)) {\n                vis.add(v);\n                if (dfs(v, target, g, vis)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    bool findWhetherExistsPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int target) {\n        unordered_map&lt;int, vector&lt;int&gt;&gt; g;\n        for (auto&amp; e : graph) g[e[0]].push_back(e[1]);\n        unordered_set&lt;int&gt; vis{{start}};\n        return dfs(start, target, g, vis);\n    }\n\n    bool dfs(int u, int&amp; target, unordered_map&lt;int, vector&lt;int&gt;&gt;&amp; g, unordered_set&lt;int&gt;&amp; vis) {\n        if (u == target) return true;\n        for (int&amp; v : g[u]) {\n            if (!vis.count(v)) {\n                vis.insert(v);\n                if (dfs(v, target, g, vis)) return true;\n            }\n        }\n        return false;\n    }\n};\n</code></pre> <pre><code>func findWhetherExistsPath(n int, graph [][]int, start int, target int) bool {\n    g := map[int][]int{}\n    for _, e := range graph {\n        u, v := e[0], e[1]\n        g[u] = append(g[u], v)\n    }\n    vis := map[int]bool{start: true}\n    var dfs func(int) bool\n    dfs = func(u int) bool {\n        if u == target {\n            return true\n        }\n        for _, v := range g[u] {\n            if !vis[v] {\n                vis[v] = true\n                if dfs(v) {\n                    return true\n                }\n            }\n        }\n        return false\n    }\n    return dfs(start)\n}\n</code></pre>"},{"location":"lcci/4.1.html#solution-2","title":"Solution 2","text":"Python3JavaC++Go <pre><code>class Solution:\n    def findWhetherExistsPath(\n        self, n: int, graph: List[List[int]], start: int, target: int\n    ) -&gt; bool:\n        g = defaultdict(list)\n        for u, v in graph:\n            g[u].append(v)\n        q = deque([start])\n        vis = {start}\n        while q:\n            u = q.popleft()\n            if u == target:\n                return True\n            for v in g[u]:\n                if v not in vis:\n                    vis.add(v)\n                    q.append(v)\n        return False\n</code></pre> <pre><code>class Solution {\n    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {\n        Map&lt;Integer, List&lt;Integer&gt;&gt; g = new HashMap&lt;&gt;();\n        for (int[] e : graph) {\n            g.computeIfAbsent(e[0], k -&gt; new ArrayList&lt;&gt;()).add(e[1]);\n        }\n        Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();\n        q.offer(start);\n        Set&lt;Integer&gt; vis = new HashSet&lt;&gt;();\n        vis.add(start);\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            if (u == target) {\n                return true;\n            }\n            for (int v : g.getOrDefault(u, Collections.emptyList())) {\n                if (!vis.contains(v)) {\n                    vis.add(v);\n                    q.offer(v);\n                }\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    bool findWhetherExistsPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int target) {\n        unordered_map&lt;int, vector&lt;int&gt;&gt; g;\n        for (auto&amp; e : graph) g[e[0]].push_back(e[1]);\n        queue&lt;int&gt; q{{start}};\n        unordered_set&lt;int&gt; vis{{start}};\n        while (!q.empty()) {\n            int u = q.front();\n            if (u == target) return true;\n            q.pop();\n            for (int v : g[u]) {\n                if (!vis.count(v)) {\n                    vis.insert(v);\n                    q.push(v);\n                }\n            }\n        }\n        return false;\n    }\n};\n</code></pre> <pre><code>func findWhetherExistsPath(n int, graph [][]int, start int, target int) bool {\n    g := map[int][]int{}\n    for _, e := range graph {\n        u, v := e[0], e[1]\n        g[u] = append(g[u], v)\n    }\n    q := []int{start}\n    vis := map[int]bool{start: true}\n    for len(q) &gt; 0 {\n        u := q[0]\n        if u == target {\n            return true\n        }\n        q = q[1:]\n        for _, v := range g[u] {\n            if !vis[v] {\n                vis[v] = true\n                q = append(q, v)\n            }\n        }\n    }\n    return false\n}\n</code></pre>"},{"location":"lcci/4.10.html","title":"04.10. Check SubTree","text":""},{"location":"lcci/4.10.html#description","title":"Description","text":"<p>T1\u00a0and T2 are two very large binary trees, with T1\u00a0much bigger than T2. Create an algorithm to determine if T2 is a subtree of T1.</p> <p>A tree T2 is a subtree of T1\u00a0if there exists a node n in T1\u00a0such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the two trees would be identical.</p> <p>Example1:</p> <pre>\n\n Input: t1 = [1, 2, 3], t2 = [2]\n\n Output: true\n\n</pre> <p>Example2:</p> <pre>\n\n Input: t1 = [1, null, 2, 4], t2 = [3, 2]\n\n Output: false\n\n</pre> <p>Note: </p> <ol> <li>The node numbers of both tree are in [0, 20000].</li> </ol>"},{"location":"lcci/4.10.html#solutions","title":"Solutions","text":""},{"location":"lcci/4.10.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRust <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def checkSubTree(self, t1: TreeNode, t2: TreeNode) -&gt; bool:\n        def dfs(t1, t2):\n            if t2 is None:\n                return True\n            if t1 is None:\n                return False\n            if t1.val == t2.val:\n                return dfs(t1.left, t2.left) and dfs(t1.right, t2.right)\n            return dfs(t1.left, t2) or dfs(t1.right, t2)\n\n        return dfs(t1, t2)\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean checkSubTree(TreeNode t1, TreeNode t2) {\n        if (t2 == null) {\n            return true;\n        }\n        if (t1 == null) {\n            return false;\n        }\n        if (t1.val == t2.val) {\n            return checkSubTree(t1.left, t2.left) &amp;&amp; checkSubTree(t1.right, t2.right);\n        }\n        return checkSubTree(t1.left, t2) || checkSubTree(t1.right, t2);\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool checkSubTree(TreeNode* t1, TreeNode* t2) {\n        if (!t2) return 1;\n        if (!t1) return 0;\n        if (t1-&gt;val == t2-&gt;val) return checkSubTree(t1-&gt;left, t2-&gt;left) &amp;&amp; checkSubTree(t1-&gt;right, t2-&gt;right);\n        return checkSubTree(t1-&gt;left, t2) || checkSubTree(t1-&gt;right, t2);\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc checkSubTree(t1 *TreeNode, t2 *TreeNode) bool {\n    if t2 == nil {\n        return true\n    }\n    if t1 == nil {\n        return false\n    }\n    if t1.Val == t2.Val {\n        return checkSubTree(t1.Left, t2.Left) &amp;&amp; checkSubTree(t1.Right, t2.Right)\n    }\n    return checkSubTree(t1.Left, t2) || checkSubTree(t1.Right, t2)\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction checkSubTree(t1: TreeNode | null, t2: TreeNode | null): boolean {\n    if (t1 == null &amp;&amp; t2 == null) {\n        return true;\n    }\n    if (t1 == null || t2 == null) {\n        return false;\n    }\n    if (t1.val === t2.val) {\n        return checkSubTree(t1.left, t2.left) &amp;&amp; checkSubTree(t1.right, t2.right);\n    }\n    return checkSubTree(t1.left, t2) || checkSubTree(t1.right, t2);\n}\n</code></pre> <pre><code>// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -&gt; Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    fn dfs(t1: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, t2: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; bool {\n        if t1.is_none() &amp;&amp; t2.is_none() {\n            return true;\n        }\n        if t1.is_none() || t2.is_none() {\n            return false;\n        }\n        let r1 = t1.as_ref().unwrap().borrow();\n        let r2 = t2.as_ref().unwrap().borrow();\n        if r1.val == r2.val {\n            return Self::dfs(&amp;r1.left, &amp;r2.left) &amp;&amp; Self::dfs(&amp;r1.right, &amp;r2.right);\n        }\n        Self::dfs(&amp;r1.left, t2) || Self::dfs(&amp;r1.right, t2)\n    }\n\n    pub fn check_sub_tree(\n        t1: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n        t2: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;\n    ) -&gt; bool {\n        Self::dfs(&amp;t1, &amp;t2)\n    }\n}\n</code></pre>"},{"location":"lcci/4.12.html","title":"04.12. Paths with Sum","text":""},{"location":"lcci/4.12.html#description","title":"Description","text":"<p>You are given a binary tree in which each node contains an integer value (which might be positive or negative). Design an algorithm to count the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p> <p>Example:  Given the following tree and \u00a0<code>sum = 22,</code></p> <pre>\n\n              5\n\n             / \\\n\n            4   8\n\n           /   / \\\n\n          11  13  4\n\n         /  \\    / \\\n\n        7    2  5   1\n\n</pre> <p>Output:</p> <pre>\n\n3\n\nExplanation: Paths that have sum 22 are: [5,4,11,2], [5,8,4,5], [4,11,7]</pre> <p>Note:</p> <ul> <li><code>node number &lt;= 10000</code></li> </ul>"},{"location":"lcci/4.12.html#solutions","title":"Solutions","text":""},{"location":"lcci/4.12.html#solution-1-hash-table-prefix-sum-recursion","title":"Solution 1: Hash Table + Prefix Sum + Recursion","text":"<p>We can use the idea of prefix sum to recursively traverse the binary tree, and use a hash table $cnt$ to count the occurrence of each prefix sum on the path from the root node to the current node.</p> <p>We design a recursive function $dfs(node, s)$, where the current node being traversed is $node$, and the prefix sum on the path from the root node to the current node is $s$. The return value of the function is the number of paths with the path sum equal to $sum$ and the path ends at the $node$ node or its subtree nodes. Therefore, the answer is $dfs(root, 0)$.</p> <p>The recursive process of the function $dfs(node, s)$ is as follows:</p> <ul> <li>If the current node $node$ is null, return $0$.</li> <li>Calculate the prefix sum $s$ on the path from the root node to the current node.</li> <li>Use $cnt[s - sum]$ to represent the number of paths with the path sum equal to $sum$ and the path ends at the current node, where $cnt[s - sum]$ is the count of the prefix sum equal to $s - sum$ in $cnt$.</li> <li>Add the count of the prefix sum $s$ by $1$, i.e., $cnt[s] = cnt[s] + 1$.</li> <li>Recursively traverse the left and right child nodes of the current node, i.e., call the functions $dfs(node.left, s)$ and $dfs(node.right, s)$, and add their return values.</li> <li>After the return value is calculated, subtract the count of the prefix sum $s$ of the current node by $1$, i.e., execute $cnt[s] = cnt[s] - 1$.</li> <li>Finally, return the answer.</li> </ul> <p>The time complexity is $O(n)$, and the space complexity is $O(n)$. Here, $n$ is the number of nodes in the binary tree.</p> Python3JavaC++GoTypeScriptRust <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def pathSum(self, root: TreeNode, sum: int) -&gt; int:\n        def dfs(root: TreeNode, s: int):\n            if root is None:\n                return 0\n            s += root.val\n            ans = cnt[s - sum]\n            cnt[s] += 1\n            ans += dfs(root.left, s)\n            ans += dfs(root.right, s)\n            cnt[s] -= 1\n            return ans\n\n        cnt = Counter({0: 1})\n        return dfs(root, 0)\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private Map&lt;Long, Integer&gt; cnt = new HashMap&lt;&gt;();\n    private int target;\n\n    public int pathSum(TreeNode root, int sum) {\n        cnt.put(0L, 1);\n        target = sum;\n        return dfs(root, 0);\n    }\n\n    private int dfs(TreeNode root, long s) {\n        if (root == null) {\n            return 0;\n        }\n        s += root.val;\n        int ans = cnt.getOrDefault(s - target, 0);\n        cnt.merge(s, 1, Integer::sum);\n        ans += dfs(root.left, s);\n        ans += dfs(root.right, s);\n        cnt.merge(s, -1, Integer::sum);\n        return ans;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int pathSum(TreeNode* root, int sum) {\n        unordered_map&lt;long long, int&gt; cnt;\n        cnt[0] = 1;\n        function&lt;int(TreeNode*, long long)&gt; dfs = [&amp;](TreeNode* root, long long s) {\n            if (!root) {\n                return 0;\n            }\n            s += root-&gt;val;\n            int ans = cnt[s - sum];\n            ++cnt[s];\n            ans += dfs(root-&gt;left, s);\n            ans += dfs(root-&gt;right, s);\n            --cnt[s];\n            return ans;\n        };\n        return dfs(root, 0);\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc pathSum(root *TreeNode, sum int) int {\n    cnt := map[int]int{0: 1}\n    var dfs func(*TreeNode, int) int\n    dfs = func(root *TreeNode, s int) int {\n        if root == nil {\n            return 0\n        }\n        s += root.Val\n        ans := cnt[s-sum]\n        cnt[s]++\n        ans += dfs(root.Left, s)\n        ans += dfs(root.Right, s)\n        cnt[s]--\n        return ans\n    }\n    return dfs(root, 0)\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction pathSum(root: TreeNode | null, sum: number): number {\n    const cnt: Map&lt;number, number&gt; = new Map();\n    cnt.set(0, 1);\n    const dfs = (root: TreeNode | null, s: number): number =&gt; {\n        if (!root) {\n            return 0;\n        }\n        s += root.val;\n        let ans = cnt.get(s - sum) ?? 0;\n        cnt.set(s, (cnt.get(s) ?? 0) + 1);\n        ans += dfs(root.left, s);\n        ans += dfs(root.right, s);\n        cnt.set(s, (cnt.get(s) ?? 0) - 1);\n        return ans;\n    };\n    return dfs(root, 0);\n}\n</code></pre> <pre><code>// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -&gt; Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nimpl Solution {\n    pub fn path_sum(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, sum: i32) -&gt; i32 {\n        let mut cnt = HashMap::new();\n        cnt.insert(0, 1);\n        return Self::dfs(root, sum, 0, &amp;mut cnt);\n    }\n\n    fn dfs(\n        root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n        sum: i32,\n        s: i32,\n        cnt: &amp;mut HashMap&lt;i32, i32&gt;\n    ) -&gt; i32 {\n        if let Some(node) = root {\n            let node = node.borrow();\n            let s = s + node.val;\n            let mut ans = *cnt.get(&amp;(s - sum)).unwrap_or(&amp;0);\n            *cnt.entry(s).or_insert(0) += 1;\n            ans += Self::dfs(node.left.clone(), sum, s, cnt);\n            ans += Self::dfs(node.right.clone(), sum, s, cnt);\n            *cnt.entry(s).or_insert(0) -= 1;\n            return ans;\n        }\n        return 0;\n    }\n}\n</code></pre>"},{"location":"lcci/4.2.html","title":"04.02. Minimum Height Tree","text":""},{"location":"lcci/4.2.html#description","title":"Description","text":"<p>Given a sorted (increasing order) array with unique integer elements, write an algo\u00adrithm to create a binary search tree with minimal height.</p> <p>Example:</p> <pre>\n\nGiven sorted array: [-10,-3,0,5,9],\n\n\n\nOne possible answer is: [0,-3,9,-10,null,5]\uff0cwhich represents the following tree: \n\n\n\n          0 \n\n         / \\ \n\n       -3   9 \n\n       /   / \n\n     -10  5 \n\n</pre>"},{"location":"lcci/4.2.html#solutions","title":"Solutions","text":""},{"location":"lcci/4.2.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRustJavaScript <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:\n        def dfs(l, r):\n            if l &gt; r:\n                return None\n            mid = (l + r) &gt;&gt; 1\n            return TreeNode(nums[mid], dfs(l, mid - 1), dfs(mid + 1, r))\n\n        return dfs(0, len(nums) - 1)\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private int[] nums;\n\n    public TreeNode sortedArrayToBST(int[] nums) {\n        this.nums = nums;\n        return dfs(0, nums.length - 1);\n    }\n\n    private TreeNode dfs(int l, int r) {\n        if (l &gt; r) {\n            return null;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        return new TreeNode(nums[mid], dfs(l, mid - 1), dfs(mid + 1, r));\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {\n        function&lt;TreeNode*(int, int)&gt; dfs = [&amp;](int l, int r) -&gt; TreeNode* {\n            if (l &gt; r) return nullptr;\n            int mid = l + r &gt;&gt; 1;\n            return new TreeNode(nums[mid], dfs(l, mid - 1), dfs(mid + 1, r));\n        };\n        return dfs(0, nums.size() - 1);\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedArrayToBST(nums []int) *TreeNode {\n    var dfs func(int, int) *TreeNode\n    dfs = func(l, r int) *TreeNode {\n        if l &gt; r {\n            return nil\n        }\n        mid := (l + r) &gt;&gt; 1\n        return &amp;TreeNode{nums[mid], dfs(l, mid-1), dfs(mid+1, r)}\n    }\n\n    return dfs(0, len(nums)-1)\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction sortedArrayToBST(nums: number[]): TreeNode | null {\n    const dfs = (l: number, r: number): TreeNode | null =&gt; {\n        if (l &gt; r) {\n            return null;\n        }\n        const mid = (l + r) &gt;&gt; 1;\n        return new TreeNode(nums[mid], dfs(l, mid - 1), dfs(mid + 1, r));\n    };\n    return dfs(0, nums.length - 1);\n}\n</code></pre> <pre><code>// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -&gt; Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    fn dfs(nums: &amp;Vec&lt;i32&gt;, start: usize, end: usize) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {\n        if start &gt;= end {\n            return None;\n        }\n        let mid = start + (end - start) / 2;\n        Some(\n            Rc::new(\n                RefCell::new(TreeNode {\n                    val: nums[mid],\n                    left: Self::dfs(nums, start, mid),\n                    right: Self::dfs(nums, mid + 1, end),\n                })\n            )\n        )\n    }\n    pub fn sorted_array_to_bst(nums: Vec&lt;i32&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {\n        let end = nums.len();\n        Self::dfs(&amp;nums, 0, end)\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nvar sortedArrayToBST = function (nums) {\n    function dfs(l, r) {\n        if (l &gt; r) {\n            return null;\n        }\n        const mid = (l + r) &gt;&gt; 1;\n        return new TreeNode(nums[mid], dfs(l, mid - 1), dfs(mid + 1, r));\n    }\n\n    return dfs(0, nums.length - 1);\n};\n</code></pre>"},{"location":"lcci/4.3.html","title":"04.03. List of Depth","text":""},{"location":"lcci/4.3.html#description","title":"Description","text":"<p>Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g., if you have a tree with depth D, you'll have D linked lists). Return a array containing all the linked lists.</p> <p> </p> <p>Example: </p> <pre>\n\nInput: [1,2,3,4,5,null,7,8]\n\n\n\n        1\n\n       /  \\\n\n      2    3\n\n     / \\    \\\n\n    4   5    7\n\n   /\n\n  8\n\n\n\nOutput: [[1],[2,3],[4,5,7],[8]]\n\n</pre>"},{"location":"lcci/4.3.html#solutions","title":"Solutions","text":""},{"location":"lcci/4.3.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRust <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]:\n        ans = []\n        q = deque([tree])\n        while q:\n            dummy = cur = ListNode(0)\n            for _ in range(len(q)):\n                node = q.popleft()\n                cur.next = ListNode(node.val)\n                cur = cur.next\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            ans.append(dummy.next)\n        return ans\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode[] listOfDepth(TreeNode tree) {\n        List&lt;ListNode&gt; ans = new ArrayList&lt;&gt;();\n        Deque&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;();\n        q.offer(tree);\n        while (!q.isEmpty()) {\n            ListNode dummy = new ListNode(0);\n            ListNode cur = dummy;\n            for (int k = q.size(); k &gt; 0; --k) {\n                TreeNode node = q.poll();\n                cur.next = new ListNode(node.val);\n                cur = cur.next;\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n            ans.add(dummy.next);\n        }\n        return ans.toArray(new ListNode[0]);\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;ListNode*&gt; listOfDepth(TreeNode* tree) {\n        vector&lt;ListNode*&gt; ans;\n        queue&lt;TreeNode*&gt; q{{tree}};\n        while (!q.empty()) {\n            ListNode* dummy = new ListNode(0);\n            ListNode* cur = dummy;\n            for (int k = q.size(); k; --k) {\n                TreeNode* node = q.front();\n                q.pop();\n                cur-&gt;next = new ListNode(node-&gt;val);\n                cur = cur-&gt;next;\n                if (node-&gt;left) {\n                    q.push(node-&gt;left);\n                }\n                if (node-&gt;right) {\n                    q.push(node-&gt;right);\n                }\n            }\n            ans.push_back(dummy-&gt;next);\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc listOfDepth(tree *TreeNode) (ans []*ListNode) {\n    q := []*TreeNode{tree}\n    for len(q) &gt; 0 {\n        dummy := &amp;ListNode{}\n        cur := dummy\n        for k := len(q); k &gt; 0; k-- {\n            node := q[0]\n            q = q[1:]\n            cur.Next = &amp;ListNode{Val: node.Val}\n            cur = cur.Next\n            if node.Left != nil {\n                q = append(q, node.Left)\n            }\n            if node.Right != nil {\n                q = append(q, node.Right)\n            }\n        }\n        ans = append(ans, dummy.Next)\n    }\n    return\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction listOfDepth(tree: TreeNode | null): Array&lt;ListNode | null&gt; {\n    const ans: Array&lt;ListNode | null&gt; = [];\n    const q: Array&lt;TreeNode | null&gt; = [tree];\n    while (q.length) {\n        const dummy = new ListNode();\n        let cur = dummy;\n        for (let k = q.length; k; --k) {\n            const { val, left, right } = q.shift()!;\n            cur.next = new ListNode(val);\n            cur = cur.next;\n            left &amp;&amp; q.push(left);\n            right &amp;&amp; q.push(right);\n        }\n        ans.push(dummy.next);\n    }\n    return ans;\n}\n</code></pre> <pre><code>// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -&gt; Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\n// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -&gt; Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nimpl Solution {\n    pub fn list_of_depth(tree: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Vec&lt;Option&lt;Box&lt;ListNode&gt;&gt;&gt; {\n        let mut res = vec![];\n        if tree.is_none() {\n            return res;\n        }\n        let mut q = VecDeque::new();\n        q.push_back(tree);\n        while !q.is_empty() {\n            let n = q.len();\n            let mut demmy = Some(Box::new(ListNode::new(0)));\n            let mut cur = &amp;mut demmy;\n            for _ in 0..n {\n                if let Some(node) = q.pop_front().unwrap() {\n                    let mut node = node.borrow_mut();\n                    if node.left.is_some() {\n                        q.push_back(node.left.take());\n                    }\n                    if node.right.is_some() {\n                        q.push_back(node.right.take());\n                    }\n                    cur.as_mut().unwrap().next = Some(Box::new(ListNode::new(node.val)));\n                    cur = &amp;mut cur.as_mut().unwrap().next;\n                }\n            }\n            res.push(demmy.as_mut().unwrap().next.take());\n        }\n        res\n    }\n}\n</code></pre>"},{"location":"lcci/4.4.html","title":"04.04. Check Balance","text":""},{"location":"lcci/4.4.html#description","title":"Description","text":"<p>Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.</p> <p> Example 1:</p> <pre>\n\nGiven tree [3,9,20,null,null,15,7]\n\n    3\n\n   / \\\n\n  9  20\n\n    /  \\\n\n   15   7\n\nreturn true.</pre> <p>Example 2:</p> <pre>\n\nGiven [1,2,2,3,3,null,null,4,4]\n\n      1\n\n     / \\\n\n    2   2\n\n   / \\\n\n  3   3\n\n / \\\n\n4   4\n\nreturn\u00a0false.</pre> <p> </p>"},{"location":"lcci/4.4.html#solutions","title":"Solutions","text":""},{"location":"lcci/4.4.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScript <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -&gt; bool:\n        def dfs(root: TreeNode):\n            if root is None:\n                return 0, True\n            a, b = dfs(root.left)\n            c, d = dfs(root.right)\n            return max(a, c) + 1, abs(a - c) &lt;= 1 and b and d\n\n        return dfs(root)[1]\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return dfs(root) &gt;= 0;\n    }\n\n    private int dfs(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int l = dfs(root.left);\n        int r = dfs(root.right);\n        if (l &lt; 0 || r &lt; 0 || Math.abs(l - r) &gt; 1) {\n            return -1;\n        }\n        return Math.max(l, r) + 1;\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        function&lt;int(TreeNode*)&gt; dfs = [&amp;](TreeNode* root) {\n            if (!root) {\n                return 0;\n            }\n            int l = dfs(root-&gt;left);\n            int r = dfs(root-&gt;right);\n            if (l == -1 || r == -1 || abs(l - r) &gt; 1) {\n                return -1;\n            }\n            return max(l, r) + 1;\n        };\n        return dfs(root) &gt;= 0;\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isBalanced(root *TreeNode) bool {\n    var dfs func(*TreeNode) int\n    dfs = func(root *TreeNode) int {\n        if root == nil {\n            return 0\n        }\n        l, r := dfs(root.Left), dfs(root.Right)\n        if l == -1 || r == -1 || abs(l-r) &gt; 1 {\n            return -1\n        }\n        return max(l, r) + 1\n    }\n    return dfs(root) &gt;= 0\n}\n\nfunc abs(x int) int {\n    if x &lt; 0 {\n        return -x\n    }\n    return x\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isBalanced(root: TreeNode | null): boolean {\n    const dfs = (root: TreeNode | null): number =&gt; {\n        if (!root) {\n            return 0;\n        }\n        const l = dfs(root.left);\n        const r = dfs(root.right);\n        if (l === -1 || r === -1 || Math.abs(l - r) &gt; 1) {\n            return -1;\n        }\n        return Math.max(l, r) + 1;\n    };\n    return dfs(root) &gt;= 0;\n}\n</code></pre>"},{"location":"lcci/4.4.html#solution-2","title":"Solution 2","text":"Python3 <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -&gt; bool:\n        def dfs(root: TreeNode):\n            if root is None:\n                return 0\n            l, r = dfs(root.left), dfs(root.right)\n            if l == -1 or r == -1 or abs(l - r) &gt; 1:\n                return -1\n            return max(l, r) + 1\n\n        return dfs(root) &gt;= 0\n</code></pre>"},{"location":"lcci/4.5.html","title":"04.05. Legal Binary Search Tree","text":""},{"location":"lcci/4.5.html#description","title":"Description","text":"<p>Implement a function to check if a binary tree is a binary search tree.</p> <p>Example\u00a01:</p> <pre>\n\nInput:\n\n    2\n\n   / \\\n\n  1   3\n\nOutput: true\n\n</pre> <p>Example\u00a02:</p> <pre>\n\nInput:\n\n    5\n\n   / \\\n\n  1   4\n\n\u00a0    / \\\n\n\u00a0   3   6\n\nOutput: false\n\nExplanation: Input: [5,1,4,null,null,3,6].\n\n\u00a0    the value of root node is 5, but its right child has value 4.</pre>"},{"location":"lcci/4.5.html#solutions","title":"Solutions","text":""},{"location":"lcci/4.5.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRust <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    res, t = True, None\n\n    def isValidBST(self, root: TreeNode) -&gt; bool:\n        self.isValid(root)\n        return self.res\n\n    def isValid(self, root):\n        if not root:\n            return\n        self.isValid(root.left)\n        if self.t is None or self.t &lt; root.val:\n            self.t = root.val\n        else:\n            self.res = False\n            return\n        self.isValid(root.right)\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private boolean res = true;\n    private Integer t = null;\n    public boolean isValidBST(TreeNode root) {\n        isValid(root);\n        return res;\n    }\n\n    private void isValid(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        isValid(root.left);\n        if (t == null || t &lt; root.val) {\n            t = root.val;\n        } else {\n            res = false;\n            return;\n        }\n        isValid(root.right);\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        TreeNode* pre = nullptr;\n        TreeNode* cur = root;\n        stack&lt;TreeNode*&gt; stk;\n        while (cur || !stk.empty()) {\n            if (cur) {\n                stk.push(cur);\n                cur = cur-&gt;left;\n            } else {\n                cur = stk.top();\n                stk.pop();\n                if (pre &amp;&amp; pre-&gt;val &gt;= cur-&gt;val) {\n                    return false;\n                }\n                pre = cur;\n                cur = cur-&gt;right;\n            }\n        }\n        return true;\n    }\n};\n</code></pre> <pre><code>func isValidBST(root *TreeNode) bool {\n    stack := make([]*TreeNode, 0)\n    var prev *TreeNode = nil\n    node := root\n    for len(stack) &gt; 0 || node != nil {\n        for node != nil {\n            stack = append(stack, node)\n            node = node.Left\n        }\n        node = stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        if prev == nil || node.Val &gt; prev.Val {\n            prev = node\n        } else {\n            return false\n        }\n        node = node.Right\n    }\n    return true\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isValidBST(root: TreeNode | null): boolean {\n    let pre = -Infinity;\n    const dfs = (root: TreeNode | null) =&gt; {\n        if (root == null) {\n            return true;\n        }\n        const { val, left, right } = root;\n        if (!dfs(left) || val &lt;= pre) {\n            return false;\n        }\n        pre = val;\n        return dfs(right);\n    };\n    return dfs(root);\n}\n</code></pre> <pre><code>// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -&gt; Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    fn dfs(root: &amp;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, pre: &amp;mut Option&lt;i32&gt;) -&gt; bool {\n        if root.is_none() {\n            return true;\n        }\n        let root = root.as_ref().unwrap().borrow();\n        if !Self::dfs(&amp;root.left, pre) {\n            return false;\n        }\n        if pre.is_some() &amp;&amp; pre.unwrap() &gt;= root.val {\n            return false;\n        }\n        *pre = Some(root.val);\n        Self::dfs(&amp;root.right, pre)\n    }\n\n    pub fn is_valid_bst(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; bool {\n        Self::dfs(&amp;root, &amp;mut None)\n    }\n}\n</code></pre>"},{"location":"lcci/4.5.html#solution-2","title":"Solution 2","text":"GoTypeScript <pre><code>func isValidBST(root *TreeNode) bool {\n    return check(root, math.MinInt64, math.MaxInt64)\n}\n\nfunc check(node *TreeNode, lower, upper int) bool {\n    if node == nil {\n        return true\n    }\n    if node.Val &lt;= lower || node.Val &gt;= upper {\n        return false\n    }\n    return check(node.Left, lower, node.Val) &amp;&amp; check(node.Right, node.Val, upper)\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isValidBST(root: TreeNode | null): boolean {\n    if (root == null) {\n        return true;\n    }\n    const { val, left, right } = root;\n    const dfs = (root: TreeNode | null, min: number, max: number) =&gt; {\n        if (root == null) {\n            return true;\n        }\n        const { val, left, right } = root;\n        if (val &lt;= min || val &gt;= max) {\n            return false;\n        }\n        return dfs(left, min, Math.min(val, max)) &amp;&amp; dfs(right, Math.max(val, min), max);\n    };\n    return dfs(left, -Infinity, val) &amp;&amp; dfs(right, val, Infinity);\n}\n</code></pre>"},{"location":"lcci/4.6.html","title":"04.06. Successor","text":""},{"location":"lcci/4.6.html#description","title":"Description","text":"<p>Write an algorithm to find the \"next\" node (i.e., in-order successor) of a given node in a binary search tree.</p> <p>Return <code>null</code> if there's no \"next\" node for the given node.</p> <p>Example 1:</p> <pre>\n\nInput: root = <code>[2,1,3], p = 1\n\n\n\n  2\n\n / \\\n\n1   3\n\n</code>\n\nOutput: 2</pre> <p>Example 2:</p> <pre>\n\nInput: root = <code>[5,3,6,2,4,null,null,1], p = 6\n\n\n\n      5\n\n     / \\\n\n    3   6\n\n   / \\\n\n  2   4\n\n /   \n\n1\n\n</code>\n\nOutput: null</pre>"},{"location":"lcci/4.6.html#solutions","title":"Solutions","text":""},{"location":"lcci/4.6.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoJavaScript <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def inorderSuccessor(self, root: TreeNode, p: TreeNode) -&gt; TreeNode:\n        def dfs(root):\n            if root is None:\n                return\n            dfs(root.left)\n            nonlocal ans, prev\n            if prev == p:\n                ans = root\n            prev = root\n            dfs(root.right)\n\n        ans = prev = None\n        dfs(root)\n        return ans\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private TreeNode prev;\n    private TreeNode p;\n    private TreeNode ans;\n\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n        prev = null;\n        ans = null;\n        this.p = p;\n        dfs(root);\n        return ans;\n    }\n\n    private void dfs(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        dfs(root.left);\n        if (prev == p) {\n            ans = root;\n        }\n        prev = root;\n        dfs(root.right);\n    }\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* prev;\n    TreeNode* p;\n    TreeNode* ans;\n\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n        this-&gt;p = p;\n        dfs(root);\n        return ans;\n    }\n\n    void dfs(TreeNode* root) {\n        if (!root) return;\n        dfs(root-&gt;left);\n        if (prev == p) ans = root;\n        prev = root;\n        dfs(root-&gt;right);\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc inorderSuccessor(root *TreeNode, p *TreeNode) *TreeNode {\n    var prev, ans *TreeNode\n    var dfs func(root *TreeNode)\n    dfs = func(root *TreeNode) {\n        if root == nil {\n            return\n        }\n        dfs(root.Left)\n        if prev == p {\n            ans = root\n        }\n        prev = root\n        dfs(root.Right)\n    }\n    dfs(root)\n    return ans\n}\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @return {TreeNode}\n */\nvar inorderSuccessor = function (root, p) {\n    if (root == null) {\n        return root;\n    }\n    const { val, left, right } = root;\n    const res = inorderSuccessor(left, p);\n    if (res != null) {\n        return res;\n    }\n    if (val &gt; p.val) {\n        return root;\n    }\n    return inorderSuccessor(right, p);\n};\n</code></pre>"},{"location":"lcci/4.6.html#solution-2","title":"Solution 2","text":"C++JavaScript <pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n        stack&lt;TreeNode*&gt; stk;\n        TreeNode* cur = root;\n        while (cur != nullptr || !stk.empty()) {\n            if (cur == nullptr) {\n                cur = stk.top();\n                stk.pop();\n                if (cur-&gt;val &gt; p-&gt;val) {\n                    return cur;\n                }\n                cur = cur-&gt;right;\n            } else {\n                stk.push(cur);\n                cur = cur-&gt;left;\n            }\n        }\n        return cur;\n    }\n};\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @return {TreeNode}\n */\nvar inorderSuccessor = function (root, p) {\n    const stack = [];\n    let cur = root;\n    while (cur != null || stack.length !== 0) {\n        if (cur == null) {\n            cur = stack.pop();\n            if (cur.val &gt; p.val) {\n                return cur;\n            }\n            cur = cur.right;\n        } else {\n            stack.push(cur);\n            cur = cur.left;\n        }\n    }\n    return cur;\n};\n</code></pre>"},{"location":"lcci/4.8.html","title":"04.08. First Common Ancestor","text":""},{"location":"lcci/4.8.html#description","title":"Description","text":"<p>Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a data structure. NOTE: This is not necessarily a binary search tree.</p> <p>For example, Given the following tree: root = [3,5,1,6,2,0,8,null,null,7,4]</p> <pre>\n\n    3\n\n   / \\\n\n  5   1\n\n / \\ / \\\n\n6  2 0  8\n\n  / \\\n\n 7   4\n\n</pre> <p>Example 1:</p> <pre>\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\nInput: 3\n\nExplanation: The first common ancestor of node 5 and node 1 is node 3.</pre> <p>Example 2:</p> <pre>\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\nOutput: 5\n\nExplanation: The first common ancestor of node 5 and node 4 is node 5.</pre> <p>Notes:</p> <ul> <li>All node values are pairwise distinct.</li> <li>p, q are different node and both can be found in the given tree.</li> </ul>"},{"location":"lcci/4.8.html#solutions","title":"Solutions","text":""},{"location":"lcci/4.8.html#solution-1","title":"Solution 1","text":"Python3Java <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: TreeNode, p: TreeNode, q: TreeNode\n    ) -&gt; TreeNode:\n        if root is None or root == p or root == q:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        return right if left is None else (left if right is None else root)\n</code></pre> <pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) {\n            return root;\n        }\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        return left == null ? right : (right == null ? left : root);\n    }\n}\n</code></pre>"},{"location":"lcci/4.9.html","title":"04.09. BST Sequences","text":""},{"location":"lcci/4.9.html#description","title":"Description","text":"<p>A binary search tree was created by traversing through an array from left to right and inserting each element. Given a binary search tree with distinct elements, print all possible arrays that could have led to this tree.</p> <p>Example: Given the following tree:</p> <pre>\n\n        2\n\n       / \\\n\n      1   3\n\n</pre> <p>Output:</p> <pre>\n\n[\n\n[2,1,3],\n\n[2,3,1]\n\n]\n\n</pre>"},{"location":"lcci/4.9.html#solutions","title":"Solutions","text":""},{"location":"lcci/5.1.html","title":"05.01. Insert Into Bits","text":""},{"location":"lcci/5.1.html#description","title":"Description","text":"<p>You are given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to insert M into N such that M starts at bit j and ends at bit i. You can assume that the bits j through i have enough space to fit all of M. That is, if M = 10011, you can assume that there are at least 5 bits between j and i. You would not, for example, have j = 3 and i = 2, because M could not fully fit between bit 3 and bit 2.</p> <p>Example1:</p> <pre>\n\n Input: N = 10000000000, M = 10011, i = 2, j = 6\n\n Output: N = 10001001100\n\n</pre> <p>Example2:</p> <pre>\n\n Input: N = 0, M = 11111, i = 0, j = 4\n\n Output: N = 11111\n\n</pre>"},{"location":"lcci/5.1.html#solutions","title":"Solutions","text":""},{"location":"lcci/5.1.html#solution-1-bit-manipulation","title":"Solution 1: Bit Manipulation","text":"<p>First, we clear the bits from the $i$-th to the $j$-th in $N$, then we left shift $M$ by $i$ bits, and finally perform a bitwise OR operation on $M$ and $N$.</p> <p>The time complexity is $O(\\log n)$, where $n$ is the size of $N$. The space complexity is $O(1)$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def insertBits(self, N: int, M: int, i: int, j: int) -&gt; int:\n        for k in range(i, j + 1):\n            N &amp;= ~(1 &lt;&lt; k)\n        return N | M &lt;&lt; i\n</code></pre> <pre><code>class Solution {\n    public int insertBits(int N, int M, int i, int j) {\n        for (int k = i; k &lt;= j; ++k) {\n            N &amp;= ~(1 &lt;&lt; k);\n        }\n        return N | M &lt;&lt; i;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int insertBits(int N, int M, int i, int j) {\n        for (int k = i; k &lt;= j; ++k) {\n            N &amp;= ~(1 &lt;&lt; k);\n        }\n        return N | M &lt;&lt; i;\n    }\n};\n</code></pre> <pre><code>func insertBits(N int, M int, i int, j int) int {\n    for k := i; k &lt;= j; k++ {\n        N &amp;= ^(1 &lt;&lt; k)\n    }\n    return N | M&lt;&lt;i\n}\n</code></pre> <pre><code>function insertBits(N: number, M: number, i: number, j: number): number {\n    for (let k = i; k &lt;= j; ++k) {\n        N &amp;= ~(1 &lt;&lt; k);\n    }\n    return N | (M &lt;&lt; i);\n}\n</code></pre>"},{"location":"lcci/5.2.html","title":"05.02. Binary Number to String","text":""},{"location":"lcci/5.2.html#description","title":"Description","text":"<p>Given a real number between O and 1 (e.g., 0.72) that is passed in as a double, print the binary representation. If the number cannot be represented accurately in binary with at most 32 characters, print \"ERROR\".</p> <p>Example1:</p> <pre>\n\n Input: 0.625\n\n Output: \"0.101\"\n\n</pre> <p>Example2:</p> <pre>\n\n Input: 0.1\n\n Output: \"ERROR\"\n\n Note: 0.1 cannot be represented accurately in binary.\n\n</pre> <p>Note: </p> <ol> <li>This two characters \"0.\" should be counted into 32 characters.</li> </ol>"},{"location":"lcci/5.2.html#solutions","title":"Solutions","text":""},{"location":"lcci/5.2.html#solution-1-decimal-fraction-to-binary-fraction","title":"Solution 1: Decimal Fraction to Binary Fraction","text":"<p>The method of converting a decimal fraction to a binary fraction is as follows: multiply the decimal part by $2$, take the integer part as the next digit of the binary fraction, and take the decimal part as the multiplicand for the next multiplication, until the decimal part is $0$ or the length of the binary fraction exceeds $32$ bits.</p> <p>Let's take an example, suppose we want to convert $0.8125$ to a binary fraction, the process is as follows:</p> <p>$$ \\begin{aligned} 0.8125 \\times 2 &amp;= 1.625 \\quad \\text{take the integer part} \\quad 1 \\ 0.625 \\times 2 &amp;= 1.25 \\quad \\text{take the integer part} \\quad 1 \\ 0.25 \\times 2 &amp;= 0.5 \\quad \\text{take the integer part} \\quad 0 \\ 0.5 \\times 2 &amp;= 1 \\quad \\text{take the integer part} \\quad 1 \\ \\end{aligned} $$</p> <p>So the binary fraction representation of the decimal fraction $0.8125$ is $0.1101_{(2)}$.</p> <p>For this problem, since the real number is between $0$ and $1$, its integer part must be $0$. We only need to convert the decimal part into a binary fraction according to the above method. Stop the conversion when the decimal part is $0$ or the length of the binary fraction is not less than $32$ bits.</p> <p>Finally, if the decimal part is not $0$, it means that the real number cannot be represented in binary within $32$ bits, return the string <code>\"ERROR\"</code>. Otherwise, return the converted binary fraction.</p> <p>The time complexity is $O(C)$, and the space complexity is $O(C)$. Here, $C$ is the length of the binary fraction, with a maximum of $32$.</p> Python3JavaC++Go <pre><code>class Solution:\n    def printBin(self, num: float) -&gt; str:\n        ans = '0.'\n        while len(ans) &lt; 32 and num:\n            num *= 2\n            x = int(num)\n            ans += str(x)\n            num -= x\n        return 'ERROR' if num else ans\n</code></pre> <pre><code>class Solution {\n    public String printBin(double num) {\n        StringBuilder ans = new StringBuilder(\"0.\");\n        while (ans.length() &lt; 32 &amp;&amp; num != 0) {\n            num *= 2;\n            int x = (int) num;\n            ans.append(x);\n            num -= x;\n        }\n        return num != 0 ? \"ERROR\" : ans.toString();\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    string printBin(double num) {\n        string ans = \"0.\";\n        while (ans.size() &lt; 32 &amp;&amp; num != 0) {\n            num *= 2;\n            int x = (int) num;\n            ans.push_back('0' + x);\n            num -= x;\n        }\n        return num != 0 ? \"ERROR\" : ans;\n    }\n};\n</code></pre> <pre><code>func printBin(num float64) string {\n    ans := &amp;strings.Builder{}\n    ans.WriteString(\"0.\")\n    for ans.Len() &lt; 32 &amp;&amp; num != 0 {\n        num *= 2\n        x := byte(num)\n        ans.WriteByte('0' + x)\n        num -= float64(x)\n    }\n    if num != 0 {\n        return \"ERROR\"\n    }\n    return ans.String()\n}\n</code></pre>"},{"location":"lcci/5.3.html","title":"05.03. Reverse Bits","text":""},{"location":"lcci/5.3.html#description","title":"Description","text":"<p>You have an integer and you can flip exactly one bit from a 0 to a 1. Write code to find the length of the longest sequence of 1s you could create.</p> <p>Example 1: </p> <pre>\n\nInput: <code>num</code> = 1775(11011101111<sub>2</sub>)\n\nOutput: 8\n\n</pre> <p>Example 2: </p> <pre>\n\nInput: <code>num</code> = 7(0111<sub>2</sub>)\n\nOutput: 4\n\n</pre>"},{"location":"lcci/5.3.html#solutions","title":"Solutions","text":""},{"location":"lcci/5.3.html#solution-1-two-pointers","title":"Solution 1: Two Pointers","text":"<p>We can use two pointers $i$ and $j$ to maintain a sliding window, where $i$ is the right pointer and $j$ is the left pointer. Each time the right pointer $i$ moves one bit to the right, if the number of $0$s in the window exceeds $1$, then the left pointer $j$ moves one bit to the right, until the number of $0$s in the window does not exceed $1$. Then calculate the length of the window at this time, compare it with the current maximum length, and take the larger value as the current maximum length.</p> <p>Finally, return the maximum length.</p> <p>The time complexity is $O(\\log M)$, and the space complexity is $O(1)$. Here, $M$ is the maximum value of a 32-bit integer.</p> Python3JavaC++Go <pre><code>class Solution:\n    def reverseBits(self, num: int) -&gt; int:\n        ans = cnt = j = 0\n        for i in range(32):\n            cnt += num &gt;&gt; i &amp; 1 ^ 1\n            while cnt &gt; 1:\n                cnt -= num &gt;&gt; j &amp; 1 ^ 1\n                j += 1\n            ans = max(ans, i - j + 1)\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int reverseBits(int num) {\n        int ans = 0, cnt = 0;\n        for (int i = 0, j = 0; i &lt; 32; ++i) {\n            cnt += num &gt;&gt; i &amp; 1 ^ 1;\n            while (cnt &gt; 1) {\n                cnt -= num &gt;&gt; j &amp; 1 ^ 1;\n                ++j;\n            }\n            ans = Math.max(ans, i - j + 1);\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int reverseBits(int num) {\n        int ans = 0, cnt = 0;\n        for (int i = 0, j = 0; i &lt; 32; ++i) {\n            cnt += num &gt;&gt; i &amp; 1 ^ 1;\n            while (cnt &gt; 1) {\n                cnt -= num &gt;&gt; j &amp; 1 ^ 1;\n                ++j;\n            }\n            ans = max(ans, i - j + 1);\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func reverseBits(num int) (ans int) {\n    var cnt, j int\n    for i := 0; i &lt; 32; i++ {\n        cnt += num&gt;&gt;i&amp;1 ^ 1\n        for cnt &gt; 1 {\n            cnt -= num&gt;&gt;j&amp;1 ^ 1\n            j++\n        }\n        ans = max(ans, i-j+1)\n    }\n    return\n}\n</code></pre>"},{"location":"lcci/5.4.html","title":"05.04. Closed Number","text":""},{"location":"lcci/5.4.html#description","title":"Description","text":"<p>Given a positive integer, print the next smallest and the next largest number that have the same number of 1 bits in their binary representation.</p> <p>Example1:</p> <pre>\n\n Input: num = 2 (0b10)\n\n Output: [4, 1] ([0b100, 0b1])\n\n</pre> <p>Example2:</p> <pre>\n\n Input: num = 1\n\n Output: [2, -1]\n\n</pre> <p>Note:</p> <ol> <li><code>1 &lt;= num &lt;=\u00a02147483647</code></li> <li>If there is no next smallest or next largest number, output -1.</li> </ol>"},{"location":"lcci/5.4.html#solutions","title":"Solutions","text":""},{"location":"lcci/5.4.html#solution-1-bit-manipulation","title":"Solution 1: Bit Manipulation","text":"<p>First, let's consider how to find the first number that is larger than $num$ and has the same number of $1$s in its binary representation.</p> <p>We can traverse the adjacent two binary bits of $num$ from low to high. If the lower bit is $1$ and the adjacent higher bit is $0$, then we have found a position where we can change the $0$ at this position to $1$ and change the $1$ at this position to $0$. Then we move all the remaining lower bits of $1$ to the lowest bit, so we get a number that is larger than $num$ and has the same number of $1$s in its binary representation.</p> <p>Similarly, we can find the first number that is smaller than $num$ and has the same number of $1$s in its binary representation.</p> <p>We can traverse the adjacent two binary bits of $num$ from low to high. If the lower bit is $0$ and the adjacent higher bit is $1$, then we have found a position where we can change the $1$ at this position to $0$ and change the $0$ at this position to $1$. Then we move all the remaining lower bits of $0$ to the lowest bit, so we get a number that is smaller than $num$ and has the same number of $1$s in its binary representation.</p> <p>In implementation, we can use a piece of code to handle the above two situations uniformly.</p> <p>The time complexity is $O(\\log n)$, where $n$ is the size of $num$. The space complexity is $O(1)$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def findClosedNumbers(self, num: int) -&gt; List[int]:\n        ans = [-1] * 2\n        dirs = (0, 1, 0)\n        for p in range(2):\n            a, b = dirs[p], dirs[p + 1]\n            x = num\n            for i in range(1, 31):\n                if (x &gt;&gt; i &amp; 1) == a and (x &gt;&gt; (i - 1) &amp; 1) == b:\n                    x ^= 1 &lt;&lt; i\n                    x ^= 1 &lt;&lt; (i - 1)\n                    j, k = 0, i - 2\n                    while j &lt; k:\n                        while j &lt; k and (x &gt;&gt; j &amp; 1) == b:\n                            j += 1\n                        while j &lt; k and (x &gt;&gt; k &amp; 1) == a:\n                            k -= 1\n                        if j &lt; k:\n                            x ^= 1 &lt;&lt; j\n                            x ^= 1 &lt;&lt; k\n                    ans[p] = x\n                    break\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int[] findClosedNumbers(int num) {\n        int[] ans = {-1, -1};\n        int[] dirs = {0, 1, 0};\n        for (int p = 0; p &lt; 2; ++p) {\n            int a = dirs[p], b = dirs[p + 1];\n            int x = num;\n            for (int i = 1; i &lt; 31; ++i) {\n                if ((x &gt;&gt; i &amp; 1) == a &amp;&amp; (x &gt;&gt; (i - 1) &amp; 1) == b) {\n                    x ^= 1 &lt;&lt; i;\n                    x ^= 1 &lt;&lt; (i - 1);\n                    int j = 0, k = i - 2;\n                    while (j &lt; k) {\n                        while (j &lt; k &amp;&amp; (x &gt;&gt; j &amp; 1) == b) {\n                            ++j;\n                        }\n                        while (j &lt; k &amp;&amp; (x &gt;&gt; k &amp; 1) == a) {\n                            --k;\n                        }\n                        if (j &lt; k) {\n                            x ^= 1 &lt;&lt; j;\n                            x ^= 1 &lt;&lt; k;\n                        }\n                    }\n                    ans[p] = x;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; findClosedNumbers(int num) {\n        vector&lt;int&gt; ans(2, -1);\n        int dirs[3] = {0, 1, 0};\n        for (int p = 0; p &lt; 2; ++p) {\n            int a = dirs[p], b = dirs[p + 1];\n            int x = num;\n            for (int i = 1; i &lt; 31; ++i) {\n                if ((x &gt;&gt; i &amp; 1) == a &amp;&amp; (x &gt;&gt; (i - 1) &amp; 1) == b) {\n                    x ^= 1 &lt;&lt; i;\n                    x ^= 1 &lt;&lt; (i - 1);\n                    int j = 0, k = i - 2;\n                    while (j &lt; k) {\n                        while (j &lt; k &amp;&amp; (x &gt;&gt; j &amp; 1) == b) {\n                            ++j;\n                        }\n                        while (j &lt; k &amp;&amp; (x &gt;&gt; k &amp; 1) == a) {\n                            --k;\n                        }\n                        if (j &lt; k) {\n                            x ^= 1 &lt;&lt; j;\n                            x ^= 1 &lt;&lt; k;\n                        }\n                    }\n                    ans[p] = x;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func findClosedNumbers(num int) []int {\n    ans := []int{-1, -1}\n    dirs := [3]int{0, 1, 0}\n    for p := 0; p &lt; 2; p++ {\n        a, b := dirs[p], dirs[p+1]\n        x := num\n        for i := 1; i &lt; 31; i++ {\n            if x&gt;&gt;i&amp;1 == a &amp;&amp; x&gt;&gt;(i-1)&amp;1 == b {\n                x ^= 1 &lt;&lt; i\n                x ^= 1 &lt;&lt; (i - 1)\n                j, k := 0, i-2\n                for j &lt; k {\n                    for j &lt; k &amp;&amp; x&gt;&gt;j&amp;1 == b {\n                        j++\n                    }\n                    for j &lt; k &amp;&amp; x&gt;&gt;k&amp;1 == a {\n                        k--\n                    }\n                    if j &lt; k {\n                        x ^= 1 &lt;&lt; j\n                        x ^= 1 &lt;&lt; k\n                    }\n                }\n                ans[p] = x\n                break\n            }\n        }\n    }\n    return ans\n}\n</code></pre> <pre><code>function findClosedNumbers(num: number): number[] {\n    const ans: number[] = [-1, -1];\n    const dirs: number[] = [0, 1, 0];\n    for (let p = 0; p &lt; 2; ++p) {\n        const [a, b] = [dirs[p], dirs[p + 1]];\n        let x = num;\n        for (let i = 1; i &lt; 31; ++i) {\n            if (((x &gt;&gt; i) &amp; 1) === a &amp;&amp; ((x &gt;&gt; (i - 1)) &amp; 1) === b) {\n                x ^= 1 &lt;&lt; i;\n                x ^= 1 &lt;&lt; (i - 1);\n                let [j, k] = [0, i - 2];\n                while (j &lt; k) {\n                    while (j &lt; k &amp;&amp; ((x &gt;&gt; j) &amp; 1) === b) {\n                        ++j;\n                    }\n                    while (j &lt; k &amp;&amp; ((x &gt;&gt; k) &amp; 1) === a) {\n                        --k;\n                    }\n                    if (j &lt; k) {\n                        x ^= 1 &lt;&lt; j;\n                        x ^= 1 &lt;&lt; k;\n                    }\n                }\n                ans[p] = x;\n                break;\n            }\n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"lcci/5.6.html","title":"05.06. Convert Integer","text":""},{"location":"lcci/5.6.html#description","title":"Description","text":"<p>Write a function to determine the number of bits you would need to flip to convert integer A to integer B.</p> <p>Example1:</p> <pre>\n\n\n\n Input: A = 29 (0b11101), B = 15 (0b01111)\n\n\n\n Output: 2\n\n\n\n</pre> <p>Example2:</p> <pre>\n\n\n\n Input: A = 1\uff0cB = 2\n\n\n\n Output: 2\n\n\n\n</pre> <p>Note:</p> <ol> <li><code>-2147483648 &lt;= A, B &lt;= 2147483647</code></li> </ol>"},{"location":"lcci/5.6.html#solutions","title":"Solutions","text":""},{"location":"lcci/5.6.html#solution-1-bit-manipulation","title":"Solution 1: Bit Manipulation","text":"<p>We perform a bitwise XOR operation on A and B. The number of $1$s in the result is the number of bits that need to be changed.</p> <p>The time complexity is $O(\\log n)$, where $n$ is the maximum value of A and B. The space complexity is $O(1)$.</p> Python3JavaC++GoTypeScriptRust <pre><code>class Solution:\n    def convertInteger(self, A: int, B: int) -&gt; int:\n        A &amp;= 0xFFFFFFFF\n        B &amp;= 0xFFFFFFFF\n        return (A ^ B).bit_count()\n</code></pre> <pre><code>class Solution {\n    public int convertInteger(int A, int B) {\n        return Integer.bitCount(A ^ B);\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int convertInteger(int A, int B) {\n        unsigned int c = A ^ B;\n        return __builtin_popcount(c);\n    }\n};\n</code></pre> <pre><code>func convertInteger(A int, B int) int {\n    return bits.OnesCount32(uint32(A ^ B))\n}\n</code></pre> <pre><code>function convertInteger(A: number, B: number): number {\n    let res = 0;\n    while (A !== 0 || B !== 0) {\n        if ((A &amp; 1) !== (B &amp; 1)) {\n            res++;\n        }\n        A &gt;&gt;&gt;= 1;\n        B &gt;&gt;&gt;= 1;\n    }\n    return res;\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn convert_integer(a: i32, b: i32) -&gt; i32 {\n        (a ^ b).count_ones() as i32\n    }\n}\n</code></pre>"},{"location":"lcci/5.7.html","title":"05.07. Exchange","text":""},{"location":"lcci/5.7.html#description","title":"Description","text":"<p>Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on).</p> <p>Example1:</p> <pre>\n\n Input: num = 2\uff080b10\uff09\n\n Output 1 (0b01)\n\n</pre> <p>Example2:</p> <pre>\n\n Input: num = 3\n\n Output: 3\n\n</pre> <p>Note:</p> <ol> <li><code>0 &lt;= num &lt;=</code>\u00a02^30 - 1</li> <li>The result integer fits into 32-bit integer.</li> </ol>"},{"location":"lcci/5.7.html#solutions","title":"Solutions","text":""},{"location":"lcci/5.7.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoRust <pre><code>class Solution:\n    def exchangeBits(self, num: int) -&gt; int:\n        return ((num &amp; 0x55555555) &lt;&lt; 1) | ((num &amp; 0xAAAAAAAA) &gt;&gt; 1)\n</code></pre> <pre><code>class Solution {\n    public int exchangeBits(int num) {\n        return ((num &amp; 0x55555555) &lt;&lt; 1) | ((num &amp; 0xaaaaaaaa)) &gt;&gt; 1;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int exchangeBits(int num) {\n        return ((num &amp; 0x55555555) &lt;&lt; 1) | ((num &amp; 0xaaaaaaaa)) &gt;&gt; 1;\n    }\n};\n</code></pre> <pre><code>func exchangeBits(num int) int {\n    return ((num &amp; 0x55555555) &lt;&lt; 1) | (num&amp;0xaaaaaaaa)&gt;&gt;1\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn exchange_bits(mut num: i32) -&gt; i32 {\n        let mut res = 0;\n        let mut i = 0;\n        while num != 0 {\n            let a = num &amp; 1;\n            num &gt;&gt;= 1;\n            let b = num &amp; 1;\n            num &gt;&gt;= 1;\n            res |= a &lt;&lt; (i + 1);\n            res |= b &lt;&lt; i;\n            i += 2;\n        }\n        res\n    }\n}\n</code></pre>"},{"location":"lcci/5.8.html","title":"05.08. Draw Line","text":""},{"location":"lcci/5.8.html#description","title":"Description","text":"<p>A monochrome screen is stored as a single array of int, allowing 32 consecutive pixels to be stored in one int. The screen has width <code>w</code>, where <code>w</code> is divisible by 32\u00a0(that is, no byte will be split across rows). The height of the screen, of course, can be derived from the length of the array and the width. Implement a function that draws a horizontal line from <code>(x1, y)</code> to <code>(x2, y)</code>.</p> <p>Given the length of the array, the width of the array (in bit), start position <code>x1</code>\u00a0(in bit) of the line, end position <code>x2</code> (in bit) of the line and the row number\u00a0<code>y</code> of the line, return the array after drawing.</p> <p>Example1:</p> <pre>\n\n Input: length = 1, w = 32, x1 = 30, x2 = 31, y = 0\n\n Output: [3]\n\n Explanation: After drawing a line from (30, 0) to (31, 0), the screen becomes [0b000000000000000000000000000000011].\n\n</pre> <p>Example2:</p> <pre>\n\n Input: length = 3, w = 96, x1 = 0, x2 = 95, y = 0\n\n Output: [-1, -1, -1]\n\n</pre>"},{"location":"lcci/5.8.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.1.html","title":"08.01. Three Steps Problem","text":""},{"location":"lcci/8.1.html#description","title":"Description","text":"<p>A child is running up a staircase with n steps and can hop either 1 step, 2 steps, or 3 steps at a time. Implement a method to count how many possible ways the child can run up the stairs.\u00a0The result may be large, so return it modulo 1000000007.</p> <p>Example1:</p> <pre>\n\n Input: n = 3 \n\n Output: 4\n\n</pre> <p>Example2:</p> <pre>\n\n Input: n = 5\n\n Output: 13\n\n</pre> <p>Note:</p> <ol> <li><code>1 &lt;= n &lt;= 1000000</code></li> </ol>"},{"location":"lcci/8.1.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.1.html#solution-1-recursion","title":"Solution 1: Recursion","text":"<p>We define $f[i]$ as the number of ways to reach the $i$-th step, initially $f[1]=1$, $f[2]=2$, $f[3]=4$. The answer is $f[n]$.</p> <p>The recursion formula is $f[i] = f[i-1] + f[i-2] + f[i-3]$.</p> <p>Since $f[i]$ is only related to $f[i-1]$, $f[i-2]$, $f[i-3]$, we can use three variables $a$, $b$, $c$ to store the values of $f[i-1]$, $f[i-2]$, $f[i-3]$, reducing the space complexity to $O(1)$.</p> <p>The time complexity is $O(n)$, where $n$ is the given integer. The space complexity is $O(1)$.</p> Python3JavaC++GoRustJavaScriptC <pre><code>class Solution:\n    def waysToStep(self, n: int) -&gt; int:\n        a, b, c = 1, 2, 4\n        mod = 10**9 + 7\n        for _ in range(n - 1):\n            a, b, c = b, c, (a + b + c) % mod\n        return a\n</code></pre> <pre><code>class Solution {\n    public int waysToStep(int n) {\n        final int mod = (int) 1e9 + 7;\n        int a = 1, b = 2, c = 4;\n        for (int i = 1; i &lt; n; ++i) {\n            int t = a;\n            a = b;\n            b = c;\n            c = (((a + b) % mod) + t) % mod;\n        }\n        return a;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int waysToStep(int n) {\n        const int mod = 1e9 + 7;\n        int a = 1, b = 2, c = 4;\n        for (int i = 1; i &lt; n; ++i) {\n            int t = a;\n            a = b;\n            b = c;\n            c = (((a + b) % mod) + t) % mod;\n        }\n        return a;\n    }\n};\n</code></pre> <pre><code>func waysToStep(n int) int {\n    const mod int = 1e9 + 7\n    a, b, c := 1, 2, 4\n    for i := 1; i &lt; n; i++ {\n        a, b, c = b, c, (a+b+c)%mod\n    }\n    return a\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn ways_to_step(n: i32) -&gt; i32 {\n        let (mut a, mut b, mut c) = (1, 2, 4);\n        let m = 1000000007;\n        for _ in 1..n {\n            let t = a;\n            a = b;\n            b = c;\n            c = (((a + b) % m) + t) % m;\n        }\n        a\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number} n\n * @return {number}\n */\nvar waysToStep = function (n) {\n    let [a, b, c] = [1, 2, 4];\n    const mod = 1e9 + 7;\n    for (let i = 1; i &lt; n; ++i) {\n        [a, b, c] = [b, c, (a + b + c) % mod];\n    }\n    return a;\n};\n</code></pre> <pre><code>int waysToStep(int n) {\n    const int mod = 1e9 + 7;\n    int a = 1, b = 2, c = 4;\n    for (int i = 1; i &lt; n; ++i) {\n        int t = a;\n        a = b;\n        b = c;\n        c = (((a + b) % mod) + t) % mod;\n    }\n    return a;\n}\n</code></pre>"},{"location":"lcci/8.1.html#solution-2-matrix-quick-power-to-accelerate-recursion","title":"Solution 2: Matrix Quick Power to Accelerate Recursion","text":"<p>We set $F(n)$ to represent a $1 \\times 3$ matrix $\\begin{bmatrix} F_{n - 1} &amp; F_{n - 2} &amp; F_{n - 3} \\end{bmatrix}$, where $F_{n - 1}$, $F_{n - 2}$ and $F_{n - 3}$ respectively represent the number of ways to reach the $n - 1$-th, $n - 2$-th and $n - 3$-th steps.</p> <p>We hope to derive $F(n)$ based on $F(n-1) = \\begin{bmatrix} F_{n - 2} &amp; F_{n - 3} &amp; F_{n - 4} \\end{bmatrix}$. That is to say, we need a matrix $base$, so that $F(n - 1) \\times base = F(n)$, i.e.:</p> <p>$$ \\begin{bmatrix} F_{n - 2} &amp; F_{n - 3} &amp; F_{n - 4} \\end{bmatrix} \\times base = \\begin{bmatrix} F_{n - 1} &amp; F_{n - 2} &amp; F_{n - 3} \\end{bmatrix} $$</p> <p>Since $F_n = F_{n - 1} + F_{n - 2} + F_{n - 3}$, the matrix $base$ is:</p> <p>$$ \\begin{bmatrix}  1 &amp; 1 &amp; 0 \\  1 &amp; 0 &amp; 1 \\  1 &amp; 0 &amp; 0 \\end{bmatrix} $$</p> <p>We define the initial matrix $res = \\begin{bmatrix} 1 &amp; 1  &amp; 0 \\end{bmatrix}$, then $F_n$ equals the sum of all elements in the result matrix of $res$ multiplied by $base^{n - 4}$. It can be solved using matrix quick power.</p> <p>The time complexity is $O(\\log n)$, and the space complexity is $O(1)$.</p> Python3JavaC++GoJavaScript <pre><code>class Solution:\n    def waysToStep(self, n: int) -&gt; int:\n        mod = 10**9 + 7\n\n        def mul(a: List[List[int]], b: List[List[int]]) -&gt; List[List[int]]:\n            m, n = len(a), len(b[0])\n            c = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    for k in range(len(a[0])):\n                        c[i][j] = (c[i][j] + a[i][k] * b[k][j] % mod) % mod\n            return c\n\n        def pow(a: List[List[int]], n: int) -&gt; List[List[int]]:\n            res = [[4, 2, 1]]\n            while n:\n                if n &amp; 1:\n                    res = mul(res, a)\n                n &gt;&gt;= 1\n                a = mul(a, a)\n            return res\n\n        if n &lt; 4:\n            return 2 ** (n - 1)\n        a = [[1, 1, 0], [1, 0, 1], [1, 0, 0]]\n        return sum(pow(a, n - 4)[0]) % mod\n</code></pre> <pre><code>class Solution {\n    private final int mod = (int) 1e9 + 7;\n\n    public int waysToStep(int n) {\n        if (n &lt; 4) {\n            return (int) Math.pow(2, n - 1);\n        }\n        long[][] a = {{1, 1, 0}, {1, 0, 1}, {1, 0, 0}};\n        long[][] res = pow(a, n - 4);\n        long ans = 0;\n        for (long x : res[0]) {\n            ans = (ans + x) % mod;\n        }\n        return (int) ans;\n    }\n\n    private long[][] mul(long[][] a, long[][] b) {\n        int m = a.length, n = b[0].length;\n        long[][] c = new long[m][n];\n        for (int i = 0; i &lt; m; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                for (int k = 0; k &lt; b.length; ++k) {\n                    c[i][j] = (c[i][j] + a[i][k] * b[k][j] % mod) % mod;\n                }\n            }\n        }\n        return c;\n    }\n\n    private long[][] pow(long[][] a, int n) {\n        long[][] res = {{4, 2, 1}};\n        while (n &gt; 0) {\n            if ((n &amp; 1) == 1) {\n                res = mul(res, a);\n            }\n            a = mul(a, a);\n            n &gt;&gt;= 1;\n        }\n        return res;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int waysToStep(int n) {\n        if (n &lt; 4) {\n            return pow(2, n - 1);\n        }\n        vector&lt;vector&lt;ll&gt;&gt; a = {{1, 1, 0}, {1, 0, 1}, {1, 0, 0}};\n        vector&lt;vector&lt;ll&gt;&gt; res = qpow(a, n - 4);\n        ll ans = 0;\n        for (ll x : res[0]) {\n            ans = (ans + x) % mod;\n        }\n        return ans;\n    }\n\nprivate:\n    using ll = long long;\n    const int mod = 1e9 + 7;\n    vector&lt;vector&lt;ll&gt;&gt; mul(vector&lt;vector&lt;ll&gt;&gt;&amp; a, vector&lt;vector&lt;ll&gt;&gt;&amp; b) {\n        int m = a.size(), n = b[0].size();\n        vector&lt;vector&lt;ll&gt;&gt; c(m, vector&lt;ll&gt;(n));\n        for (int i = 0; i &lt; m; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                for (int k = 0; k &lt; b.size(); ++k) {\n                    c[i][j] = (c[i][j] + a[i][k] * b[k][j] % mod) % mod;\n                }\n            }\n        }\n        return c;\n    }\n\n    vector&lt;vector&lt;ll&gt;&gt; qpow(vector&lt;vector&lt;ll&gt;&gt;&amp; a, int n) {\n        vector&lt;vector&lt;ll&gt;&gt; res = {{4, 2, 1}};\n        while (n) {\n            if (n &amp; 1) {\n                res = mul(res, a);\n            }\n            a = mul(a, a);\n            n &gt;&gt;= 1;\n        }\n        return res;\n    }\n};\n</code></pre> <pre><code>const mod = 1e9 + 7\n\nfunc waysToStep(n int) (ans int) {\n    if n &lt; 4 {\n        return int(math.Pow(2, float64(n-1)))\n    }\n    a := [][]int{{1, 1, 0}, {1, 0, 1}, {1, 0, 0}}\n    res := pow(a, n-4)\n    for _, x := range res[0] {\n        ans = (ans + x) % mod\n    }\n    return\n}\n\nfunc mul(a, b [][]int) [][]int {\n    m, n := len(a), len(b[0])\n    c := make([][]int, m)\n    for i := range c {\n        c[i] = make([]int, n)\n    }\n    for i := 0; i &lt; m; i++ {\n        for j := 0; j &lt; n; j++ {\n            for k := 0; k &lt; len(b); k++ {\n                c[i][j] = (c[i][j] + a[i][k]*b[k][j]%mod) % mod\n            }\n        }\n    }\n    return c\n}\n\nfunc pow(a [][]int, n int) [][]int {\n    res := [][]int{{4, 2, 1}}\n    for n &gt; 0 {\n        if n&amp;1 == 1 {\n            res = mul(res, a)\n        }\n        a = mul(a, a)\n        n &gt;&gt;= 1\n    }\n    return res\n}\n</code></pre> <pre><code>/**\n * @param {number} n\n * @return {number}\n */\n\nconst mod = 1e9 + 7;\n\nvar waysToStep = function (n) {\n    if (n &lt; 4) {\n        return Math.pow(2, n - 1);\n    }\n    const a = [\n        [1, 1, 0],\n        [1, 0, 1],\n        [1, 0, 0],\n    ];\n    let ans = 0;\n    const res = pow(a, n - 4);\n    for (const x of res[0]) {\n        ans = (ans + x) % mod;\n    }\n    return ans;\n};\n\nfunction mul(a, b) {\n    const [m, n] = [a.length, b[0].length];\n    const c = Array.from({ length: m }, () =&gt; Array.from({ length: n }, () =&gt; 0));\n    for (let i = 0; i &lt; m; ++i) {\n        for (let j = 0; j &lt; n; ++j) {\n            for (let k = 0; k &lt; b.length; ++k) {\n                c[i][j] =\n                    (c[i][j] + Number((BigInt(a[i][k]) * BigInt(b[k][j])) % BigInt(mod))) % mod;\n            }\n        }\n    }\n    return c;\n}\n\nfunction pow(a, n) {\n    let res = [[4, 2, 1]];\n    while (n) {\n        if (n &amp; 1) {\n            res = mul(res, a);\n        }\n        a = mul(a, a);\n        n &gt;&gt;= 1;\n    }\n    return res;\n}\n</code></pre>"},{"location":"lcci/8.1.html#solution-3","title":"Solution 3","text":"Python3 <pre><code>import numpy as np\n\n\nclass Solution:\n    def waysToStep(self, n: int) -&gt; int:\n        if n &lt; 4:\n            return 2 ** (n - 1)\n        mod = 10**9 + 7\n        factor = np.mat([(1, 1, 0), (1, 0, 1), (1, 0, 0)], np.dtype(\"O\"))\n        res = np.mat([(4, 2, 1)], np.dtype(\"O\"))\n        n -= 4\n        while n:\n            if n &amp; 1:\n                res = res * factor % mod\n            factor = factor * factor % mod\n            n &gt;&gt;= 1\n        return res.sum() % mod\n</code></pre>"},{"location":"lcci/8.10.html","title":"08.10. Color Fill","text":""},{"location":"lcci/8.10.html#description","title":"Description","text":"<p>Implement the \"paint fill\" function that one might see on many image editing programs. That is, given a screen (represented by a two-dimensional array of colors), a point, and a new color, fill in the surrounding area until the color changes from the original color.</p> <p>Example1:</p> <pre>\n\nInput: \n\nimage = [[1,1,1],[1,1,0],[1,0,1]] \n\nsr = 1, sc = 1, newColor = 2\n\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\n\nExplanation: \n\nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels connected \n\nby a path of the same color as the starting pixel are colored with the new color.\n\nNote the bottom corner is not colored 2, because it is not 4-directionally connected\n\nto the starting pixel.</pre> <p>Note:</p> <ul> <li>The length of\u00a0<code>image</code>\u00a0and\u00a0<code>image[0]</code>\u00a0will be in the range\u00a0<code>[1, 50]</code>.</li> <li>The given starting pixel will satisfy\u00a0<code>0 &lt;= sr &lt; image.length</code>\u00a0and\u00a0<code>0 &lt;= sc &lt; image[0].length</code>.</li> <li>The value of each color in\u00a0<code>image[i][j]</code>\u00a0and\u00a0<code>newColor</code>\u00a0will be an integer in\u00a0<code>[0, 65535]</code>.</li> </ul>"},{"location":"lcci/8.10.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.10.html#solution-1-flood-fill-algorithm","title":"Solution 1: Flood Fill Algorithm","text":"<p>The Flood Fill algorithm is a classic algorithm used to extract several connected points from a region and distinguish them from other adjacent regions (or color them differently). It is named for its strategy, which is similar to a flood spreading from one area to all reachable areas.</p> <p>The simplest implementation method is to use the recursive method of DFS, or it can be implemented iteratively using BFS.</p> <p>The time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of rows and columns of the image, respectively.</p> Python3JavaC++GoRust <pre><code>class Solution:\n    def floodFill(\n        self, image: List[List[int]], sr: int, sc: int, newColor: int\n    ) -&gt; List[List[int]]:\n        def dfs(i, j):\n            if (\n                not 0 &lt;= i &lt; m\n                or not 0 &lt;= j &lt; n\n                or image[i][j] != oc\n                or image[i][j] == newColor\n            ):\n                return\n            image[i][j] = newColor\n            for a, b in pairwise(dirs):\n                dfs(i + a, j + b)\n\n        dirs = (-1, 0, 1, 0, -1)\n        m, n = len(image), len(image[0])\n        oc = image[sr][sc]\n        dfs(sr, sc)\n        return image\n</code></pre> <pre><code>class Solution {\n    private int[] dirs = {-1, 0, 1, 0, -1};\n    private int[][] image;\n    private int nc;\n    private int oc;\n\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        nc = newColor;\n        oc = image[sr][sc];\n        this.image = image;\n        dfs(sr, sc);\n        return image;\n    }\n\n    private void dfs(int i, int j) {\n        if (i &lt; 0 || i &gt;= image.length || j &lt; 0 || j &gt;= image[0].length || image[i][j] != oc\n            || image[i][j] == nc) {\n            return;\n        }\n        image[i][j] = nc;\n        for (int k = 0; k &lt; 4; ++k) {\n            dfs(i + dirs[k], j + dirs[k + 1]);\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) {\n        int m = image.size(), n = image[0].size();\n        int oc = image[sr][sc];\n        int dirs[5] = {-1, 0, 1, 0, -1};\n        function&lt;void(int, int)&gt; dfs = [&amp;](int i, int j) {\n            if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || image[i][j] != oc || image[i][j] == newColor) {\n                return;\n            }\n            image[i][j] = newColor;\n            for (int k = 0; k &lt; 4; ++k) {\n                dfs(i + dirs[k], j + dirs[k + 1]);\n            }\n        };\n        dfs(sr, sc);\n        return image;\n    }\n};\n</code></pre> <pre><code>func floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\n    oc := image[sr][sc]\n    m, n := len(image), len(image[0])\n    dirs := []int{-1, 0, 1, 0, -1}\n    var dfs func(i, j int)\n    dfs = func(i, j int) {\n        if i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || image[i][j] != oc || image[i][j] == newColor {\n            return\n        }\n        image[i][j] = newColor\n        for k := 0; k &lt; 4; k++ {\n            dfs(i+dirs[k], j+dirs[k+1])\n        }\n    }\n    dfs(sr, sc)\n    return image\n}\n</code></pre> <pre><code>impl Solution {\n    fn dfs(i: usize, j: usize, target: i32, new_color: i32, image: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {\n        if image[i][j] != target {\n            return;\n        }\n        image[i][j] = new_color;\n        if i != 0 {\n            Self::dfs(i - 1, j, target, new_color, image);\n        }\n        if j != 0 {\n            Self::dfs(i, j - 1, target, new_color, image);\n        }\n        if i + 1 != image.len() {\n            Self::dfs(i + 1, j, target, new_color, image);\n        }\n        if j + 1 != image[0].len() {\n            Self::dfs(i, j + 1, target, new_color, image);\n        }\n    }\n\n    pub fn flood_fill(mut image: Vec&lt;Vec&lt;i32&gt;&gt;, sr: i32, sc: i32, new_color: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n        let (sr, sc) = (sr as usize, sc as usize);\n        let target = image[sr][sc];\n        if target == new_color {\n            return image;\n        }\n        Self::dfs(sr, sc, target, new_color, &amp;mut image);\n        image\n    }\n}\n</code></pre>"},{"location":"lcci/8.10.html#solution-2","title":"Solution 2","text":"Python3JavaC++Go <pre><code>class Solution:\n    def floodFill(\n        self, image: List[List[int]], sr: int, sc: int, newColor: int\n    ) -&gt; List[List[int]]:\n        if image[sr][sc] == newColor:\n            return image\n        q = deque([(sr, sc)])\n        oc = image[sr][sc]\n        image[sr][sc] = newColor\n        dirs = (-1, 0, 1, 0, -1)\n        while q:\n            i, j = q.popleft()\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 &lt;= x &lt; len(image) and 0 &lt;= y &lt; len(image[0]) and image[x][y] == oc:\n                    q.append((x, y))\n                    image[x][y] = newColor\n        return image\n</code></pre> <pre><code>class Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        if (image[sr][sc] == newColor) {\n            return image;\n        }\n        Deque&lt;int[]&gt; q = new ArrayDeque&lt;&gt;();\n        q.offer(new int[] {sr, sc});\n        int oc = image[sr][sc];\n        image[sr][sc] = newColor;\n        int[] dirs = {-1, 0, 1, 0, -1};\n        while (!q.isEmpty()) {\n            int[] p = q.poll();\n            int i = p[0], j = p[1];\n            for (int k = 0; k &lt; 4; ++k) {\n                int x = i + dirs[k], y = j + dirs[k + 1];\n                if (x &gt;= 0 &amp;&amp; x &lt; image.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; image[0].length\n                    &amp;&amp; image[x][y] == oc) {\n                    q.offer(new int[] {x, y});\n                    image[x][y] = newColor;\n                }\n            }\n        }\n        return image;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) {\n        if (image[sr][sc] == newColor) return image;\n        int oc = image[sr][sc];\n        image[sr][sc] = newColor;\n        queue&lt;pair&lt;int, int&gt;&gt; q;\n        q.push({sr, sc});\n        int dirs[5] = {-1, 0, 1, 0, -1};\n        while (!q.empty()) {\n            auto [a, b] = q.front();\n            q.pop();\n            for (int k = 0; k &lt; 4; ++k) {\n                int x = a + dirs[k];\n                int y = b + dirs[k + 1];\n                if (x &gt;= 0 &amp;&amp; x &lt; image.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; image[0].size() &amp;&amp; image[x][y] == oc) {\n                    q.push({x, y});\n                    image[x][y] = newColor;\n                }\n            }\n        }\n        return image;\n    }\n};\n</code></pre> <pre><code>func floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\n    if image[sr][sc] == newColor {\n        return image\n    }\n    oc := image[sr][sc]\n    q := [][]int{[]int{sr, sc}}\n    image[sr][sc] = newColor\n    dirs := []int{-1, 0, 1, 0, -1}\n    for len(q) &gt; 0 {\n        p := q[0]\n        q = q[1:]\n        for k := 0; k &lt; 4; k++ {\n            x, y := p[0]+dirs[k], p[1]+dirs[k+1]\n            if x &gt;= 0 &amp;&amp; x &lt; len(image) &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; len(image[0]) &amp;&amp; image[x][y] == oc {\n                q = append(q, []int{x, y})\n                image[x][y] = newColor\n            }\n        }\n    }\n    return image\n}\n</code></pre>"},{"location":"lcci/8.11.html","title":"08.11. Coin","text":""},{"location":"lcci/8.11.html#description","title":"Description","text":"<p>Given an infinite number of quarters (25 cents), dimes (10 cents), nickels (5 cents), and pennies (1 cent), write code to calculate the number of ways of representing n cents.\u00a0(The result may be large, so you should return it modulo 1000000007)</p> <p>Example1:</p> <pre>\n\n Input: n = 5\n\n Output: 2\n\n Explanation: There are two ways:\n\n5=5\n\n5=1+1+1+1+1\n\n</pre> <p>Example2:</p> <pre>\n\n Input: n = 10\n\n Output: 4\n\n Explanation: There are four ways:\n\n10=10\n\n10=5+5\n\n10=5+1+1+1+1+1\n\n10=1+1+1+1+1+1+1+1+1+1\n\n</pre> <p>Notes: </p> <p>You can assume:</p> <ul> <li>0 &lt;= n\u00a0&lt;= 1000000</li> </ul>"},{"location":"lcci/8.11.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.11.html#solution-1-dynamic-programming","title":"Solution 1: Dynamic Programming","text":"<p>We define $f[i][j]$ as the number of ways to make up the total amount $j$ using only the first $i$ types of coins. Initially, $f[0][0]=1$, and the rest of the elements are $0$. The answer is $f[4][n]$.</p> <p>Considering $f[i][j]$, we can enumerate the number of the $i$-th type of coin used, $k$, where $0 \\leq k \\leq j / c_i$, then $f[i][j]$ is equal to the sum of all $f[i\u22121][j\u2212k \\times c_i]$. Since the number of coins is infinite, $k$ can start from $0$. That is, the state transition equation is as follows:</p> <p>$$ f[i][j] = f[i - 1][j] + f[i - 1][j - c_i] + \\cdots + f[i - 1][j - k \\times c_i] $$</p> <p>Let $j = j - c_i$, then the above state transition equation can be written as:</p> <p>$$ f[i][j - c_i] = f[i - 1][j - c_i] + f[i - 1][j - 2 \\times c_i] + \\cdots + f[i - 1][j - k \\times c_i] $$</p> <p>Substitute the second equation into the first equation to get:</p> <p>$$ f[i][j]= \\begin{cases} f[i - 1][j] + f[i][j - c_i], &amp; j \\geq c_i \\ f[i - 1][j], &amp; j &lt; c_i \\end{cases} $$</p> <p>The final answer is $f[4][n]$.</p> <p>The time complexity is $O(C \\times n)$, and the space complexity is $O(C \\times n)$, where $C$ is the number of types of coins.</p> <p>We notice that the calculation of $f[i][j]$ is only related to $f[i\u22121][..]$, so we can remove the first dimension and optimize the space complexity to $O(n)$.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def waysToChange(self, n: int) -&gt; int:\n        mod = 10**9 + 7\n        coins = [25, 10, 5, 1]\n        f = [[0] * (n + 1) for _ in range(5)]\n        f[0][0] = 1\n        for i, c in enumerate(coins, 1):\n            for j in range(n + 1):\n                f[i][j] = f[i - 1][j]\n                if j &gt;= c:\n                    f[i][j] = (f[i][j] + f[i][j - c]) % mod\n        return f[-1][n]\n</code></pre> <pre><code>class Solution {\n    public int waysToChange(int n) {\n        final int mod = (int) 1e9 + 7;\n        int[] coins = {25, 10, 5, 1};\n        int[][] f = new int[5][n + 1];\n        f[0][0] = 1;\n        for (int i = 1; i &lt;= 4; ++i) {\n            for (int j = 0; j &lt;= n; ++j) {\n                f[i][j] = f[i - 1][j];\n                if (j &gt;= coins[i - 1]) {\n                    f[i][j] = (f[i][j] + f[i][j - coins[i - 1]]) % mod;\n                }\n            }\n        }\n        return f[4][n];\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int waysToChange(int n) {\n        const int mod = 1e9 + 7;\n        vector&lt;int&gt; coins = {25, 10, 5, 1};\n        int f[5][n + 1];\n        memset(f, 0, sizeof(f));\n        f[0][0] = 1;\n        for (int i = 1; i &lt;= 4; ++i) {\n            for (int j = 0; j &lt;= n; ++j) {\n                f[i][j] = f[i - 1][j];\n                if (j &gt;= coins[i - 1]) {\n                    f[i][j] = (f[i][j] + f[i][j - coins[i - 1]]) % mod;\n                }\n            }\n        }\n        return f[4][n];\n    }\n};\n</code></pre> <pre><code>func waysToChange(n int) int {\n    const mod int = 1e9 + 7\n    coins := []int{25, 10, 5, 1}\n    f := make([][]int, 5)\n    for i := range f {\n        f[i] = make([]int, n+1)\n    }\n    f[0][0] = 1\n    for i := 1; i &lt;= 4; i++ {\n        for j := 0; j &lt;= n; j++ {\n            f[i][j] = f[i-1][j]\n            if j &gt;= coins[i-1] {\n                f[i][j] = (f[i][j] + f[i][j-coins[i-1]]) % mod\n            }\n        }\n    }\n    return f[4][n]\n}\n</code></pre> <pre><code>function waysToChange(n: number): number {\n    const mod = 10 ** 9 + 7;\n    const coins: number[] = [25, 10, 5, 1];\n    const f: number[][] = Array(5)\n        .fill(0)\n        .map(() =&gt; Array(n + 1).fill(0));\n    f[0][0] = 1;\n    for (let i = 1; i &lt;= 4; ++i) {\n        for (let j = 0; j &lt;= n; ++j) {\n            f[i][j] = f[i - 1][j];\n            if (j &gt;= coins[i - 1]) {\n                f[i][j] = (f[i][j] + f[i][j - coins[i - 1]]) % mod;\n            }\n        }\n    }\n    return f[4][n];\n}\n</code></pre>"},{"location":"lcci/8.11.html#solution-2","title":"Solution 2","text":"Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def waysToChange(self, n: int) -&gt; int:\n        mod = 10**9 + 7\n        coins = [25, 10, 5, 1]\n        f = [1] + [0] * n\n        for c in coins:\n            for j in range(c, n + 1):\n                f[j] = (f[j] + f[j - c]) % mod\n        return f[n]\n</code></pre> <pre><code>class Solution {\n    public int waysToChange(int n) {\n        final int mod = (int) 1e9 + 7;\n        int[] coins = {25, 10, 5, 1};\n        int[] f = new int[n + 1];\n        f[0] = 1;\n        for (int c : coins) {\n            for (int j = c; j &lt;= n; ++j) {\n                f[j] = (f[j] + f[j - c]) % mod;\n            }\n        }\n        return f[n];\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int waysToChange(int n) {\n        const int mod = 1e9 + 7;\n        vector&lt;int&gt; coins = {25, 10, 5, 1};\n        int f[n + 1];\n        memset(f, 0, sizeof(f));\n        f[0] = 1;\n        for (int c : coins) {\n            for (int j = c; j &lt;= n; ++j) {\n                f[j] = (f[j] + f[j - c]) % mod;\n            }\n        }\n        return f[n];\n    }\n};\n</code></pre> <pre><code>func waysToChange(n int) int {\n    const mod int = 1e9 + 7\n    coins := []int{25, 10, 5, 1}\n    f := make([]int, n+1)\n    f[0] = 1\n    for _, c := range coins {\n        for j := c; j &lt;= n; j++ {\n            f[j] = (f[j] + f[j-c]) % mod\n        }\n    }\n    return f[n]\n}\n</code></pre> <pre><code>function waysToChange(n: number): number {\n    const mod = 10 ** 9 + 7;\n    const coins: number[] = [25, 10, 5, 1];\n    const f: number[] = new Array(n + 1).fill(0);\n    f[0] = 1;\n    for (const c of coins) {\n        for (let i = c; i &lt;= n; ++i) {\n            f[i] = (f[i] + f[i - c]) % mod;\n        }\n    }\n    return f[n];\n}\n</code></pre>"},{"location":"lcci/8.12.html","title":"08.12. Eight Queens","text":""},{"location":"lcci/8.12.html#description","title":"Description","text":"<p>Write an algorithm to print all ways of arranging n queens on an n x n\u00a0chess board so that none of them share the same row, column, or diagonal. In this case, \"diagonal\" means all diagonals, not just the two that bisect the board.</p> <p>Notes: This\u00a0problem is a generalization of the original one in the book.</p> <p>Example:</p> <pre>\n\n Input: 4\n\n Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n\n Explanation: 4 queens has following two solutions\n\n[\n\n\u00a0[\".Q..\", \u00a0// solution 1\n\n\u00a0 \"...Q\",\n\n\u00a0 \"Q...\",\n\n\u00a0 \"..Q.\"],\n\n\n\n\u00a0[\"..Q.\", \u00a0// solution 2\n\n\u00a0 \"Q...\",\n\n\u00a0 \"...Q\",\n\n\u00a0 \".Q..\"]\n\n]\n\n</pre>"},{"location":"lcci/8.12.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.12.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoC# <pre><code>class Solution:\n    def solveNQueens(self, n: int) -&gt; List[List[str]]:\n        res = []\n        g = [['.'] * n for _ in range(n)]\n        col = [False] * n\n        dg = [False] * (2 * n)\n        udg = [False] * (2 * n)\n\n        def dfs(u):\n            if u == n:\n                res.append([''.join(item) for item in g])\n                return\n            for i in range(n):\n                if not col[i] and not dg[u + i] and not udg[n - u + i]:\n                    g[u][i] = 'Q'\n                    col[i] = dg[u + i] = udg[n - u + i] = True\n                    dfs(u + 1)\n                    g[u][i] = '.'\n                    col[i] = dg[u + i] = udg[n - u + i] = False\n\n        dfs(0)\n        return res\n</code></pre> <pre><code>class Solution {\n    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {\n        List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();\n        String[][] g = new String[n][n];\n        for (int i = 0; i &lt; n; ++i) {\n            String[] t = new String[n];\n            Arrays.fill(t, \".\");\n            g[i] = t;\n        }\n        // \u200b\u5217\u200b\u662f\u5426\u200b\u5df2\u7ecf\u200b\u6709\u503c\u200b\n        boolean[] col = new boolean[n];\n        // \u200b\u659c\u7ebf\u200b\u662f\u5426\u200b\u5df2\u7ecf\u200b\u6709\u503c\u200b\n        boolean[] dg = new boolean[2 * n];\n        // \u200b\u53cd\u200b\u659c\u7ebf\u200b\u662f\u5426\u200b\u5df2\u7ecf\u200b\u6709\u503c\u200b\n        boolean[] udg = new boolean[2 * n];\n        // \u200b\u4ece\u200b\u7b2c\u4e00\u884c\u200b\u5f00\u59cb\u200b\u641c\u7d22\u200b\n        dfs(0, n, col, dg, udg, g, res);\n        return res;\n    }\n\n    private void dfs(int u, int n, boolean[] col, boolean[] dg, boolean[] udg, String[][] g,\n        List&lt;List&lt;String&gt;&gt; res) {\n        if (u == n) {\n            List&lt;String&gt; t = new ArrayList&lt;&gt;();\n            for (String[] e : g) {\n                t.add(String.join(\"\", e));\n            }\n            res.add(t);\n            return;\n        }\n        for (int i = 0; i &lt; n; ++i) {\n            if (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) {\n                g[u][i] = \"Q\";\n                col[i] = dg[u + i] = udg[n - u + i] = true;\n                dfs(u + 1, n, col, dg, udg, g, res);\n                g[u][i] = \".\";\n                col[i] = dg[u + i] = udg[n - u + i] = false;\n            }\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n        vector&lt;vector&lt;string&gt;&gt; res;\n        vector&lt;string&gt; g(n, string(n, '.'));\n        vector&lt;bool&gt; col(n, false);\n        vector&lt;bool&gt; dg(2 * n, false);\n        vector&lt;bool&gt; udg(2 * n, false);\n        dfs(0, n, col, dg, udg, g, res);\n        return res;\n    }\n\n    void dfs(int u, int n, vector&lt;bool&gt;&amp; col, vector&lt;bool&gt;&amp; dg, vector&lt;bool&gt;&amp; udg, vector&lt;string&gt;&amp; g, vector&lt;vector&lt;string&gt;&gt;&amp; res) {\n        if (u == n) {\n            res.push_back(g);\n            return;\n        }\n        for (int i = 0; i &lt; n; ++i) {\n            if (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) {\n                g[u][i] = 'Q';\n                col[i] = dg[u + i] = udg[n - u + i] = true;\n                dfs(u + 1, n, col, dg, udg, g, res);\n                g[u][i] = '.';\n                col[i] = dg[u + i] = udg[n - u + i] = false;\n            }\n        }\n    }\n};\n</code></pre> <pre><code>func solveNQueens(n int) [][]string {\n    res := [][]string{}\n    g := make([][]string, n)\n    for i := range g {\n        g[i] = make([]string, n)\n        for j := range g[i] {\n            g[i][j] = \".\"\n        }\n    }\n    col := make([]bool, n)\n    dg := make([]bool, 2*n)\n    udg := make([]bool, 2*n)\n    dfs(0, n, col, dg, udg, g, &amp;res)\n    return res\n}\n\nfunc dfs(u, n int, col, dg, udg []bool, g [][]string, res *[][]string) {\n    if u == n {\n        t := make([]string, n)\n        for i := 0; i &lt; n; i++ {\n            t[i] = strings.Join(g[i], \"\")\n        }\n        *res = append(*res, t)\n        return\n    }\n    for i := 0; i &lt; n; i++ {\n        if !col[i] &amp;&amp; !dg[u+i] &amp;&amp; !udg[n-u+i] {\n            g[u][i] = \"Q\"\n            col[i], dg[u+i], udg[n-u+i] = true, true, true\n            dfs(u+1, n, col, dg, udg, g, res)\n            g[u][i] = \".\"\n            col[i], dg[u+i], udg[n-u+i] = false, false, false\n        }\n    }\n}\n</code></pre> <pre><code>using System.Collections.Generic;\nusing System.Text;\n\npublic class Solution {\n    private IList&lt;IList&lt;string&gt;&gt; results = new List&lt;IList&lt;string&gt;&gt;();\n    private int n;\n\n    public IList&lt;IList&lt;string&gt;&gt; SolveNQueens(int n) {\n        this.n = n;\n        Search(new List&lt;int&gt;(), 0, 0, 0);\n        return results;\n    }\n\n    private void Search(IList&lt;int&gt; state, int left, int right, int vertical)\n    {\n        if (state.Count == n)\n        {\n            Print(state);\n            return;\n        }\n        int available = ~(left | right | vertical) &amp; ((1 &lt;&lt; n) - 1);\n        while (available != 0)\n        {\n            int x = available &amp; -available;\n            state.Add(x);\n            Search(state, (left | x ) &lt;&lt; 1, (right | x ) &gt;&gt; 1, vertical | x);\n            state.RemoveAt(state.Count - 1);\n            available &amp;= ~x;\n        }\n    }\n\n    private void Print(IList&lt;int&gt; state)\n    {\n        var result = new List&lt;string&gt;();\n        var sb = new StringBuilder(n);\n        foreach (var s in state)\n        {\n            var x = s;\n            for (var i = 0; i &lt; n; ++i)\n            {\n                sb.Append((x &amp; 1) != 0 ? 'Q': '.');\n                x &gt;&gt;= 1;\n            }\n            result.Add(sb.ToString());\n            sb.Clear();\n        }\n        results.Add(result);\n    }\n}\n</code></pre>"},{"location":"lcci/8.13.html","title":"08.13. Pile Box","text":""},{"location":"lcci/8.13.html#description","title":"Description","text":"<p>You have a stack of n boxes, with widths wi, heights hi, and depths di. The boxes cannot be rotated and can only be stacked on top of one another if each box in the stack is strictly larger than the box above it in width, height, and depth. Implement a method to compute the height of the tallest possible stack. The height of a stack is the sum of the heights of each box.</p> <p>The input use <code>[wi, di, hi]</code>\u00a0to represents each box.</p> <p>Example1:</p> <pre>\n\n Input: box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]\n\n Output: 6\n\n</pre> <p>Example2:</p> <pre>\n\n Input: box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]]\n\n Output: 10\n\n</pre> <p>Note:</p> <ol> <li><code>box.length &lt;= 3000</code></li> </ol>"},{"location":"lcci/8.13.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.13.html#solution-1-sorting-dynamic-programming","title":"Solution 1: Sorting + Dynamic Programming","text":"<p>First, we sort the boxes in ascending order by width and descending order by depth, then use dynamic programming to solve the problem.</p> <p>We define $f[i]$ as the maximum height with the $i$-th box at the bottom. For $f[i]$, we enumerate $j \\in [0, i)$, if $box[j][1] &lt; box[i][1]$ and $box[j][2] &lt; box[i][2]$, then we can put the $j$-th box on top of the $i$-th box, in which case $f[i] = \\max{f[i], f[j]}$. Finally, we add the height of the $i$-th box to $f[i]$ to get the final value of $f[i]$.</p> <p>The answer is the maximum value in $f$.</p> <p>The time complexity is $O(n^2)$, and the space complexity is $O(n)$. Here, $n$ is the number of boxes.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def pileBox(self, box: List[List[int]]) -&gt; int:\n        box.sort(key=lambda x: (x[0], -x[1]))\n        n = len(box)\n        f = [0] * n\n        for i in range(n):\n            for j in range(i):\n                if box[j][1] &lt; box[i][1] and box[j][2] &lt; box[i][2]:\n                    f[i] = max(f[i], f[j])\n            f[i] += box[i][2]\n        return max(f)\n</code></pre> <pre><code>class Solution {\n    public int pileBox(int[][] box) {\n        Arrays.sort(box, (a, b) -&gt; a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\n        int n = box.length;\n        int[] f = new int[n];\n        int ans = 0;\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; i; ++j) {\n                if (box[j][1] &lt; box[i][1] &amp;&amp; box[j][2] &lt; box[i][2]) {\n                    f[i] = Math.max(f[i], f[j]);\n                }\n            }\n            f[i] += box[i][2];\n            ans = Math.max(ans, f[i]);\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int pileBox(vector&lt;vector&lt;int&gt;&gt;&amp; box) {\n        sort(box.begin(), box.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {\n            return a[0] &lt; b[0] || (a[0] == b[0] &amp;&amp; b[1] &lt; a[1]);\n        });\n        int n = box.size();\n        int f[n];\n        memset(f, 0, sizeof(f));\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; i; ++j) {\n                if (box[j][1] &lt; box[i][1] &amp;&amp; box[j][2] &lt; box[i][2]) {\n                    f[i] = max(f[i], f[j]);\n                }\n            }\n            f[i] += box[i][2];\n        }\n        return *max_element(f, f + n);\n    }\n};\n</code></pre> <pre><code>func pileBox(box [][]int) int {\n    sort.Slice(box, func(i, j int) bool {\n        a, b := box[i], box[j]\n        return a[0] &lt; b[0] || (a[0] == b[0] &amp;&amp; b[1] &lt; a[1])\n    })\n    n := len(box)\n    f := make([]int, n)\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; i; j++ {\n            if box[j][1] &lt; box[i][1] &amp;&amp; box[j][2] &lt; box[i][2] {\n                f[i] = max(f[i], f[j])\n            }\n        }\n        f[i] += box[i][2]\n    }\n    return slices.Max(f)\n}\n</code></pre> <pre><code>function pileBox(box: number[][]): number {\n    box.sort((a, b) =&gt; (a[0] === b[0] ? b[1] - a[1] : a[0] - b[0]));\n    const n = box.length;\n    const f: number[] = new Array(n).fill(0);\n    let ans: number = 0;\n    for (let i = 0; i &lt; n; ++i) {\n        for (let j = 0; j &lt; i; ++j) {\n            if (box[j][1] &lt; box[i][1] &amp;&amp; box[j][2] &lt; box[i][2]) {\n                f[i] = Math.max(f[i], f[j]);\n            }\n        }\n        f[i] += box[i][2];\n        ans = Math.max(ans, f[i]);\n    }\n    return ans;\n}\n</code></pre>"},{"location":"lcci/8.14.html","title":"08.14. Boolean Evaluation","text":""},{"location":"lcci/8.14.html#description","title":"Description","text":"<p>Given a boolean expression consisting of the symbols <code>0</code> (false), <code>1</code> (true), <code>&amp;</code> (AND), <code>|</code> (OR), and <code>^</code>\u00a0(XOR), and a desired boolean result value result, implement a function to count the number of ways of parenthesizing the expression such that it evaluates to result.</p> <p>Example 1:</p> <pre>\n\nInput: s = \"1^0|0|1\", result = 0\n\n\n\nOutput: 2\n\nExplanation:\u00a0Two possible parenthesizing ways are:\n\n1^(0|(0|1))\n\n1^((0|0)|1)\n\n</pre> <p>Example 2:</p> <pre>\n\nInput: s = \"0&amp;0&amp;0&amp;1^1|0\", result = 1\n\n\n\nOutput: 10</pre> <p>Note: </p> <ul> <li>There are no more than\u00a019 operators in <code>s</code>.</li> </ul>"},{"location":"lcci/8.14.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.14.html#solution-1","title":"Solution 1","text":"Python3JavaC++Go <pre><code>class Solution:\n    def countEval(self, s: str, result: int) -&gt; int:\n        @cache\n        def dfs(s):\n            res = [0] * 2\n            if s in '01':\n                res[int(s)] = 1\n                return res\n            for k, op in enumerate(s):\n                if op in '&amp;^|':\n                    left, right = dfs(s[:k]), dfs(s[k + 1 :])\n                    for i, v1 in enumerate(left):\n                        for j, v2 in enumerate(right):\n                            if op == '&amp;':\n                                v = i &amp; j\n                            elif op == '^':\n                                v = i ^ j\n                            elif op == '|':\n                                v = i | j\n                            res[v] += v1 * v2\n            return res\n\n        ans = dfs(s)\n        return ans[result] if 0 &lt;= result &lt; 2 else 0\n</code></pre> <pre><code>class Solution {\n    private Map&lt;String, int[]&gt; memo;\n\n    public int countEval(String s, int result) {\n        memo = new HashMap&lt;&gt;();\n        int[] ans = dfs(s);\n        return result == 0 || result == 1 ? ans[result] : 0;\n    }\n\n    private int[] dfs(String s) {\n        if (memo.containsKey(s)) {\n            return memo.get(s);\n        }\n        int[] res = new int[2];\n        if (s.length() == 1) {\n            res[Integer.parseInt(s)] = 1;\n            return res;\n        }\n        for (int k = 0; k &lt; s.length(); ++k) {\n            char op = s.charAt(k);\n            if (op == '&amp;' || op == '|' || op == '^') {\n                int[] left = dfs(s.substring(0, k));\n                int[] right = dfs(s.substring(k + 1));\n                for (int i = 0; i &lt; 2; ++i) {\n                    for (int j = 0; j &lt; 2; ++j) {\n                        int v = 0;\n                        if (op == '&amp;') {\n                            v = i &amp; j;\n                        } else if (op == '|') {\n                            v = i | j;\n                        } else if (op == '^') {\n                            v = i ^ j;\n                        }\n                        res[v] += left[i] * right[j];\n                    }\n                }\n            }\n        }\n        memo.put(s, res);\n        return res;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    unordered_map&lt;string, vector&lt;int&gt;&gt; memo;\n\n    int countEval(string s, int result) {\n        vector&lt;int&gt; ans = dfs(s);\n        return result == 0 || result == 1 ? ans[result] : 0;\n    }\n\n    vector&lt;int&gt; dfs(string s) {\n        if (memo.count(s)) return memo[s];\n        vector&lt;int&gt; res(2);\n        if (s.size() == 1) {\n            res[s[0] - '0'] = 1;\n            return res;\n        }\n        for (int k = 0; k &lt; s.size(); ++k) {\n            if (s[k] == '0' || s[k] == '1') continue;\n            vector&lt;int&gt; left = dfs(s.substr(0, k));\n            vector&lt;int&gt; right = dfs(s.substr(k + 1, s.size() - k));\n            for (int i = 0; i &lt; 2; ++i) {\n                for (int j = 0; j &lt; 2; ++j) {\n                    int v = 0;\n                    if (s[k] == '&amp;')\n                        v = i &amp; j;\n                    else if (s[k] == '|')\n                        v = i | j;\n                    else if (s[k] == '^')\n                        v = i ^ j;\n                    res[v] += left[i] * right[j];\n                }\n            }\n        }\n        memo[s] = res;\n        return res;\n    }\n};\n</code></pre> <pre><code>func countEval(s string, result int) int {\n    memo := map[string][]int{}\n    var dfs func(string) []int\n    dfs = func(s string) []int {\n        if v, ok := memo[s]; ok {\n            return v\n        }\n        res := make([]int, 2)\n        if len(s) == 1 {\n            res[s[0]-'0'] = 1\n            return res\n        }\n        for k, c := range s {\n            if c == '0' || c == '1' {\n                continue\n            }\n            left, right := dfs(s[:k]), dfs(s[k+1:])\n            for i, v1 := range left {\n                for j, v2 := range right {\n                    v := 0\n                    if c == '&amp;' {\n                        v = i &amp; j\n                    } else if c == '|' {\n                        v = i | j\n                    } else if c == '^' {\n                        v = i ^ j\n                    }\n                    res[v] += v1 * v2\n                }\n            }\n        }\n        memo[s] = res\n        return res\n    }\n    ans := dfs(s)\n    if result == 0 || result == 1 {\n        return ans[result]\n    }\n    return 0\n}\n</code></pre>"},{"location":"lcci/8.2.html","title":"08.02. Robot in a Grid","text":""},{"location":"lcci/8.2.html#description","title":"Description","text":"<p>Imagine a robot sitting on the upper left corner of grid with r rows and c columns. The robot can only move in two directions, right and down, but certain cells are \"off limits\" such that the robot cannot step on them. Design an algorithm to find a path for the robot from the top left to the bottom right.</p> <p></p> <p>\"off limits\" and empty grid are represented by\u00a0<code>1</code> and\u00a0<code>0</code>\u00a0respectively.</p> <p>Return a valid path, consisting of row number and column number of grids in the path.</p> <p>Example\u00a01:</p> <pre>\n\nInput:\n\n[\n\n\u00a0 [0,0,0],\n\n\u00a0 [0,1,0],\n\n\u00a0 [0,0,0]\n\n]\n\nOutput: [[0,0],[0,1],[0,2],[1,2],[2,2]]</pre> <p>Note: </p> <ul> <li><code>r,\u00a0c &lt;= 100</code></li> </ul>"},{"location":"lcci/8.2.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.2.html#solution-1-dfs-depth-first-search","title":"Solution 1: DFS (Depth-First Search)","text":"<p>We can use depth-first search to solve this problem. We start from the top left corner and move right or down until we reach the bottom right corner. If at some step, we find that the current position is an obstacle, or the current position is already in the path, then we return. Otherwise, we add the current position to the path and mark the current position as visited, then continue to move right or down.</p> <p>If we can finally reach the bottom right corner, then we have found a feasible path, otherwise, it means there is no feasible path.</p> <p>The time complexity is $O(m \\times n)$, and the space complexity is $O(m \\times n)$. Here, $m$ and $n$ are the number of rows and columns of the grid, respectively.</p> Python3JavaC++GoTypeScriptRust <pre><code>class Solution:\n    def pathWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; List[List[int]]:\n        def dfs(i, j):\n            if i &gt;= m or j &gt;= n or obstacleGrid[i][j] == 1:\n                return False\n            ans.append([i, j])\n            obstacleGrid[i][j] = 1\n            if (i == m - 1 and j == n - 1) or dfs(i + 1, j) or dfs(i, j + 1):\n                return True\n            ans.pop()\n            return False\n\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        ans = []\n        return ans if dfs(0, 0) else []\n</code></pre> <pre><code>class Solution {\n    private List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n    private int[][] g;\n    private int m;\n    private int n;\n\n    public List&lt;List&lt;Integer&gt;&gt; pathWithObstacles(int[][] obstacleGrid) {\n        g = obstacleGrid;\n        m = g.length;\n        n = g[0].length;\n        return dfs(0, 0) ? ans : Collections.emptyList();\n    }\n\n    private boolean dfs(int i, int j) {\n        if (i &gt;= m || j &gt;= n || g[i][j] == 1) {\n            return false;\n        }\n        ans.add(List.of(i, j));\n        g[i][j] = 1;\n        if ((i == m - 1 &amp;&amp; j == n - 1) || dfs(i + 1, j) || dfs(i, j + 1)) {\n            return true;\n        }\n        ans.remove(ans.size() - 1);\n        return false;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; pathWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {\n        int m = obstacleGrid.size();\n        int n = obstacleGrid[0].size();\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        function&lt;bool(int, int)&gt; dfs = [&amp;](int i, int j) -&gt; bool {\n            if (i &gt;= m || j &gt;= n || obstacleGrid[i][j] == 1) {\n                return false;\n            }\n            ans.push_back({i, j});\n            obstacleGrid[i][j] = 1;\n            if ((i == m - 1 &amp;&amp; j == n - 1) || dfs(i + 1, j) || dfs(i, j + 1)) {\n                return true;\n            }\n            ans.pop_back();\n            return false;\n        };\n        return dfs(0, 0) ? ans : vector&lt;vector&lt;int&gt;&gt;();\n    }\n};\n</code></pre> <pre><code>func pathWithObstacles(obstacleGrid [][]int) [][]int {\n    m, n := len(obstacleGrid), len(obstacleGrid[0])\n    ans := [][]int{}\n    var dfs func(i, j int) bool\n    dfs = func(i, j int) bool {\n        if i &gt;= m || j &gt;= n || obstacleGrid[i][j] == 1 {\n            return false\n        }\n        ans = append(ans, []int{i, j})\n        obstacleGrid[i][j] = 1\n        if (i == m-1 &amp;&amp; j == n-1) || dfs(i+1, j) || dfs(i, j+1) {\n            return true\n        }\n        ans = ans[:len(ans)-1]\n        return false\n    }\n    if dfs(0, 0) {\n        return ans\n    }\n    return [][]int{}\n}\n</code></pre> <pre><code>function pathWithObstacles(obstacleGrid: number[][]): number[][] {\n    const m = obstacleGrid.length;\n    const n = obstacleGrid[0].length;\n    const res = [];\n    const dfs = (i: number, j: number): boolean =&gt; {\n        if (i === m || j === n || obstacleGrid[i][j] === 1) {\n            return false;\n        }\n        res.push([i, j]);\n        obstacleGrid[i][j] = 1;\n        if ((i + 1 === m &amp;&amp; j + 1 === n) || dfs(i + 1, j) || dfs(i, j + 1)) {\n            return true;\n        }\n        res.pop();\n        return false;\n    };\n    if (dfs(0, 0)) {\n        return res;\n    }\n    return [];\n}\n</code></pre> <pre><code>impl Solution {\n    fn dfs(grid: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, path: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, i: usize, j: usize) -&gt; bool {\n        if i == grid.len() || j == grid[0].len() || grid[i][j] == 1 {\n            return false;\n        }\n        path.push(vec![i as i32, j as i32]);\n        grid[i as usize][j as usize] = 1;\n        if\n            (i + 1 == grid.len() &amp;&amp; j + 1 == grid[0].len()) ||\n            Self::dfs(grid, path, i + 1, j) ||\n            Self::dfs(grid, path, i, j + 1)\n        {\n            return true;\n        }\n        path.pop();\n        false\n    }\n\n    pub fn path_with_obstacles(mut obstacle_grid: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n        let mut res = vec![];\n        if Self::dfs(&amp;mut obstacle_grid, &amp;mut res, 0, 0) {\n            return res;\n        }\n        vec![]\n    }\n}\n</code></pre>"},{"location":"lcci/8.3.html","title":"08.03. Magic Index","text":""},{"location":"lcci/8.3.html#description","title":"Description","text":"<p>A magic index in an array <code>A[0...n-1]</code> is defined to be an index such that <code>A[i] = i</code>. Given a sorted array of distinct integers, write a method to find a magic index, if one exists, in array A. If not, return -1. If there are more than one magic index, return the smallest one.</p> <p>Example1:</p> <pre>\n\n Input: nums = [0, 2, 3, 4, 5]\n\n Output: 0\n\n</pre> <p>Example2:</p> <pre>\n\n Input: nums = [1, 1, 1]\n\n Output: 1\n\n</pre> <p>Note:</p> <ol> <li><code>1 &lt;= nums.length &lt;= 1000000</code></li> </ol>"},{"location":"lcci/8.3.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.3.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoTypeScriptRustJavaScript <pre><code>class Solution:\n    def findMagicIndex(self, nums: List[int]) -&gt; int:\n        def find(nums, left, right):\n            if left &gt; right:\n                return -1\n            mid = (left + right) &gt;&gt; 1\n            left_index = find(nums, left, mid - 1)\n            if left_index != -1:\n                return left_index\n            if nums[mid] == mid:\n                return mid\n            return find(nums, mid + 1, right)\n\n        return find(nums, 0, len(nums) - 1)\n</code></pre> <pre><code>class Solution {\n    public int findMagicIndex(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        return find(nums, left, right);\n    }\n\n    private int find(int[] nums, int left, int right) {\n        if (left &gt; right) {\n            return -1;\n        }\n        int mid = (left + right) &gt;&gt; 1;\n        int leftIndex = find(nums, left, mid - 1);\n        if (leftIndex != -1) {\n            return leftIndex;\n        }\n        if (nums[mid] == mid) {\n            return mid;\n        }\n        return find(nums, mid + 1, right);\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int findMagicIndex(vector&lt;int&gt;&amp; nums) {\n        return find(nums, 0, nums.size() - 1);\n    }\n\n    int find(vector&lt;int&gt;&amp; nums, int left, int right) {\n        if (left &gt; right) {\n            return -1;\n        }\n        int mid = left + right &gt;&gt; 1;\n        int leftIndex = find(nums, left, mid - 1);\n        if (leftIndex != -1) {\n            return leftIndex;\n        }\n        if (nums[mid] == mid) {\n            return mid;\n        }\n        return find(nums, mid + 1, right);\n    }\n};\n</code></pre> <pre><code>func findMagicIndex(nums []int) int {\n    return find(nums, 0, len(nums)-1)\n}\n\nfunc find(nums []int, left, right int) int {\n    if left &gt; right {\n        return -1\n    }\n    mid := (left + right) &gt;&gt; 1\n    leftIndex := find(nums, left, mid-1)\n    if leftIndex != -1 {\n        return leftIndex\n    }\n    if nums[mid] == mid {\n        return mid\n    }\n    return find(nums, mid+1, right)\n}\n</code></pre> <pre><code>function findMagicIndex(nums: number[]): number {\n    const n = nums.length;\n    const find = (l: number, r: number): number =&gt; {\n        if (l &gt; r || nums[r] &lt; 0) {\n            return -1;\n        }\n        const mid = l + Math.floor((r - l) / 2);\n        if (nums[mid] &gt;= l) {\n            const res = find(l, mid - 1);\n            if (res !== -1) {\n                return res;\n            }\n        }\n        if (nums[mid] === mid) {\n            return mid;\n        }\n        return find(mid + 1, r);\n    };\n    return find(0, n - 1);\n}\n</code></pre> <pre><code>impl Solution {\n    fn find(nums: &amp;Vec&lt;i32&gt;, l: usize, r: usize) -&gt; i32 {\n        if l &gt;= r || nums[r - 1] &lt; 0 {\n            return -1;\n        }\n        let mid = l + (r - l) / 2;\n        if nums[mid] &gt;= (l as i32) {\n            let res = Self::find(nums, l, mid);\n            if res != -1 {\n                return res;\n            }\n        }\n        if nums[mid] == (mid as i32) {\n            return mid as i32;\n        }\n        Self::find(nums, mid + 1, r)\n    }\n\n    pub fn find_magic_index(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        Self::find(&amp;nums, 0, nums.len())\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMagicIndex = function (nums) {\n    return helper(nums, 0, nums.length - 1);\n};\n\nfunction helper(nums, left, right) {\n    if (left &gt; right) return -1;\n    let mid = Math.floor((left + right) / 2);\n    let leftIndex = helper(nums, left, mid - 1);\n    if (leftIndex != -1) return leftIndex;\n    if (nums[mid] == mid) return mid;\n    return helper(nums, mid + 1, right);\n}\n</code></pre>"},{"location":"lcci/8.3.html#solution-2","title":"Solution 2","text":"TypeScriptRust <pre><code>function findMagicIndex(nums: number[]): number {\n    const n = nums.length;\n    let i = 0;\n    while (i &lt; n) {\n        if (nums[i] === i) {\n            return i;\n        }\n        i = Math.max(nums[i], i + 1);\n    }\n    return -1;\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn find_magic_index(nums: Vec&lt;i32&gt;) -&gt; i32 {\n        let n = nums.len();\n        let mut i = 0 as i32;\n        while (i as usize) &lt; n {\n            let num = nums[i as usize];\n            if num == i {\n                return i;\n            }\n            i = num.max(i + 1);\n        }\n        -1\n    }\n}\n</code></pre>"},{"location":"lcci/8.4.html","title":"08.04. Power Set","text":""},{"location":"lcci/8.4.html#description","title":"Description","text":"<p>Write a method to return all subsets of a set. The elements in a set are\u00a0pairwise distinct.</p> <p>Note: The result set should not contain duplicated subsets.</p> <p>Example:</p> <pre>\n\n Input:  nums = [1,2,3]\n\n Output: \n\n[\n\n  [3],\n\n\u00a0 [1],\n\n\u00a0 [2],\n\n\u00a0 [1,2,3],\n\n\u00a0 [1,3],\n\n\u00a0 [2,3],\n\n\u00a0 [1,2],\n\n\u00a0 []\n\n]\n\n</pre>"},{"location":"lcci/8.4.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.4.html#solution-1-recursive-enumeration","title":"Solution 1: Recursive Enumeration","text":"<p>We design a recursive function $dfs(u, t)$, where $u$ is the index of the current element being enumerated, and $t$ is the current subset.</p> <p>For the current element with index $u$, we can choose to add it to the subset $t$, or we can choose not to add it to the subset $t$. Recursively making these two choices will yield all subsets.</p> <p>The time complexity is $O(n \\times 2^n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. Each element in the array has two states, namely chosen or not chosen, for a total of $2^n$ states. Each state requires $O(n)$ time to construct the subset.</p> Python3JavaC++GoTypeScriptRustJavaScript <pre><code>class Solution:\n    def subsets(self, nums: List[int]) -&gt; List[List[int]]:\n        def dfs(u, t):\n            if u == len(nums):\n                ans.append(t[:])\n                return\n            dfs(u + 1, t)\n            t.append(nums[u])\n            dfs(u + 1, t)\n            t.pop()\n\n        ans = []\n        dfs(0, [])\n        return ans\n</code></pre> <pre><code>class Solution {\n    private List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n    private int[] nums;\n\n    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {\n        this.nums = nums;\n        dfs(0, new ArrayList&lt;&gt;());\n        return ans;\n    }\n\n    private void dfs(int u, List&lt;Integer&gt; t) {\n        if (u == nums.length) {\n            ans.add(new ArrayList&lt;&gt;(t));\n            return;\n        }\n        dfs(u + 1, t);\n        t.add(nums[u]);\n        dfs(u + 1, t);\n        t.remove(t.size() - 1);\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; t;\n        dfs(0, nums, t, ans);\n        return ans;\n    }\n\n    void dfs(int u, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; t, vector&lt;vector&lt;int&gt;&gt;&amp; ans) {\n        if (u == nums.size()) {\n            ans.push_back(t);\n            return;\n        }\n        dfs(u + 1, nums, t, ans);\n        t.push_back(nums[u]);\n        dfs(u + 1, nums, t, ans);\n        t.pop_back();\n    }\n};\n</code></pre> <pre><code>func subsets(nums []int) [][]int {\n    var ans [][]int\n    var dfs func(u int, t []int)\n    dfs = func(u int, t []int) {\n        if u == len(nums) {\n            ans = append(ans, append([]int(nil), t...))\n            return\n        }\n        dfs(u+1, t)\n        t = append(t, nums[u])\n        dfs(u+1, t)\n        t = t[:len(t)-1]\n    }\n    var t []int\n    dfs(0, t)\n    return ans\n}\n</code></pre> <pre><code>function subsets(nums: number[]): number[][] {\n    const res = [[]];\n    nums.forEach(num =&gt; {\n        res.forEach(item =&gt; {\n            res.push(item.concat(num));\n        });\n    });\n    return res;\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn subsets(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n        let n = nums.len();\n        let mut res: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![]];\n        for i in 0..n {\n            for j in 0..res.len() {\n                res.push(vec![..res[j].clone(), vec![nums[i]]].concat());\n            }\n        }\n        res\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function (nums) {\n    let prev = [];\n    let res = [];\n    dfs(nums, 0, prev, res);\n    return res;\n};\n\nfunction dfs(nums, depth, prev, res) {\n    res.push(prev.slice());\n    for (let i = depth; i &lt; nums.length; i++) {\n        prev.push(nums[i]);\n        depth++;\n        dfs(nums, depth, prev, res);\n        prev.pop();\n    }\n}\n</code></pre>"},{"location":"lcci/8.4.html#solution-2-binary-enumeration","title":"Solution 2: Binary Enumeration","text":"<p>We can rewrite the recursive process in Method 1 into an iterative form, that is, using binary enumeration to enumerate all subsets.</p> <p>We can use $2^n$ binary numbers to represent all subsets of $n$ elements. If the $i$-th bit of a binary number <code>mask</code> is $1$, it means that the subset contains the $i$-th element $v$ of the array; if it is $0$, it means that the subset does not contain the $i$-th element $v$ of the array.</p> <p>The time complexity is $O(n \\times 2^n)$, and the space complexity is $O(n)$. Here, $n$ is the length of the array. There are a total of $2^n$ subsets, and each subset requires $O(n)$ time to construct.</p> Python3JavaC++GoTypeScriptRust <pre><code>class Solution:\n    def subsets(self, nums: List[int]) -&gt; List[List[int]]:\n        ans = []\n        for mask in range(1 &lt;&lt; len(nums)):\n            t = []\n            for i, v in enumerate(nums):\n                if (mask &gt;&gt; i) &amp; 1:\n                    t.append(v)\n            ans.append(t)\n        return ans\n</code></pre> <pre><code>class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {\n        int n = nums.length;\n        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n        for (int mask = 0; mask &lt; 1 &lt;&lt; n; ++mask) {\n            List&lt;Integer&gt; t = new ArrayList&lt;&gt;();\n            for (int i = 0; i &lt; n; ++i) {\n                if (((mask &gt;&gt; i) &amp; 1) == 1) {\n                    t.add(nums[i]);\n                }\n            }\n            ans.add(t);\n        }\n        return ans;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; t;\n        int n = nums.size();\n        for (int mask = 0; mask &lt; 1 &lt;&lt; n; ++mask) {\n            t.clear();\n            for (int i = 0; i &lt; n; ++i) {\n                if ((mask &gt;&gt; i) &amp; 1) {\n                    t.push_back(nums[i]);\n                }\n            }\n            ans.push_back(t);\n        }\n        return ans;\n    }\n};\n</code></pre> <pre><code>func subsets(nums []int) [][]int {\n    var ans [][]int\n    n := len(nums)\n    for mask := 0; mask &lt; 1&lt;&lt;n; mask++ {\n        t := []int{}\n        for i, v := range nums {\n            if ((mask &gt;&gt; i) &amp; 1) == 1 {\n                t = append(t, v)\n            }\n        }\n        ans = append(ans, t)\n    }\n    return ans\n}\n</code></pre> <pre><code>function subsets(nums: number[]): number[][] {\n    const n = nums.length;\n    const res = [];\n    const list = [];\n    const dfs = (i: number) =&gt; {\n        if (i === n) {\n            res.push([...list]);\n            return;\n        }\n        list.push(nums[i]);\n        dfs(i + 1);\n        list.pop();\n        dfs(i + 1);\n    };\n    dfs(0);\n    return res;\n}\n</code></pre> <pre><code>impl Solution {\n    fn dfs(nums: &amp;Vec&lt;i32&gt;, i: usize, res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, list: &amp;mut Vec&lt;i32&gt;) {\n        if i == nums.len() {\n            res.push(list.clone());\n            return;\n        }\n        list.push(nums[i]);\n        Self::dfs(nums, i + 1, res, list);\n        list.pop();\n        Self::dfs(nums, i + 1, res, list);\n    }\n\n    pub fn subsets(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n        let mut res = vec![];\n        Self::dfs(&amp;nums, 0, &amp;mut res, &amp;mut vec![]);\n        res\n    }\n}\n</code></pre>"},{"location":"lcci/8.5.html","title":"08.05. Recursive Mulitply","text":""},{"location":"lcci/8.5.html#description","title":"Description","text":"<p>Write a recursive function to multiply two positive integers without using the * operator. You can use addition, subtraction, and bit shifting, but you should minimize the number of those operations.</p> <p>Example 1:</p> <pre>\n\n Input: A = 1, B = 10\n\n Output: 10\n\n</pre> <p>Example 2:</p> <pre>\n\n Input: A = 3, B = 4\n\n Output: 12\n\n</pre> <p>Note:</p> <ol> <li>The result will not overflow.</li> </ol>"},{"location":"lcci/8.5.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.5.html#solution-1-recursion-bit-manipulation","title":"Solution 1: Recursion + Bit Manipulation","text":"<p>First, we check if $B$ is $1$. If it is, we directly return $A$.</p> <p>Otherwise, we check if $B$ is an odd number. If it is, we can right shift $B$ by one bit, then recursively call the function, and finally left shift the result by one bit and add $A$. If not, we can right shift $B$ by one bit, then recursively call the function, and finally left shift the result by one bit.</p> <p>The time complexity is $O(\\log n)$, and the space complexity is $O(\\log n)$. Here, $n$ is the size of $B$.</p> Python3JavaC++GoTypeScriptRust <pre><code>class Solution:\n    def multiply(self, A: int, B: int) -&gt; int:\n        if B == 1:\n            return A\n        if B &amp; 1:\n            return (self.multiply(A, B &gt;&gt; 1) &lt;&lt; 1) + A\n        return self.multiply(A, B &gt;&gt; 1) &lt;&lt; 1\n</code></pre> <pre><code>class Solution {\n    public int multiply(int A, int B) {\n        if (B == 1) {\n            return A;\n        }\n        if ((B &amp; 1) == 1) {\n            return (multiply(A, B &gt;&gt; 1) &lt;&lt; 1) + A;\n        }\n        return multiply(A, B &gt;&gt; 1) &lt;&lt; 1;\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    int multiply(int A, int B) {\n        if (B == 1) {\n            return A;\n        }\n        if ((B &amp; 1) == 1) {\n            return (multiply(A, B &gt;&gt; 1) &lt;&lt; 1) + A;\n        }\n        return multiply(A, B &gt;&gt; 1) &lt;&lt; 1;\n    }\n};\n</code></pre> <pre><code>func multiply(A int, B int) int {\n    if B == 1 {\n        return A\n    }\n    if B&amp;1 == 1 {\n        return (multiply(A, B&gt;&gt;1) &lt;&lt; 1) + A\n    }\n    return multiply(A, B&gt;&gt;1) &lt;&lt; 1\n}\n</code></pre> <pre><code>function multiply(A: number, B: number): number {\n    if (B === 1) {\n        return A;\n    }\n    if ((B &amp; 1) === 1) {\n        return (multiply(A, B &gt;&gt; 1) &lt;&lt; 1) + A;\n    }\n    return multiply(A, B &gt;&gt; 1) &lt;&lt; 1;\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn multiply(a: i32, b: i32) -&gt; i32 {\n        if b == 1 {\n            return a;\n        }\n        if (b &amp; 1) == 1 {\n            return (Self::multiply(a, b &gt;&gt; 1) &lt;&lt; 1) + a;\n        }\n        Self::multiply(a, b &gt;&gt; 1) &lt;&lt; 1\n    }\n}\n</code></pre>"},{"location":"lcci/8.6.html","title":"08.06. Hanota","text":""},{"location":"lcci/8.6.html#description","title":"Description","text":"<p>In the classic problem of the Towers of Hanoi, you have 3 towers and N disks of different sizes which can slide onto any tower. The puzzle starts with disks sorted in ascending order of size from top to bottom (i.e., each disk sits on top of an even larger one). You have the following constraints:</p> <p>(1) Only one disk can be moved at a time. (2) A disk is slid off the top of one tower onto another tower. (3) A disk cannot be placed on top of a smaller disk.</p> <p>Write a program to move the disks from the first tower to the last using stacks.</p> <p>Example1:</p> <pre>\n\n Input: A = [2, 1, 0], B = [], C = []\n\n Output: C = [2, 1, 0]\n\n</pre> <p>Example2:</p> <pre>\n\n Input: A = [1, 0], B = [], C = []\n\n Output: C = [1, 0]\n\n</pre> <p>Note:</p> <ol> <li><code>A.length &lt;= 14</code></li> </ol>"},{"location":"lcci/8.6.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.6.html#solution-1-recursion","title":"Solution 1: Recursion","text":"<p>We design a function $dfs(n, a, b, c)$, which represents moving $n$ disks from $a$ to $c$, with $b$ as the auxiliary rod.</p> <p>First, we move $n - 1$ disks from $a$ to $b$, then move the $n$-th disk from $a$ to $c$, and finally move $n - 1$ disks from $b$ to $c$.</p> <p>The time complexity is $O(2^n)$, and the space complexity is $O(n)$. Here, $n$ is the number of disks.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def hanota(self, A: List[int], B: List[int], C: List[int]) -&gt; None:\n        def dfs(n, a, b, c):\n            if n == 1:\n                c.append(a.pop())\n                return\n            dfs(n - 1, a, c, b)\n            c.append(a.pop())\n            dfs(n - 1, b, a, c)\n\n        dfs(len(A), A, B, C)\n</code></pre> <pre><code>class Solution {\n    public void hanota(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C) {\n        dfs(A.size(), A, B, C);\n    }\n\n    private void dfs(int n, List&lt;Integer&gt; a, List&lt;Integer&gt; b, List&lt;Integer&gt; c) {\n        if (n == 1) {\n            c.add(a.remove(a.size() - 1));\n            return;\n        }\n        dfs(n - 1, a, c, b);\n        c.add(a.remove(a.size() - 1));\n        dfs(n - 1, b, a, c);\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    void hanota(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C) {\n        function&lt;void(int, vector&lt;int&gt;&amp;, vector&lt;int&gt;&amp;, vector&lt;int&gt;&amp;)&gt; dfs = [&amp;](int n, vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b, vector&lt;int&gt;&amp; c) {\n            if (n == 1) {\n                c.push_back(a.back());\n                a.pop_back();\n                return;\n            }\n            dfs(n - 1, a, c, b);\n            c.push_back(a.back());\n            a.pop_back();\n            dfs(n - 1, b, a, c);\n        };\n        dfs(A.size(), A, B, C);\n    }\n};\n</code></pre> <pre><code>func hanota(A []int, B []int, C []int) []int {\n    var dfs func(n int, a, b, c *[]int)\n    dfs = func(n int, a, b, c *[]int) {\n        if n == 1 {\n            *c = append(*c, (*a)[len(*a)-1])\n            *a = (*a)[:len(*a)-1]\n            return\n        }\n        dfs(n-1, a, c, b)\n        *c = append(*c, (*a)[len(*a)-1])\n        *a = (*a)[:len(*a)-1]\n        dfs(n-1, b, a, c)\n    }\n    dfs(len(A), &amp;A, &amp;B, &amp;C)\n    return C\n}\n</code></pre> <pre><code>/**\n Do not return anything, modify C in-place instead.\n */\nfunction hanota(A: number[], B: number[], C: number[]): void {\n    const dfs = (n: number, a: number[], b: number[], c: number[]) =&gt; {\n        if (n === 1) {\n            c.push(a.pop()!);\n            return;\n        }\n        dfs(n - 1, a, c, b);\n        c.push(a.pop()!);\n        dfs(n - 1, b, a, c);\n    };\n    dfs(A.length, A, B, C);\n}\n</code></pre>"},{"location":"lcci/8.6.html#solution-2-iteration-stack","title":"Solution 2: Iteration (Stack)","text":"<p>We can use a stack to simulate the recursive process.</p> <p>We define a struct $Task$, which represents a task, where $n$ represents the number of disks, and $a$, $b$, $c$ represent the three rods.</p> <p>We push the initial task $Task(len(A), A, B, C)$ into the stack, and then continuously process the task at the top of the stack until the stack is empty.</p> <p>If $n = 1$, then we directly move the disk from $a$ to $c$.</p> <p>Otherwise, we push three subtasks into the stack, which are:</p> <ol> <li>Move $n - 1$ disks from $b$ to $c$ with the help of $a$;</li> <li>Move the $n$-th disk from $a$ to $c$;</li> <li>Move $n - 1$ disks from $a$ to $b$ with the help of $c$.</li> </ol> <p>The time complexity is $O(2^n)$, and the space complexity is $O(n)$. Here, $n$ is the number of disks.</p> Python3JavaC++GoTypeScript <pre><code>class Solution:\n    def hanota(self, A: List[int], B: List[int], C: List[int]) -&gt; None:\n        stk = [(len(A), A, B, C)]\n        while stk:\n            n, a, b, c = stk.pop()\n            if n == 1:\n                c.append(a.pop())\n            else:\n                stk.append((n - 1, b, a, c))\n                stk.append((1, a, b, c))\n                stk.append((n - 1, a, c, b))\n</code></pre> <pre><code>class Solution {\n    public void hanota(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C) {\n        Deque&lt;Task&gt; stk = new ArrayDeque&lt;&gt;();\n        stk.push(new Task(A.size(), A, B, C));\n        while (stk.size() &gt; 0) {\n            Task task = stk.pop();\n            int n = task.n;\n            List&lt;Integer&gt; a = task.a;\n            List&lt;Integer&gt; b = task.b;\n            List&lt;Integer&gt; c = task.c;\n            if (n == 1) {\n                c.add(a.remove(a.size() - 1));\n            } else {\n                stk.push(new Task(n - 1, b, a, c));\n                stk.push(new Task(1, a, b, c));\n                stk.push(new Task(n - 1, a, c, b));\n            }\n        }\n    }\n}\n\nclass Task {\n    int n;\n    List&lt;Integer&gt; a;\n    List&lt;Integer&gt; b;\n    List&lt;Integer&gt; c;\n\n    public Task(int n, List&lt;Integer&gt; a, List&lt;Integer&gt; b, List&lt;Integer&gt; c) {\n        this.n = n;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n}\n</code></pre> <pre><code>struct Task {\n    int n;\n    vector&lt;int&gt;* a;\n    vector&lt;int&gt;* b;\n    vector&lt;int&gt;* c;\n};\n\nclass Solution {\npublic:\n    void hanota(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C) {\n        stack&lt;Task&gt; stk;\n        stk.push({(int) A.size(), &amp;A, &amp;B, &amp;C});\n        while (!stk.empty()) {\n            Task task = stk.top();\n            stk.pop();\n            if (task.n == 1) {\n                task.c-&gt;push_back(task.a-&gt;back());\n                task.a-&gt;pop_back();\n            } else {\n                stk.push({task.n - 1, task.b, task.a, task.c});\n                stk.push({1, task.a, task.b, task.c});\n                stk.push({task.n - 1, task.a, task.c, task.b});\n            }\n        }\n    }\n};\n</code></pre> <pre><code>func hanota(A []int, B []int, C []int) []int {\n    stk := []Task{{len(A), &amp;A, &amp;B, &amp;C}}\n    for len(stk) &gt; 0 {\n        task := stk[len(stk)-1]\n        stk = stk[:len(stk)-1]\n        if task.n == 1 {\n            *task.c = append(*task.c, (*task.a)[len(*task.a)-1])\n            *task.a = (*task.a)[:len(*task.a)-1]\n        } else {\n            stk = append(stk, Task{task.n - 1, task.b, task.a, task.c})\n            stk = append(stk, Task{1, task.a, task.b, task.c})\n            stk = append(stk, Task{task.n - 1, task.a, task.c, task.b})\n        }\n    }\n    return C\n}\n\ntype Task struct {\n    n       int\n    a, b, c *[]int\n}\n</code></pre> <pre><code>/**\n Do not return anything, modify C in-place instead.\n */\nfunction hanota(A: number[], B: number[], C: number[]): void {\n    const stk: any[] = [[A.length, A, B, C]];\n    while (stk.length) {\n        const [n, a, b, c] = stk.pop()!;\n        if (n === 1) {\n            c.push(a.pop());\n        } else {\n            stk.push([n - 1, b, a, c]);\n            stk.push([1, a, b, c]);\n            stk.push([n - 1, a, c, b]);\n        }\n    }\n}\n</code></pre>"},{"location":"lcci/8.7.html","title":"08.07. Permutation I","text":""},{"location":"lcci/8.7.html#description","title":"Description","text":"<p>Write a method to compute all permutations of a string of unique characters.</p> <p>Example1:</p> <pre>\n\n Input: S = \"qwe\"\n\n Output: [\"qwe\", \"qew\", \"wqe\", \"weq\", \"ewq\", \"eqw\"]\n\n</pre> <p>Example2:</p> <pre>\n\n Input: S = \"ab\"\n\n Output: [\"ab\", \"ba\"]\n\n</pre> <p>Note:</p> <ol> <li>All characters are English letters.</li> <li><code>1 &lt;= S.length &lt;= 9</code></li> </ol>"},{"location":"lcci/8.7.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.7.html#solution-1","title":"Solution 1","text":"Python3JavaC++GoJavaScript <pre><code>class Solution:\n    def permutation(self, S: str) -&gt; List[str]:\n        def dfs(u, t):\n            if u == n:\n                ans.append(''.join(t))\n                return\n            for i in range(n):\n                if vis[i]:\n                    continue\n                vis[i] = True\n                t.append(S[i])\n                dfs(u + 1, t)\n                t.pop()\n                vis[i] = False\n\n        n = len(S)\n        vis = [False] * n\n        ans = []\n        dfs(0, [])\n        return ans\n</code></pre> <pre><code>class Solution {\n    public String[] permutation(String S) {\n        Set&lt;Character&gt; vis = new HashSet&lt;&gt;();\n        List&lt;String&gt; ans = new ArrayList&lt;&gt;();\n        StringBuilder t = new StringBuilder();\n        dfs(0, S, t, ans, vis);\n        return ans.toArray(new String[0]);\n    }\n\n    private void dfs(int u, String S, StringBuilder t, List&lt;String&gt; ans, Set&lt;Character&gt; vis) {\n        if (u == S.length()) {\n            ans.add(t.toString());\n            return;\n        }\n        for (char c : S.toCharArray()) {\n            if (vis.contains(c)) {\n                continue;\n            }\n            vis.add(c);\n            t.append(c);\n            dfs(u + 1, S, t, ans, vis);\n            t.deleteCharAt(t.length() - 1);\n            vis.remove(c);\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;string&gt; permutation(string S) {\n        unordered_set&lt;char&gt; vis;\n        vector&lt;string&gt; ans;\n        string t = \"\";\n        dfs(0, S, t, ans, vis);\n        return ans;\n    }\n\n    void dfs(int u, string&amp; S, string&amp; t, vector&lt;string&gt;&amp; ans, unordered_set&lt;char&gt;&amp; vis) {\n        if (u == S.size()) {\n            ans.push_back(t);\n            return;\n        }\n        for (char&amp; c : S) {\n            if (vis.count(c)) continue;\n            vis.insert(c);\n            t.push_back(c);\n            dfs(u + 1, S, t, ans, vis);\n            vis.erase(c);\n            t.pop_back();\n        }\n    }\n};\n</code></pre> <pre><code>func permutation(S string) []string {\n    vis := make(map[byte]bool)\n    var ans []string\n    var t []byte\n    var dfs func(u int, t []byte)\n    dfs = func(u int, t []byte) {\n        if u == len(S) {\n            ans = append(ans, string(t))\n            return\n        }\n        for i := range S {\n            if vis[S[i]] {\n                continue\n            }\n            vis[S[i]] = true\n            t = append(t, S[i])\n            dfs(u+1, t)\n            vis[S[i]] = false\n            t = t[:len(t)-1]\n        }\n    }\n    dfs(0, t)\n    return ans\n}\n</code></pre> <pre><code>/**\n * @param {string} S\n * @return {string[]}\n */\nvar permutation = function (S) {\n    let res = [];\n    let arr = [...S];\n    let prev = [];\n    let record = new Array(S.length).fill(false);\n    dfs(arr, 0, prev, record, res);\n    return res;\n};\n\nfunction dfs(arr, depth, prev, record, res) {\n    if (depth == arr.length) {\n        res.push(prev.join(''));\n        return;\n    }\n    for (let i = 0; i &lt; arr.length; i++) {\n        if (record[i]) {\n            continue;\n        }\n        prev.push(arr[i]);\n        record[i] = true;\n        dfs(arr, depth + 1, prev, record, res);\n        prev.pop();\n        record[i] = false;\n    }\n}\n</code></pre>"},{"location":"lcci/8.8.html","title":"08.08. Permutation II","text":""},{"location":"lcci/8.8.html#description","title":"Description","text":"<p>Write a method to compute all permutations of a string whose charac\u00ad ters are not necessarily unique. The list of permutations should not have duplicates.</p> <p>Example1:</p> <pre>\n\n Input: S = \"qqe\"\n\n Output: [\"eqq\",\"qeq\",\"qqe\"]\n\n</pre> <p>Example2:</p> <pre>\n\n Input: S = \"ab\"\n\n Output: [\"ab\", \"ba\"]\n\n</pre> <p>Note:</p> <ol> <li>All characters are English letters.</li> <li><code>1 &lt;= S.length &lt;= 9</code></li> </ol>"},{"location":"lcci/8.8.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.8.html#solution-1-sorting-backtracking","title":"Solution 1: Sorting + Backtracking","text":"<p>We can first sort the string by characters, which allows us to put duplicate characters together and makes it easier for us to remove duplicates.</p> <p>Then, we design a function $dfs(i)$, which means that we need to fill in the character at the $i$-th position. The specific implementation of the function is as follows:</p> <ul> <li>If $i = n$, it means that we have finished filling in, add the current permutation to the answer array, and then return.</li> <li>Otherwise, we enumerate the character $s[j]$ at the $i$-th position, where the range of $j$ is $[0, n - 1]$. We need to ensure that $s[j]$ has not been used and is different from the previously enumerated characters, so as to ensure that the current permutation is not repeated. If the conditions are met, we can fill in $s[j]$, and continue to recursively fill in the next position, that is, call $dfs(i + 1)$. After the recursive call ends, we need to mark $s[j]$ as unused for later enumeration.</li> </ul> <p>In the main function, we first sort the string, then call $dfs(0)$, that is, start filling from the $0$-th position, and finally return the answer array.</p> <p>The time complexity is $O(n \\times n!)$, and the space complexity is $O(n)$. Here, $n$ is the length of the string $s$. $n!$ enumerations need to be performed, and each enumeration requires $O(n)$ time to determine whether it is repeated. In addition, we need a marker array to mark whether each position has been used, so the space complexity is $O(n)$.</p> Python3JavaC++GoTypeScriptJavaScript <pre><code>class Solution:\n    def permutation(self, S: str) -&gt; List[str]:\n        def dfs(i: int):\n            if i == n:\n                ans.append(\"\".join(t))\n                return\n            for j in range(n):\n                if vis[j] or (j and cs[j] == cs[j - 1] and not vis[j - 1]):\n                    continue\n                t[i] = cs[j]\n                vis[j] = True\n                dfs(i + 1)\n                vis[j] = False\n\n        cs = sorted(S)\n        n = len(cs)\n        ans = []\n        t = [None] * n\n        vis = [False] * n\n        dfs(0)\n        return ans\n</code></pre> <pre><code>class Solution {\n    private int n;\n    private char[] cs;\n    private List&lt;String&gt; ans = new ArrayList&lt;&gt;();\n    private boolean[] vis;\n    private StringBuilder t = new StringBuilder();\n\n    public String[] permutation(String S) {\n        cs = S.toCharArray();\n        n = cs.length;\n        Arrays.sort(cs);\n        vis = new boolean[n];\n        dfs(0);\n        return ans.toArray(new String[0]);\n    }\n\n    private void dfs(int i) {\n        if (i == n) {\n            ans.add(t.toString());\n            return;\n        }\n        for (int j = 0; j &lt; n; ++j) {\n            if (vis[j] || (j &gt; 0 &amp;&amp; !vis[j - 1] &amp;&amp; cs[j] == cs[j - 1])) {\n                continue;\n            }\n            vis[j] = true;\n            t.append(cs[j]);\n            dfs(i + 1);\n            t.deleteCharAt(t.length() - 1);\n            vis[j] = false;\n        }\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;string&gt; permutation(string S) {\n        vector&lt;char&gt; cs(S.begin(), S.end());\n        sort(cs.begin(), cs.end());\n        int n = cs.size();\n        vector&lt;string&gt; ans;\n        vector&lt;bool&gt; vis(n);\n        string t;\n        function&lt;void(int)&gt; dfs = [&amp;](int i) {\n            if (i == n) {\n                ans.push_back(t);\n                return;\n            }\n            for (int j = 0; j &lt; n; ++j) {\n                if (vis[j] || (j &amp;&amp; !vis[j - 1] &amp;&amp; cs[j] == cs[j - 1])) {\n                    continue;\n                }\n                vis[j] = true;\n                t.push_back(cs[j]);\n                dfs(i + 1);\n                t.pop_back();\n                vis[j] = false;\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};\n</code></pre> <pre><code>func permutation(S string) (ans []string) {\n    cs := []byte(S)\n    sort.Slice(cs, func(i, j int) bool { return cs[i] &lt; cs[j] })\n    t := []byte{}\n    n := len(cs)\n    vis := make([]bool, n)\n    var dfs func(int)\n    dfs = func(i int) {\n        if i == n {\n            ans = append(ans, string(t))\n            return\n        }\n        for j := 0; j &lt; n; j++ {\n            if vis[j] || (j &gt; 0 &amp;&amp; !vis[j-1] &amp;&amp; cs[j] == cs[j-1]) {\n                continue\n            }\n            vis[j] = true\n            t = append(t, cs[j])\n            dfs(i + 1)\n            t = t[:len(t)-1]\n            vis[j] = false\n        }\n    }\n    dfs(0)\n    return\n}\n</code></pre> <pre><code>function permutation(S: string): string[] {\n    const cs: string[] = S.split('').sort();\n    const ans: string[] = [];\n    const n = cs.length;\n    const vis: boolean[] = Array(n).fill(false);\n    const t: string[] = [];\n    const dfs = (i: number) =&gt; {\n        if (i === n) {\n            ans.push(t.join(''));\n            return;\n        }\n        for (let j = 0; j &lt; n; ++j) {\n            if (vis[j] || (j &gt; 0 &amp;&amp; !vis[j - 1] &amp;&amp; cs[j] === cs[j - 1])) {\n                continue;\n            }\n            vis[j] = true;\n            t.push(cs[j]);\n            dfs(i + 1);\n            t.pop();\n            vis[j] = false;\n        }\n    };\n    dfs(0);\n    return ans;\n}\n</code></pre> <pre><code>/**\n * @param {string} S\n * @return {string[]}\n */\nvar permutation = function (S) {\n    const cs = S.split('').sort();\n    const ans = [];\n    const n = cs.length;\n    const vis = Array(n).fill(false);\n    const t = [];\n    const dfs = i =&gt; {\n        if (i === n) {\n            ans.push(t.join(''));\n            return;\n        }\n        for (let j = 0; j &lt; n; ++j) {\n            if (vis[j] || (j &gt; 0 &amp;&amp; !vis[j - 1] &amp;&amp; cs[j] === cs[j - 1])) {\n                continue;\n            }\n            vis[j] = true;\n            t.push(cs[j]);\n            dfs(i + 1);\n            t.pop();\n            vis[j] = false;\n        }\n    };\n    dfs(0);\n    return ans;\n};\n</code></pre>"},{"location":"lcci/8.9.html","title":"08.09. Bracket","text":""},{"location":"lcci/8.9.html#description","title":"Description","text":"<p>Implement an algorithm to print all valid (e.g., properly opened and closed) combinations of n pairs of parentheses.</p> <p>Note: The result set should not contain duplicated subsets.</p> <p>For example, given\u00a0n = 3, the result should be:</p> <pre>\n\n[\n\n  \"((()))\",\n\n  \"(()())\",\n\n  \"(())()\",\n\n  \"()(())\",\n\n  \"()()()\"\n\n]\n\n</pre>"},{"location":"lcci/8.9.html#solutions","title":"Solutions","text":""},{"location":"lcci/8.9.html#solution-1-dfs-pruning","title":"Solution 1: DFS + Pruning","text":"<p>The range of $n$ in the problem is $[1, 8]$, so we can directly solve this problem quickly through \"brute force search + pruning\".</p> <p>We design a function <code>dfs(l, r, t)</code>, where $l$ and $r$ represent the number of left and right parentheses respectively, and $t$ represents the current parentheses sequence. Then we can get the following recursive structure:</p> <ul> <li>If $l &gt; n$ or $r &gt; n$ or $l &lt; r$, then the current parentheses combination $t$ is illegal, return directly;</li> <li>If $l = n$ and $r = n$, then the current parentheses combination $t$ is legal, add it to the answer array <code>ans</code>, and return directly;</li> <li>We can choose to add a left parenthesis, and recursively execute <code>dfs(l + 1, r, t + \"(\")</code>;</li> <li>We can also choose to add a right parenthesis, and recursively execute <code>dfs(l, r + 1, t + \")\")</code>.</li> </ul> <p>The time complexity is $O(2^{n\\times 2} \\times n)$, and the space complexity is $O(n)$.</p> Python3JavaC++GoTypeScriptRustJavaScript <pre><code>class Solution:\n    def generateParenthesis(self, n: int) -&gt; List[str]:\n        def dfs(l, r, t):\n            if l &gt; n or r &gt; n or l &lt; r:\n                return\n            if l == n and r == n:\n                ans.append(t)\n                return\n            dfs(l + 1, r, t + '(')\n            dfs(l, r + 1, t + ')')\n\n        ans = []\n        dfs(0, 0, '')\n        return ans\n</code></pre> <pre><code>class Solution {\n    private List&lt;String&gt; ans = new ArrayList&lt;&gt;();\n    private int n;\n\n    public List&lt;String&gt; generateParenthesis(int n) {\n        this.n = n;\n        dfs(0, 0, \"\");\n        return ans;\n    }\n\n    private void dfs(int l, int r, String t) {\n        if (l &gt; n || r &gt; n || l &lt; r) {\n            return;\n        }\n        if (l == n &amp;&amp; r == n) {\n            ans.add(t);\n            return;\n        }\n        dfs(l + 1, r, t + \"(\");\n        dfs(l, r + 1, t + \")\");\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;string&gt; generateParenthesis(int n) {\n        vector&lt;string&gt; ans;\n        function&lt;void(int, int, string)&gt; dfs;\n        dfs = [&amp;](int l, int r, string t) {\n            if (l &gt; n || r &gt; n || l &lt; r) return;\n            if (l == n &amp;&amp; r == n) {\n                ans.push_back(t);\n                return;\n            }\n            dfs(l + 1, r, t + \"(\");\n            dfs(l, r + 1, t + \")\");\n        };\n        dfs(0, 0, \"\");\n        return ans;\n    }\n};\n</code></pre> <pre><code>func generateParenthesis(n int) []string {\n    ans := []string{}\n    var dfs func(int, int, string)\n    dfs = func(l, r int, t string) {\n        if l &gt; n || r &gt; n || l &lt; r {\n            return\n        }\n        if l == n &amp;&amp; r == n {\n            ans = append(ans, t)\n            return\n        }\n        dfs(l+1, r, t+\"(\")\n        dfs(l, r+1, t+\")\")\n    }\n    dfs(0, 0, \"\")\n    return ans\n}\n</code></pre> <pre><code>function generateParenthesis(n: number): string[] {\n    function dfs(l, r, t) {\n        if (l &gt; n || r &gt; n || l &lt; r) {\n            return;\n        }\n        if (l == n &amp;&amp; r == n) {\n            ans.push(t);\n            return;\n        }\n        dfs(l + 1, r, t + '(');\n        dfs(l, r + 1, t + ')');\n    }\n    let ans = [];\n    dfs(0, 0, '');\n    return ans;\n}\n</code></pre> <pre><code>impl Solution {\n    fn dfs(left: i32, right: i32, s: &amp;mut String, res: &amp;mut Vec&lt;String&gt;) {\n        if left == 0 &amp;&amp; right == 0 {\n            res.push(s.clone());\n            return;\n        }\n        if left &gt; 0 {\n            s.push('(');\n            Self::dfs(left - 1, right, s, res);\n            s.pop();\n        }\n        if right &gt; left {\n            s.push(')');\n            Self::dfs(left, right - 1, s, res);\n            s.pop();\n        }\n    }\n\n    pub fn generate_parenthesis(n: i32) -&gt; Vec&lt;String&gt; {\n        let mut res = Vec::new();\n        Self::dfs(n, n, &amp;mut String::new(), &amp;mut res);\n        res\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number} n\n * @return {string[]}\n */\nvar generateParenthesis = function (n) {\n    function dfs(l, r, t) {\n        if (l &gt; n || r &gt; n || l &lt; r) {\n            return;\n        }\n        if (l == n &amp;&amp; r == n) {\n            ans.push(t);\n            return;\n        }\n        dfs(l + 1, r, t + '(');\n        dfs(l, r + 1, t + ')');\n    }\n    let ans = [];\n    dfs(0, 0, '');\n    return ans;\n};\n</code></pre>"},{"location":"tags.html","title":"Tags","text":"<p>Below is a list of problems classified by tags, suitable for focused practice on a certain type of problem.</p>"}]}